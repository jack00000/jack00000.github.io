<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[solr配置ik分词器]]></title>
    <url>%2F2018%2F10%2F16%2Fsolr%E9%85%8D%E7%BD%AEik%E5%88%86%E8%AF%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[参考教程1 靠谱教程2就是把一段话分成有逻辑的短语token solr自带的分词拆分不准确(不支持中文分词 所以一个字一个token 英语正常) 为IK Analyzer可以很方便的对词库近些年扩展，所以我在IK Analyzer中加入了搜狗词库的配置，可以最大限度的收录现在一些潮流的词语. 安装步骤 1.IK Analyzer官网下载地址：https://code.google.com/p/ik-analyzer/downloads/list 2.原始的IKAnalyzer已经不支持solr5以后的版本，这里是修改过后的 ik分词github下载 3.没装mvn 为降低学习难度 采用靠谱教程2 4.jar下载地址:https://search.maven.org/search?q=g:com.github.magese 4.非常直观的解释图 5.field ik分词器在managed-schema.xml配置 6.重启./solr restart 7.field 的name重复 报错 解决方法：注释掉一个 8.成功截图 总结： 1.下载jar放在 lib下 2.在managed-schema.xml配置fieldType filed (注意重复)]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用solrj对solr索引库curd]]></title>
    <url>%2F2018%2F10%2F16%2F%E4%BD%BF%E7%94%A8solrj%E5%AF%B9solr%E7%B4%A2%E5%BC%95%E5%BA%93curd%2F</url>
    <content type="text"><![CDATA[用solrj 增删查改 参考教程 找啦无数篇教程 人TM都疯啦 1.参考教程 2.用上面的参考教程完成solr的core的创建 需要注意的是：1.新建field在conf的data.xml 然后在managed-schema.xml引入 2.添加field可以在solr图形化界面添加 3.core 建立成功 选中core dataimprot 导入数据库表数据 query查询 看有没有 4.以上，为solrj的使用打下基础 运行solr为后面做准备 地址:http://localhost:8983/solr/test 5.自带分词器(在analysis里面，稍后介绍ik分词器) 6.新建maven项目 导入solrj等jar包 使用slorj 对solr服务器导入的数据库表数据进行增删查改 6.1 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.millery.spring_solr&lt;/groupId&gt; &lt;artifactId&gt;spring-solr&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 添加依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 6.2 solrtest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.fangjun.test;import org.apache.solr.client.solrj.SolrQuery;import org.apache.solr.client.solrj.SolrServer;import org.apache.solr.client.solrj.impl.HttpSolrServer;import org.apache.solr.client.solrj.response.QueryResponse;import org.apache.solr.common.SolrDocument;import org.apache.solr.common.SolrDocumentList;import org.apache.solr.common.SolrInputDocument;import org.junit.Test;import java.util.List;import java.util.Map;public class solrtest &#123; private static final String url="http://localhost:8983/solr/test"; /* * 测试向索引库中添加文档 */ @Test public void testSave() throws Exception &#123; //1.创建连接对象 HttpSolrServer solrServer = new HttpSolrServer(url); //2.创建一个文档对象 SolrInputDocument inputDocument = new SolrInputDocument(); //向文档中添加域以及对应的值,注意：所有的域必须在schema.xml中定义过,前面已经给出过我定义的域。 inputDocument.addField("id", "1"); inputDocument.addField("name", "sansung爆炸牌手机"); //3.将文档写入索引库中 solrServer.add(inputDocument); //提交 solrServer.commit(); &#125; /* * 测试修改索引库中已存在的文档 */ @Test public void testUpdate() throws Exception &#123; //1.创建连接对象 HttpSolrServer solrServer = new HttpSolrServer(url); //2.创建一个文档对象 SolrInputDocument inputDocument = new SolrInputDocument(); inputDocument.addField("id", "60"); //修改id为1的商品的信息（如果该商品不存在其实就是添加了） inputDocument.addField("name", "vivo手机hahaha"); //3.将文档写入索引库中 solrServer.add(inputDocument); //提交 solrServer.commit(); &#125; /* * 测试删除文档:根据id删除文档 * */ @Test public void testDeleteById() throws Exception&#123; HttpSolrServer solrServer = new HttpSolrServer(url); //删除文档 solrServer.deleteById("1"); //提交 solrServer.commit(); &#125; /* * 测试删除文档:根据查询结果删除文档(重新添加id为1的文档) */ @Test public void testDeleteByQ() throws Exception&#123; HttpSolrServer solrServer = new HttpSolrServer(url); //根据查询结果删除文档，注意：用item_image的查询结果来进行删除是不行的 //因为制定业务域的时候indexed=false,即不被索引，此时是不能根据图片来查询的。 solrServer.deleteByQuery("item_title:vivo手机hahaha"); solrServer.commit(); &#125; /* * 简单查询:查询单个商品信息 */ @Test public void testSimpleQ() throws Exception&#123; //1.创建连接 HttpSolrServer solrServer = new HttpSolrServer(url); //2.创建查询语句 SolrQuery query = new SolrQuery(); //3.设置查询条件 query.set("q", "id:1"); //4.执行查询 QueryResponse queryResponse = solrServer.query(query); //5.取文档列表public class SolrDocumentList extends ArrayList&lt;SolrDocument&gt; SolrDocumentList documentList = queryResponse.getResults(); for (SolrDocument solrDocument : documentList) &#123; //取各个文档信息 System.out.println("商品id:"+solrDocument.get("id")+" "); System.out.println("商品标题:"+solrDocument.get("item_title")+" "); System.out.println("商品价格:"+solrDocument.get("item_price")+" "); System.out.println("商品图片:"+solrDocument.get("item_image")+" "); &#125; &#125; /* * 测试复杂查询：取高亮 */ @Test public void testHighLighting() throws Exception&#123; //1、创建连接 HttpSolrServer solrServer = new HttpSolrServer(url); //2、创建查询语句 SolrQuery query = new SolrQuery(); //3、设置查询条件 query.set("q", "夏普");//设置查询关键字 query.setSort("id", SolrQuery.ORDER.desc);//按照id降序排列 query.setStart(1); query.setRows(5);//分页条件 query.set("df", "item_title"); //开启高亮显示 query.setHighlight(true); query.setHighlightSimplePre("&lt;em&gt;"); query.setHighlightSimplePost("&lt;/em&gt;"); //4、执行查询 QueryResponse queryResponse = solrServer.query(query); //5、取高亮 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); //6、获取文档列表 SolrDocumentList documentList = queryResponse.getResults(); //7、遍历查询结果 for (SolrDocument solrDocument : documentList) &#123; System.out.print(solrDocument.get("id")+" "); List&lt;String&gt; titleList = highlighting.get(solrDocument.get("id")).get("item_title"); if (titleList !=null &amp;&amp; titleList.size()&gt;0) &#123; //能取到高亮,输出高亮 System.out.print(titleList.get(0)); &#125; System.out.println(); &#125; &#125;&#125; 6.3 log4j.properties123456789101112131415161718### set log levels ###log4j.rootLogger = DEBUG,Console,File### 输出到控制台 ###log4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.Target=System.outlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern= %d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### 输出到日志文件 ###log4j.appender.File=org.apache.log4j.RollingFileAppenderlog4j.appender.File.File=/home/demo/Documents/idea_project/solr/src/main/resources/app.loglog4j.appender.File.DatePattern=_yyyyMMdd'.log'log4j.appender.File.MaxFileSize=10MBlog4j.appender.File.Threshold=ALLlog4j.appender.File.layout=org.apache.log4j.PatternLayoutlog4j.appender.File.layout.ConversionPattern=[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n 总结： 1.HttpSolrServer solrServer = new HttpSolrServer(url);//创建链接对象 2.SolrInputDocument inputDocument = new SolrInputDocument();//创建文档对象 3.inputDocument.addField(“id”, “1”);//添加字段信息 这里字段要在服务器定义 有两种查看方法（配置文件、游览器） solrServer.add(inputDocument);//将文档写入索引库中 还有solrServer.deleteById(“1”);solrServer.deleteByQuery(“item_title:vivo手机hahaha”);等 solrServer.commit();//提交]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux安装python3.6]]></title>
    <url>%2F2018%2F10%2F16%2Flinux%E5%AE%89%E8%A3%85Python3.6%2F</url>
    <content type="text"><![CDATA[参考教程1参考教程2 1.下载 1wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz 2.安装 12345678mkdir -p /usr/local/python3、tar -zxvf Python-3.6.1.tgzcd Python-3.6.1//编译安装./configure --prefix=/usr/local/python3make &amp;&amp; make install//过程漫长 但无错//建立python3的软链ln -s /usr/local/python3/bin/python3 /usr/bin/python3 总结 到上面就成功啦 参考教程1写啦多余的东西 结合参考教程2来看]]></content>
  </entry>
  <entry>
    <title><![CDATA[(廖雪峰)Python web实战day01]]></title>
    <url>%2F2018%2F10%2F16%2FPython_day1%2F</url>
    <content type="text"><![CDATA[目的：搭建开发环境 参考教程 1.Python3(低版本安装不了第三方库) 2.pip安装第三方库：异步框架aiohttp 前端模板引擎jinja2 MySQL的Python异步驱动程序aiomysql 3.项目结构1234567891011121314151617awesome-python3-webapp/ &lt;-- 根目录|+- backup/ &lt;-- 备份目录|+- conf/ &lt;-- 配置文件|+- dist/ &lt;-- 打包目录|+- www/ &lt;-- Web目录，存放.py文件| || +- static/ &lt;-- 存放静态文件| || +- templates/ &lt;-- 存放模板文件|+- ios/ &lt;-- 存放iOS App工程|+- LICENSE &lt;-- 代码LICENSE]]></content>
  </entry>
  <entry>
    <title><![CDATA[solr服务器配置]]></title>
    <url>%2F2018%2F10%2F15%2Frecord3%2F</url>
    <content type="text"><![CDATA[solr 入门 教程solr是啥？ Solr是一个类似于Google或者Bing的全文检索引擎， Solr是与搜索引擎优化（SEO）相关联的。很多公司也使用elasticsearch作为搜索引擎。 以前的solr，本质上是一组servlet，必须放进Tomcat才能运行，从solr5开始，它已经自带了jetty，配置的好，完全可以独立使用，并且应付大量并发请求，具体的架构我们后面会讲到，现在先来进行solr的安装配置。solr安装 1.下载tomcat solr 2.在bin下运行 ./solr start 3.教程确认可行 导入数据库数据并查询 中文分词器123456789101112131415161718192021Solr分词顺序]Solr建立索引和对关键词进行查询都得对字串进行分词，在向索引库中添加全文检索类型的索引的时候，Solr会首先用空格进行分词，然后把分词结果依次使用指定的过滤器进行过滤，最后剩下的结果才会加入到索引库中以备查询。分词的顺序如下：索引1：空格whitespaceTokenize2：过滤词(停用词，如：on、of、a、an等) StopFilter3：拆字WordDelimiterFilter4：小写过滤LowerCaseFilter5：英文相近词EnglishPorterFilter6：去除重复词RemoveDuplicatesTokenFilter查询1：查询相近词2：过滤词3：拆字4：小写过滤5：英文相近词6：去除重复词---------------------作者：jakeswang来源：CSDN原文：https://blog.csdn.net/jakeswang/article/details/50598398?utm_source=copy版权声明：本文为博主原创文章，转载请附上博文链接！ 安装见教程遇坑集合 ava.lang.ClassNotFoundException: org.apache.solr.handler.dataimport.DataImportHandler 教程 1.创建core 后 运行slor 并在项目中配置2.开启高亮 solrParams.setHighlight(true);12345678910111213141516171819202122232425262728293031@ResponseBody @RequestMapping(value = "/testHighlight") public void testHighlight() throws SolrServerException &#123; // 以后参数都是通过这个对象去构造... SolrQuery solrParams = new SolrQuery(); solrParams.setQuery("stu_name:测试"); // 开启高亮 solrParams.setHighlight(true); // 高亮显示的格式 solrParams.setHighlightSimplePre("&lt;font color='red'&gt;"); solrParams.setHighlightSimplePost("&lt;/font&gt;"); // 我需要那几个字段进行高亮 solrParams.setParam("hl.fl", "stu_name"); QueryResponse queryResponse = this.httpSolrServer.query(solrParams); // 返回所有的结果... SolrDocumentList documentList = queryResponse.getResults(); Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; maplist = queryResponse.getHighlighting(); // 返回高亮之后的结果.. for (SolrDocument solrDocument : documentList) &#123; Object id = solrDocument.get("id"); Map&lt;String, List&lt;String&gt;&gt; fieldMap = maplist.get(id); List&lt;String&gt; stringlist = fieldMap.get("stu_name"); System.out.println(stringlist); &#125; &#125;&#125;---------------------作者：z_alvin来源：CSDN原文：https://blog.csdn.net/z_alvin/article/details/79305000?utm_source=copy版权声明：本文为博主原创文章，转载请附上博文链接！ 3.java 调用solr 实现索引的增删查改 教程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Controller@RequestMapping("/solr")public class SpringSolrController &#123; @Autowired private HttpSolrServer httpSolrServer; /** * 测试方法 * * @param id * @return * @throws SolrServerException */ @ResponseBody @RequestMapping(value = "/getStudent") public Student getStudent(Long id) throws SolrServerException &#123; // 创建查询条件 SolrQuery query = new SolrQuery(); query.setQuery("id:" + id); // 查询并返回结果 QueryResponse queryResponse = this.httpSolrServer.query(query); return (Student) queryResponse.getBeans(Student.class); &#125; /** * 新增、修改 * * @param student * @throws SolrServerException * @throws IOException */ @ResponseBody @RequestMapping(value = "/addStudent") public void addStudent(@RequestBody Student student) throws SolrServerException, IOException &#123; SolrInputDocument doc = new SolrInputDocument(); doc.addField("id", student.getId()); doc.addField("stu_name", student.getStu_name()); doc.addField("age", student.getAge()); doc.addField("stu_school", student.getStu_school()); UpdateResponse response = this.httpSolrServer.add(doc); this.httpSolrServer.commit(); // 提交 System.out.println(response); &#125; /** * 删除 * * @param student * @throws SolrServerException * @throws IOException */ @ResponseBody @RequestMapping(value = "/delStudent") public void delStudent(@RequestBody Student student) throws SolrServerException, IOException &#123; UpdateResponse response = this.httpSolrServer.deleteById(student.getId()); this.httpSolrServer.commit(); // 提交 System.out.println(response); &#125; @ResponseBody @RequestMapping(value = "/searchStudentList") public void searchStudentList() throws SolrServerException &#123; // 相当于QueryParser SolrQuery query = new SolrQuery("*:*"); query.setStart(1); query.setRows(3); QueryResponse res = this.httpSolrServer.query(query); // 可以直接查询相应的bean对象，但是不是很常用 // 使用这种方式无法获取总数量 List&lt;Student&gt; list = res.getBeans(Student.class); System.out.println("当前总数：" + list.size()); for (Student stu : list) &#123; System.out.println(stu.getId() + "#" + stu.getStu_name() + "#" + stu.getAge() + "#" + stu.getStu_school()); &#125; &#125;---------------------作者：z_alvin来源：CSDN原文：https://blog.csdn.net/z_alvin/article/details/79305000?utm_source=copy版权声明：本文为博主原创文章，转载请附上博文链接！ idea 启动失败 说插件Android初始化错误 删除插件Android 重启 linux下插件所在目录 /opt/idea/plugins]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单独谈谈部署]]></title>
    <url>%2F2018%2F10%2F14%2F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[部署方式 jar warjar： pom.xml 里面修改成jarwar 可cmd命令生成 也可GUI界面生成 用winscp传到服务器 用java -jar demo.jar –server.port=9090 指定端口并运行 即可 （jdk不同 可能报错） 部署springboot项目 与ssm项目不同 jar部署方式 不同点 发现一个坑：在ssh工具运行jar 可以访问 关掉ssh工具 就访问不了啦。 再次运行发现上次运行端口被占用 靠谱教程 后台一直运行 nohup java -jar demo.jar –server.port=8090 &gt;/dev/null &amp; //将程序设置为后台程序 上面报错 ：输入重定向错误 直接nohup java -jar demo.jar 就行啦 什么鬼？？？ 必须要写一下关于永久运行， 不然nohup总错。12nohup java -jar demo.jar --server.port=8090 &gt;/dev/null &amp;nohup java -jar demo.jar war：pom.xml 里面修改成jarwar 可cmd命令生成 也可GUI界面生成 上传到tomcat的webapp目录下 运行tomcat下的 bin目录里的startup.bat war才会解压 即可 第二次部署项目。本地8080运行成功 部署到服务器时改端口运行 显示8080端口被占用。 在本地的Springboot项目中Application.properties server.port:8011 然后就可以啦。。。。以前明明可以强制改端口。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[部署web项目ssm框架的maven项目]]></title>
    <url>%2F2018%2F10%2F14%2F%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AEssm%E6%A1%86%E6%9E%B6%E7%9A%84maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[完整教程简要步骤 一个简单的web项目 主要功能上传显示图片及图片外链到其他网址。在云服务部署此maven项目：安装JAVA tomacat mysql上传jar 数据库文件并引入。并在数据库指定图片路径下上传图片。配置tomcat运行工程所在的目录。 放弃jar上传部署方式 采用war部署方式(只需要把war放在webapps下，Tomcat自动解压，部署多个项目：多个tomcat不同端口) 1.购买阿里云服务器 2.安装环境 （how2j的是centerOs 我用的ubantu 不能用下面的方法）2.1 java环境 yum -y install java-1.8.0-openjdk.x86_64 2.2 mysql安装 2.3 tomcat安装 3.本地生成jar/war并上传，本地生成数据库文件并上传。3.1 准备ftp管理文件传输 ftp安装 与ssh不同 需要创建用户和密码 每个用户对每个文件的访问权限不同 不能用ssh方式 登录ftp3.2 放弃how2j推荐的ftp软件 改用简单易懂的winsp客户端3.3 一级域名（fangjun.xyz）绑定服务器3.4 创建二级域名(eg:xxx.fangjun.xyz)并绑定云服务器上的项目 3.5 域名备案与网站备案（网站备案包括域名和空间，是一起的。）其实，本质上来讲，网站备案和域名备案是指的同一件事情，那就是为你的网站申请ICP备案号，没有本质的区别。 备案是根据空间IP来的。因为域名要访问空间必须要解析指向到一个IP地址。就算是转发也要解析到转发服务器IP地址。所以备案是指的空间的备案，而解析指向到的这个空间的所有的域名要填写进去把域名备案。如果你只有域名，不去用，不解析到任何空间，那是不需要备案的。 总之，域名和空间是一体的。备案中都是不可缺少的。 3.6 域名备案才能创建二级域名解析url （控制台旁边有备案引导） 申请服务号 一步步来 苦尽甘来]]></content>
  </entry>
  <entry>
    <title><![CDATA[语言学第五章作业]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%AF%AD%E8%A8%80%E5%AD%A6%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[Linguistics Homework(5)NO. 1508030403 Name: 方俊 Class: E + Software Engineering, 2015 Date: 04/07/20181. Define the following terms syntax 1In linguistics, syntax is the set of rules, principles, and processes that govern the structure of sentences in a given language, usually including word order. The term syntax is also used to refer to the study of such principles and processes.[3] The goal of many syntacticians is to discover the syntactic rules common to all languages.In mathematics, syntax refers to the rules governing the behavior of mathematical systems, such as formal languages used in logic. recursiveness 1234567Recursion occurs when a thing is defined in terms of itself or of its type. Recursion is used in a variety of disciplines ranging from linguistics to logic. The most common application of recursion is in mathematics and computer science, where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no loop or infinite chain of references can occur.NOUNLogic Mathematics LinguisticsThe property of being recursive; = recursivity.Origin1930s; earliest use found in American Journal of Mathematics. From recursive + -ness. surbordination 1In linguistics, subordination (abbreviated variously subord, sbrd, subr or sr) is a principle of the hierarchical organization of linguistic units. While the principle is applicable in semantics, syntax, morphology, and phonology, most work in linguistics employs the term &quot;subordination&quot; in the context of syntax, and that is the context in which it is considered here. The syntactic units of sentences are often either subordinate or coordinate to each other. Hence an understanding of subordination is promoted by an understanding of coordination, and vice versa. 2. Answer the following questions What’s the name of IC analysis ? Make an IC anaysis od the following sentences by means of either brackets or a tree diagram. 1My mother said Mary liked the handboy Answer What are endocentric constructions and exocentric constructions?1An endocentric construction is one whose distribution is functionally equivalent or approaching equivalence to that of one or more of its constituents i. e. a word or a group of words which serves as a definable center or head. Hence an endocentric construction is also known as a headed construction. Noun phrases like Lovely Lucy are typical endocentric constructions. Opposite of endocentric constructions the exocentric construction refers to a group of syntactically related words where none of the words is functionally equivalent to the group as a whole. There is no noticeable centre or head in it. Prepositional phrases like &quot; on the shelf&quot; are typical examples of this type.]]></content>
  </entry>
  <entry>
    <title><![CDATA[商标翻译]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%AF%AD%E8%A8%80%E5%AD%A6%20%E5%95%86%E6%A0%87%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[做ppt 提高模块复用率，（前端一样）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Loadrunner 自动化测试]]></title>
    <url>%2F2018%2F10%2F14%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[资源下载：HP_LoadRunner_12.50_Community_Edition_HPLR_1250_Community_Edition （ftp 易） 会提示安装 一些依赖 直接确定 更新组件注册 耗时10分钟 装软件耗时45分钟 以上。。。。。。 三剑客出现 即成功 自动化测试 –录制脚本并运行 Virtual User Generator new scrip -》web HTTP/HTML （single protocol 单方面协议） 点击录制 （注意该启动项application 为 除IE以外的游览器） 结束 自动生成代码 运行 会导出测试文档 过程截图未改application项 报错 自动化测试 –实现并发 模拟多个用户访问 Controller 导入脚本 配置场景计划表 运行 过程截图 自动化测试 –分析结果 analysis 找不到现有会话 TMD 设计得一点不人性化 controler 搞到的数据 直接一键分析不就行啦 还要我们去找项目路径，你以为我找得到，我找了半个小时。。。。。。。 有一键分析。。。。。。。。无FUCK可说。。。。。]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打造翻墙路由器]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%BF%BB%E5%A2%99%E8%B7%AF%E7%94%B1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[非常完善的教程 备忘特点：YouTube秒开 网络飞起大致步骤 在openwrt官网 ctrl+F 输入不得游览器型号（如：wd2453） 下载对应固件（找不到就是不支持） 在路由器后台 系统升级 选择该文件升级 配置ss 账号去v2ss买 （其实淘宝上80左右 有帮你刷好的路由器 不喜欢折腾 买吧） 小米路由器mini到手 开搞、所需文件参考教程1 参考教程2 开启ssh-》刷breed-》通过breed GUI安装PADAVAN(因是俄罗斯大神搞得 也称老毛子固件)1.0 找到小米路由器开发板rom （论坛有） 复制放在fat32格式的u盘 插入路由器后通电reset 黄灯闪烁后松开 绿灯表示搞定。1.1 下载ssh 下载地址1.2 刷入路由器 方式同1.02.0 上传breed固件 和 潘多拉固件 注意连ftp时 文件类型鄙视sftp或ftp 时 是scp 。。。。。2.1 固件更新中上传2.2 padavan中ss 的设置 重启后生效 设置教程截图庆祝 刷啦之后网速爆炸！！！！！！NB openwrt：OpenWrt 可以被描述为一个嵌入式的 Linux 发行版，(主流路由器固件有 dd-wrt,tomato,openwrt三类)而不是试图建立一个单一的、静态的系统。OpenWrt的包管理提供了一个完全可写的文件系统，从应用程序供应商提供的选择和配置，并允许您自定义的设备，以适应任何应用程序。对于开发人员，OpenWrt 是使用框架来构建应用程序，而无需建立一个完整的固件来支持;对于用户来说，这意味着其拥有完全定制的能力，可以用前所未有的方式使用该设备。 潘多拉固件： 梅林固件： openwrt 最原始 潘多拉固件 梅林固件使用起来方便 如自带ss插件 带ss插件的固件集合 不翻墙看不了。。。-]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[票务管理系统day_1]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%A5%A8%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fday_1%2F</url>
    <content type="text"></content>
      <categories>
        <category>实验项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 使用泛型 通配符 子类泛型不可以转换为父类泛型 父类泛型不能转型为子类泛型]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>skills javas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派制作炫酷电视盒子]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C%E7%82%AB%E9%85%B7%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[简要步骤 优点：优酷高清片源无广告 无需vip 高清真爽 （目前已知） （以前看片模式：百度云+谷歌+枪片网站 =基本无高清） osmc官网下载镜像 通过win32Diskimage 烧录到TF 并装在树莓派上 zip安装片源插件 看如 百度云 blibli 等视屏 两大插件集群：kodi官网 github项目 xbmc-addons-chinese （直接下载zip安装） 具体操作 烧录 (跟Lakke 一样 ) 看到此页面等4,5分钟即可 中文有乱码 语言设置为英文 zip安装插件（无法识别u盘） 用winsp 软件 成功装逼(u盘突然之间出现在树莓派列表中啦 无语) 解决中文乱码 教程 别换skin 一换就出现乱码 改都改不回来！！！！！设置中文输入法 教程 优酷的搜索很鸡肋，只能搜索当前文件夹的项目]]></content>
  </entry>
  <entry>
    <title><![CDATA[象棋棋盘]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;graphics.h&gt; // 绘图库头文件，绘图语句需要#include &lt;conio.h&gt; // 控制台输入输出头文件，getch()语句需要void main()&#123; initgraph(500, 550); // 初始化640x480的绘图屏幕 setbkcolor(RGB(255, 255, 255)); //加载图片 clearcliprgn(); for (int i = 50; i &lt;= 450; i = i + 50) &#123; setlinecolor(RGB(200, 0, 0)); line(i, 50, i, 250); line(i, 300, i, 500); &#125; for (int i = 50; i &lt;= 500; i = i + 50) &#123; setlinecolor(RGB(200, 0, 0)); line(50, i, 450, i); &#125; //将 士 line(200, 50, 300, 150); line(200, 150, 300, 50); line(200, 500, 300, 400); line(200, 400, 300, 500); line(50, 250, 50, 300); line(450, 250, 450, 300); //图片 IMAGE img; // 定义 IMAGE 对象 loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BRS.GIF"); // 读取图片黑车到 img 对象中 putimage(30, 30, &amp;img); // 在坐标 (0, 0) 位置显示 IMAGE 对象 IMAGE img2; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BA.GIF");//黑士 putimage(180, 30, &amp;img); IMAGE img3; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BB.GIF");//黑象 putimage(130, 30, &amp;img); IMAGE img4; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BKS.GIF");//黑将 putimage(230, 30, &amp;img); IMAGE img5; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BNS.GIF");//黑马 putimage(80, 30, &amp;img); IMAGE img6; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BAS.GIF");//黑士 putimage(280, 30, &amp;img); IMAGE img7; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BBS.GIF");//黑象 putimage(330, 30, &amp;img); IMAGE img8; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BNS.GIF");//黑马 putimage(380, 30, &amp;img); IMAGE img9; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BR.GIF");//黑车 putimage(430, 30, &amp;img); IMAGE img10; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BP.GIF");//黑卒 putimage(30, 180, &amp;img); IMAGE img11; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BP1.GIF");//黑卒 putimage(130, 180, &amp;img); IMAGE img12; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BP2.GIF");//黑卒 putimage(230, 180, &amp;img); IMAGE img13; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BP3.GIF");//黑卒 putimage(330, 180, &amp;img); IMAGE img14; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BP4.GIF");//黑卒 putimage(430, 180, &amp;img); IMAGE img15; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BC.GIF");//黑炮 putimage(80, 130, &amp;img); IMAGE img16; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\BCS.GIF");//黑炮 putimage(380, 130, &amp;img); //红方 IMAGE img17; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RK.GIF");//红帅 putimage(230, 480, &amp;img); IMAGE img18; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RA.GIF");//红士 putimage(180, 480, &amp;img); IMAGE img19; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RAS.GIF");//红士 putimage(280,480, &amp;img); IMAGE img20; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RB.GIF");//红相 putimage(130, 480, &amp;img); IMAGE img21; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RBS.GIF");//红相 putimage(330, 480, &amp;img); IMAGE img22; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RN.GIF");//红马 putimage(380, 480, &amp;img); IMAGE img23; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RNS.GIF");//红马 putimage(80, 480, &amp;img); IMAGE img24; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RR.GIF");//红车 putimage(30, 480, &amp;img); IMAGE img25; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RR.GIF");//红车 putimage(30, 480, &amp;img); IMAGE img26; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RR.GIF");//红车 putimage(30, 480, &amp;img); IMAGE img36; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RRS.GIF");//红车 putimage(430, 480, &amp;img); IMAGE img27; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RPS.GIF");//红卒 putimage(30, 330, &amp;img); IMAGE img28; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RPS1.GIF");//红卒 putimage(130, 330, &amp;img); IMAGE img29; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RPS2.GIF");//红卒 putimage(230, 330, &amp;img); IMAGE img30; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RPS3.GIF");//红卒 putimage(330, 330, &amp;img); IMAGE img31; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RPS4.GIF");//红卒 putimage(430, 330, &amp;img); IMAGE img32; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RC.GIF");//红车 putimage(80, 380, &amp;img); IMAGE img33; loadimage(&amp;img, "C:\\IMAGES_S\\POLISH\\RCS.GIF");//红车 putimage(380, 380, &amp;img); _getch(); // 按任意键 closegraph(); // 关闭绘图屏幕&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[显卡颜色优化设置]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%98%BE%E5%8D%A1%E9%A2%9C%E8%89%B2%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折半查找]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718public void search(int[] array,int key)&#123; int low,high,mid; low=0; high=array.length-1; while(low&lt;=high)&#123; mid=(low+high)/2; if(array[mid]&gt;key)&#123; high=mid-1; &#125; else if(array[mid]&lt;key)&#123; low=mid+1; &#125; else if(array[mid]==key)&#123; return mid; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python programing c++ Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 常见异常ParseException 解析异常，日期字符串转换为日期对象的时候，有可能抛出的异常OutOfIndexException 数组下标越界异常OutOfMemoryError 内存不足ClassCastException 类型转换异常ArithmaticException 除数为零NullPointerException 空指针异常 try-catch 多异常处理1/2 finally:无论是否出现异常，finally中的代码都会被执行 throw和throws throws 出现在方法声明上，而throw通常都出现在方法体内。 throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。 可查异常 CheckedException。可查异常即必须进行处理的异常，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException如果不处理，编译器，就不让你通过 运行时异常：编译不会出错 错误：指的是系统级别的异常，通常是内存用光了在默认设置下，一般java程序启动的时候，最大可以使用16m的内存如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出OutOfMemoryError与运行时异常一样，错误也是不要求强制捕捉的。 Throwable:Throwable是类，Exception和Error都继承了该类所以在捕捉的时候，也可以使用Throwable进行捕捉如图： 异常分Error和ExceptionException里又分运行时异常和可查异常。 自定义异常 课后习题1 课后习题2]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>skills javas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找软件资源的步骤]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%BD%93%E4%BD%A0%E6%89%BE%E4%B8%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E6%97%B6%2F</url>
    <content type="text"><![CDATA[关注 微信号 软件安装管家 里面有各种软件 及教程 日常收集破解版软件 如：Adobe 全套等 上官网 如：python git node.js等 上how2j搜索 如：Navicat… 去下载吧 绿色软件联盟搜索 官网下载找注册码 注册码找不到 如Navicat 重装一遍就可以用]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.类图]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奬眷数目]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%A5%96%E5%8D%B7%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[问题描述：奖券数目有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。请提交该数字（一个整数），不要写任何多余的内容或说明性文字。思路：5重循环，第一重为1-9，其余为0-9（这样就可以遍历10000到99999之间的全部数字），并且判断条件为每一个变量都不能为4。 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int a,b,c,d,e; int count=0; for(a=1;a&lt;10;a++)&#123; for(b=0;b&lt;10;b++)&#123; for(c=0;c&lt;10;c++)&#123; for(d=0;d&lt;10;d++)&#123; for(e=0;e&lt;10;e++)&#123; if(a!=4&amp;&amp;b!=4&amp;&amp;c!=4&amp;&amp;d!=4&amp;&amp;e!=4)&#123; count++; &#125; &#125; &#125; &#125; &#125; &#125; printf("%d",count);&#125; 结果：52488]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python programing c++ Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多系统系统启动盘制作与安装细节]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%A4%9A%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%AE%89%E8%A3%85%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[还原备份装机方法（来自 微信公众号：软件安装管家）报错几率小 自己的电脑是固态，装机方式随意点，没啥大问题。 别人机械硬盘的电脑 准备就绪就要10多分钟，安装成功后的引导 海内存知己天涯若比邻 5分钟 。。。 微信关注 软件安装管家 U盘安装pe系统 U盘安装win0系统 制作启动u盘装机方法 （不同电脑会遇到各种奇葩问题 如下：） 报错几率大 安装引导选择安装盘时，无法格式化以便后续安装。 卡在准备就绪10多分钟后报错。提示找不到安装文件。解救方法 删除efi相关文件 在bios更改硬盘模式 ahci winsetupfromusb软件 简单不赘述 完整教程sdformatters软件可以低级格式化tf sd U盘。。。皮。。。（当你刷失败注意一下） 遇到问题 – 无法重复刷同一类型(如win7/8/10)的系统 按照 完整教程 的方法 软件提示格式化 （取消atuo format后 可行）目前有unbantu win10企业版 win7企业版 以后可以叠加。。。。。皮。。。 遇到问题 – 系统之家的纯净版win10无法导入 msdn的可以 不知道什么原理 msdn的系统安装需要序列号 （网上说可跳过，实际操作貌似不行） win10安装密匙/激活密匙若还是不行 加群号 589766974或者 直接去系统之家类似的网站下载原版镜像 （然后用软碟通 winsetupfromusb好像不识别系统之家的镜像） 安装的系统没网卡驱动 – 带网卡驱动的驱动精灵 刚发现：这个软件刷完系统后 不能或存入文件失败。机械硬盘 操作类似 遇到问题：刷完之后插电脑上，未识别的usb设备-》原因竟是没插好（我反复插拔几次才能识别）]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 创建多线程有3种方式，分别是继承线程类,实现Runnable接口,匿名类 继承线程类 实现Runnable接口 匿名类 最骚操作 常见方法 线程优先级 setPriority（Thread.MAX_PRIORITY） 临时暂停 yield Thread.yield(); 守护线程 t1.setDaemon(true); 同步与互斥： 多个线程同时使用一个资源-&gt;产生脏数据—&gt;所以要互斥 eg:多个线程同时修改一个值，最后结果不一定正确。 使用synchronized 解决同步问题]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>skills javas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechar robot]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[python的安装 pip的安装 下载weBot源码 注册图灵账号并创建机器人获得apikey 然后开始搞事情 1.python的安装 pip的安装 别忘啦配置路径 python安装 重点说pip（为安装一些依赖库而生）这个坑python官网下载文件如图 打开cmd 直接输入python 结果如下，则python已搞定注意 需要将pip的路径配给系统变量Path 需要将python安装目录下的Scripts文件路径陪给系统变量Path 配置好的pip，运行如下： 注册图灵账号并获得apikey 搞事情详情见wxbot的readme.md 在bot.py所在目录下新建conf.ini配置文件 里面的内容 运行bot.py(用cmd打开bot.py文件所在目录) 用手机微信扫描二维码登录 扫描后如下： 到这步就成功啦 要注意的是 群聊@你的备注 机器人不回复，将你的备注改成你的用户名就行拉 效果如图]]></content>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.类图]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[专四]]></title>
    <url>%2F2018%2F10%2F14%2F%E4%B8%93%E5%9B%9B%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[基本考试信息 听力2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 待定写作 20分 计划15分单选 完型 与阅读 50分 计划30分以上]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三羊献瑞]]></title>
    <url>%2F2018%2F10%2F14%2F%E4%B8%89%E7%BE%8A%E7%8C%AE%E7%91%9E%2F</url>
    <content type="text"><![CDATA[观察下面的加法算式： 祥 瑞 生 辉 三 羊 献 瑞 三 羊 生 瑞 气其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。思路：看到此题，第一反应便是有多少个不同的字便用几重循环来控制，循环内的判断条件便是两个四位数的和等于一个五位数。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int main(int argc,char *argv[])&#123; int a,b,c,d,e,f,g,h;//祥，瑞，生，辉，三，羊，献，气 int sum=0,sum1=0,sum2=0; for(a=1;a&lt;=9;a++)//从1开始，因为数字首位不能为0 for(b=0;b&lt;=9;b++) for(c=0;c&lt;=9;c++) for(d=0;d&lt;=9;d++) for(e=1;e&lt;=9;e++)//从1开始，因为数字首位不能为0 for(f=0;f&lt;=9;f++) for(g=0;g&lt;=9;g++) for(h=0;h&lt;=9;h++) &#123; if(a!=b&amp;&amp;a!=c&amp;&amp;a!=d&amp;&amp;a!=e&amp;&amp;a!=f&amp;&amp;a!=g&amp;&amp;a!=h &amp;&amp; b!=c&amp;&amp;b!=d&amp;&amp;b!=e&amp;&amp;b!=f&amp;&amp;b!=g&amp;&amp;b!=h &amp;&amp; c!=d&amp;&amp;c!=e&amp;&amp;c!=f&amp;&amp;c!=g&amp;&amp;c!=h &amp;&amp; d!=e&amp;&amp;d!=f &amp;&amp;d!=g&amp;&amp;d!=h &amp;&amp; e!=f&amp;&amp;e!=g&amp;&amp;e!=h &amp;&amp; f!=g&amp;&amp;f!=h &amp;&amp; g!=h)&#123; sum1=a*1000 + b*100 + c*10 + d; sum2=e*1000 + f*100 + g*10 + b; sum = e*10000 + f*1000 + c*100 + b*10 + h; if(sum==sum1+sum2)&#123; cout&lt;&lt;e&lt;&lt;f&lt;&lt;g&lt;&lt;b; break; &#125; &#125; &#125;&#125; 结果：1085]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python programing c++ Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechar robot]]></title>
    <url>%2F2018%2F10%2F14%2Fwechar%20robot%2F</url>
    <content type="text"><![CDATA[python的安装 pip的安装 下载weBot源码 注册图灵账号并创建机器人获得apikey 然后开始搞事情 1.python的安装 pip的安装 别忘啦配置路径 python安装 重点说pip（为安装一些依赖库而生）这个坑python官网下载文件如图 打开cmd 直接输入python 结果如下，则python已搞定注意 需要将pip的路径配给系统变量Path 需要将python安装目录下的Scripts文件路径陪给系统变量Path 配置好的pip，运行如下： 注册图灵账号并获得apikey 搞事情详情见wxbot的readme.md 在bot.py所在目录下新建conf.ini配置文件 里面的内容 运行bot.py(用cmd打开bot.py文件所在目录) 用手机微信扫描二维码登录 扫描后如下： 到这步就成功啦 要注意的是 群聊@你的备注 机器人不回复，将你的备注改成你的用户名就行拉 效果如图]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F14%2FUnity3d%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[VIM vs GUI文本编辑器]]></title>
    <url>%2F2018%2F10%2F14%2Fvim%E4%B8%8EGUI%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[vim 无法从外部复制常用命令 esc 编辑模式/命令项模式-&gt;命令模式 a A 命令模式-&gt;编辑模式 ： 命令模式-&gt;命令项模式 GUI文本编辑器 改系统文件的权限问题 不能直接右键文件以管理员打开 要先以管理员打开文件所在文件夹 deepin(linux) 配置java环境 在终端用文本编辑器打开/etc/profile 1gedit etc/profile 在profile文件末尾加入： 123export JAVA_HOME=jdk安装路径export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tomcat和maven的安装]]></title>
    <url>%2F2018%2F10%2F14%2Ftomcat%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_j2ee项目练习]]></title>
    <url>%2F2018%2F10%2F14%2Ftmall_j2ee%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[h3&gt;完整教程：how2j 备忘 1.建表（根据表设计尸体类） 用户表 user name id password 分类表 catagoryprivate String name;private int id;List products;List&lt;List&gt; productsByRow; 属性表 Propertyprivate String name; private Category category; private int id; 产品表 Productprivate String name; private String subTitle; private float orignalPrice; private float promotePrice; private int stock; private Date createDate; private Category category; private int id; private ProductImage firstProductImage; private List productImages; private List productSingleImages;// private List productDetailImages; private int reviewCount; private int saleCount;4 产品图片表 ProductImageprivate String type; private Product product; private int id; 属性值表 PropertyValueprivate String value; private Product product; private Property property;//注意 这里是property的对象 private int id;]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F14%2Ftext%2F</url>
    <content type="text"><![CDATA[s'v'g'se'g'b'r're]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot处理表单form提交的数据]]></title>
    <url>%2F2018%2F10%2F14%2Fspringboot%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95form%E6%8F%90%E4%BA%A4%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[宿舍管理系统前端一览 在themeleaf+springboot中实现表单的数据传递。 新建实体类Greeting 新建Controller类GreetingController 新建html：greeting.html 新建html：result.html 知道GetMapping/PostMapping 当提交form时 GetMapping将对象传入form form将数据封装进对象th:object=”${greeting}” th:action=”@{/greeting}”将对象传入指定页面result.html result.html取出对象属性并显示 注意：引入 不然 th报错。 123456789101112131415161718//使用默认构造方法public class Greeting &#123; private long id; private String content; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 1234567891011121314151617//三个Mapping@Controllerpublic class GreetingController &#123; //传入greeting对象实现封装 @GetMapping("/greeting") public String greetingForm(Model model) &#123; model.addAttribute("greeting", new Greeting()); return "greeting"; &#125; //将封装的对象转入result.html @PostMapping("/greeting") public String greetingSubmit(@ModelAttribute Greeting greeting) &#123; return "result"; &#125;&#125; 1234567891011121314151617&lt;!-- greeting.html --&gt;&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Form&lt;/h1&gt;&lt;!-- action:greeting 先通过GetMapping得到对象用于封装数据，在通过PostMapping传递数据 --&gt;&lt;form action="#" th:action="@&#123;/greeting&#125;" th:object="$&#123;greeting&#125;" method="post"&gt; &lt;p&gt;Id: &lt;input type="text" th:field="*&#123;id&#125;" /&gt;&lt;/p&gt; &lt;p&gt;Message: &lt;input type="text" th:field="*&#123;content&#125;" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit" /&gt; &lt;input type="reset" value="Reset" /&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!-- result.html --&gt;&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Result&lt;/h1&gt;&lt;p th:text="'id: ' + $&#123;greeting.id&#125;" /&gt;&lt;p th:text="'content: ' + $&#123;greeting.content&#125;" /&gt;&lt;a href="/greeting"&gt;Submit another message&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; springboot+themeleaf 如何在html中引入html123&lt;div th:replace="navbar :: html"&gt;&lt;/div&gt;&lt;!--jsp引入jsp 则是--&gt;&lt;%@ include file="inlayingJsp.jsp" %&gt;]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis 轻量级数据库 学习]]></title>
    <url>%2F2018%2F10%2F14%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis:HashMap，不是在JVM中运行，而是以一个独立进程的形式运行 完整教程 how2j1.安装并运行 2.用java操作 需要导jedis包 3.不同数据类似的运用方式 – 留着需要再学。。。。皮]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F14%2Fpoem(%E8%8B%B1%E7%BE%8E%E6%96%87%E5%AD%A6)%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PAT知识点]]></title>
    <url>%2F2018%2F10%2F14%2FPAT%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[vector12345678910vecotr&lt;int&gt; // 声明向量容器 TM就是指针组 大小不确定vector&lt;int&gt; v(n);//见乙级1065vector&lt;int&gt;::iterator//定义向量迭代器vector&lt;int&gt;::iterator result=find(v.begin(),v.end(),table[v[i]]);// 见1065v.push_back(v[i]);//在v的末尾增加一个值为v[i]的元素举个例子for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) cout&lt;&lt;*it&lt;&lt;endl;就把里面的内容都输出了 函数algorithm1234567以很好的平均效率排序 sort()sort(doge.begin(),doge.end());//见1065排序，并维持相同元素的原有顺序 stable_sort()将序列的前一部分排好序 partial_sort()复制的同时将序列的前一部分排好序 partial_sort_copy()在序列中找出某个值的第一次出现的位置 find()find(v.begin(),v.end(),table[v[i]]);//table[v[i]]为要找的元素 见乙级1065 qsort1234567891011121314151617181920212223242526272829qsort（即，quicksort）主要根据你给的比较条件给一个快速排序，主要是通过指针移动实现排序功能。排序之后的结果仍然放在原来数组中。参数意义如下:第一个参数 base 是 需要排序的目标数组名（或者也可以理解成开始排序的地址，因为可以写&amp;s[i]这样的表达式）第二个参数 num 是 参与排序的目标数组元素个数第三个参数 width 是单个元素的大小（或者目标数组中每一个元素长度），推荐使用sizeof(s[0]）这样的表达式第四个参数 compare 就是让很多人觉得非常困惑的比较函数啦int compare(const void *a_t, const void *b_t)&#123; int *a = (int *)a_t, *b = (int *)b_t; if(a[3] != b[3])&#123; return a[3] - b[3]; //type升序 &#125; else if(a[1] + a[2] != b[1] + b[2])&#123; return (b[1] + b[2]) - (a[1] + a[2]); //总分降序 &#125; else if(a[1] != b[1])&#123; return b[1] - a[1]; //德分降序 &#125; else&#123; return a[0] - b[0]; //学号升序 &#125;&#125;int main()&#123;qsort(&amp;sTable[0], n, sizeof(sTable[0]), compare);//数组名 元素个数 单个元素大小 比较函数&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Oracle 11g 安装 与使用]]></title>
    <url>%2F2018%2F10%2F14%2FOracle%2011g%20%E5%AE%89%E8%A3%85%20%E4%B8%8E%E4%BD%BF%E7%94%A8%20%2F</url>
    <content type="text"><![CDATA[下载地址 服务器安装 客户端安装备忘注意 下载两个文件 然后一起解压 -》得到安装文件 客户端也在里面 非GUI界面。。。不同于mysql oracle 有三个控制 OEM /SQL PLUS/SQL DEVELOPER 使用OEM 企业管理器 在游览器打开 网址 输入默认用户名 system 与密码 使用sql plus==Mysql命令行 使用 PL/SQL DEVELOPER与Mysql-fontGUI程序使用差别太大 1.新建数据库 （多个表空间组成数据库 一次只能连接一个数据库 切换 点 file new instance） 2.建表空间 建表 打开sql windows、 新建表空间 12345create tablespace booksales datafile &apos;/opt/oracle/db01/app/oracle/oradata/OSSORCL/booksales.dbf&apos;size 10Mautoextend on next 100Mmaxsize 500Mlogging online permanent; --一直在线 向表空间添加数据文件 1234alter tablespace booksales add datafile &apos;/opt/oracle/db01/app/oracle/oradata/OSSORCL/venn02.dbf&apos;size 10Mautoextend on next 100Mmaxsize 500M ; 删除表空间及数据文件 1drop tablespace venn including contents and datafiles; 建表并指定表空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647create table customers( id number primary key, name varchar2(30) not null, phone number not null, email varchar2(30), address varchar2(30), code varchar2(30)) tablespace booksales;create table publishers( id number primary key, name varchar2(30), phone number, contaxt varchar2(30)) tablespace booksales;create table books( id number primary key, title varchar2(30), cost number, retail number) tablespace booksales;create table orders( order_id number primary key, custom_id number primary key, orderdate varchar2(30), shipdata varchar2(30)) tablespace booksales;create table orderitem( order_id number primary key, item_id number, ISBN varchar2(30)) tablespace booksales;create table promotion( gift_id number primary key, name varchar2(30), minretail number, maxretail number) tablespace booksales; 查询表空间的表 select table_name ,tablespace_name from dba_tables where tablespace_name= ‘BOOKSALES’ 3.CURD 插入 12insert into customers (id,name,phone,email,address,code) values(1,&apos;方俊&apos;,450,200,45,3,300);commit; 删除 1delete from customers where id = 1 修改 1update customers set phone = 1112323246 where id = 1; 查询 1select * from customers 创建视图 1234create view herosimple as ( select id, name from hero)select * from herosimple; 关联查询 123select e.first_name,d.department_name from hr.employees eleft join hr.departments don e.department_id = d.department_id 4.插入数据 5.创建视图 eg：创建一个视图customer_gift 获得 name ISBN custom_id1234create view customer_gift as( select name,ISBN,custom_id from customers cross join orderitem )select * from customer_gift; 6.创建角色并为角色授权 有三种角色 connect resouse dba创建用户 并赋予管理员等权限 create user test identified by test; grant connect, resource to test; revoke connect, resource from test;创建角色并赋予查找customers表的权限 create role fang; grant select on customes to fang; drop role fang;]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库操作]]></title>
    <url>%2F2018%2F10%2F14%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 连接数据库 导jar包 和代码如下 12345678910111213141516171819202122232425262728293031323334public class TestJDBC &#123; public static void main(String[] args) &#123; //初始化驱动 try &#123; //驱动类com.mysql.jdbc.Driver //就在 mysql-connector-java-5.0.8-bin.jar中 //如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException Class.forName("com.mysql.jdbc.Driver"); // 建立与数据库的Connection连接 // 这里需要提供： // 数据库所处于的ip:127.0.0.1 (本机) // 数据库的端口号： 3306 （mysql专用端口号） // 数据库名称 how2java // 编码方式 UTF-8 // 账号 root // 密码 admin Connection c = DriverManager .getConnection( "jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8", "root", "admin"); System.out.println("连接成功，获取连接对象： " + c); System.out.println("数据库驱动加载成功 ！"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 对数据库增删查改 Statement 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;...Statement s = c.createStatement(); // 准备sql语句 // 注意： 字符串要用单引号' String sql = "insert into hero values(null,"+"'提莫'"+","+313.0f+","+50+")"; s.execute(sql); System.out.println("执行插入语句成功");``` - 关闭连接：数据库的连接是有限资源，相关操作结束后，养成关闭数据库的好习惯先关闭Statement后关闭Connection```javaConnection c = null; Statement s = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8", "root", "admin"); s = c.createStatement(); String sql = "insert into hero values(null," + "'提莫'" + "," + 313.0f + "," + 50 + ")"; s.execute(sql); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; // 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯 // 先关闭Statement if (s != null) try &#123; s.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 后关闭Connection if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; idea 连接mysql数据库 和eclipse一样 注意如何导包]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql5.0+Navicat for MySQL安装]]></title>
    <url>%2F2018%2F10%2F14%2FMysql5.0%2BNavicat%20for%20MySQL%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j]]></title>
    <url>%2F2018%2F10%2F14%2FLog4j%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 导入jar包 新建类并运行 Log4j配置 log4j.properties log4j.xml log4j输出到文件 1234567891011121314151617package log4j;import org.apache.log4j.Logger;import org.apache.log4j.PropertyConfigurator;public class TestLog4j&#123; //getLogger()获取需要打印日志的对象 static Logger logger=Logger.getLogger(TestLog4j.class); public static void main(String[] args) &#123; //到处logj日志的配置文件 输出的设置 如输出到控制台，输出到文件 PropertyConfigurator.configure("E:\\project\\log4j\\src\\log4j.xml"); for(int i=0;i&lt;5000;i++) &#123; logger.info("输出信息"); logger.warn("警告信息"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怀旧游戏平台Lakka]]></title>
    <url>%2F2018%2F10%2F14%2FLakka%2B%E6%A0%91%E8%8E%93%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[完整教程 树莓派实验室基本步骤 win32diskimage 烧录Lakka 启动树莓派 并联局域网加入游戏rom到roms (网络共享/winscp) 遇到问题 tf卡低级格式化工具 sdformatter tf卡刷过linux 导致写入失败 提示：拒绝访问 ——》这个报错多半是tf卡的问题 不要快速格式化 要低级格式化(低格之前有两个盘 容量加起来还没1g)成功提示 不知道为什么 本来低格剩下一个盘 成功它弹出另一个盘让你格式化 别格式化。。。。。。。给树莓派通电 连接显示器给Lakka装游戏 打开Lakka的文件共享服务和ssh服务 设置（第二个图标）-&gt; Lakka service 我的电脑 -》网络 -》局域网共享手段失败 winsp 软件 （需获得树莓派IP） 类似ftp服务器客户端 输入树莓派IP 用户名 root 密码 root 连接后传入游戏压缩包到roms 注意：刷进去后 重启还要等一段时间 系统才打得开。 然后scan 扫描你的roms文件夹 完成（不完成也行） 到第一个图标 用核心打开的游戏 注意：有的核心不适应你选的游戏 NES第三个 我用着没问题 游戏实例 手柄推荐 hori Lakka 属于pc端 手柄连接时 要等一段时间 2号灯常亮则连接成功]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jsp与servlet的区别]]></title>
    <url>%2F2018%2F10%2F14%2Fjsp%E4%B8%8Eservlet%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[JSP在本质上就是SERVLET,但是两者的创建方式不一样.Servlet完全是JAVA程序代码构成擅长于流程控制和事务处理而通过Servlet来生成动态网页;JSP由HTML代码和JSP标签构成，可以方便地编写动态网页因此在实际应用中采用Servlet来控制业务流程,而采用JSP来生成动态网页.在struts框架中,JSP位于MVC设计模式的视图层,而Servlet位于控制层. JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2018%2F10%2F14%2FJDBC%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 建立与数据库的连接 Statement是用于执行SQL语句的，比如增加，删除(statement有三个包有，mysql才是对的) 增删 改 查询 PreparedStatement:PreparedStatement有预编译机制，性能比Statement更快 insert不用拼接 事务：有事务的前提下 在事务中的多个操作，要么都成功，要么都失败 ORM:Object Relationship Database Mapping 对象和关系数据库的映射 简单说，一个对象，对应数据库里的一条记录 DAO:DataAccess Object 数据库访问对象hero类heroDAO类]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java web]]></title>
    <url>%2F2018%2F10%2F14%2Fjava%20web%20%E9%A1%B9%E7%9B%AE%20how2j.cn%2F</url>
    <content type="text"><![CDATA[学习易忘知识点截图]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA实验题]]></title>
    <url>%2F2018%2F10%2F14%2FJAVA%E5%AE%9E%E9%AA%8C%E9%A2%98%2F</url>
    <content type="text"><![CDATA[01123456789public class HelloWorld &#123; public static void main(String []args) &#123; System.out.println(" J A V V A "); System.out.println(" J A A V V A A"); System.out.println("J J AAAAA V V AAAAA"); System.out.println(" JJ A A V A A"); &#125;&#125; 0212345678public class HelloWorld &#123; public static void main(String []args) &#123; float pai; pai=4*(1-1/3+1/5-1/7+1/9-1/11+1/13); System.out.println("pai="+pai); &#125;&#125; 03123456789101112131415161718192021222324252627import java.util.Scanner;public class A*B&#123; public static void main(String[] args) &#123; double a[3][3],b[3][3]; double [][] A=&#123;&#123;a[0][0],a[0][1],a[0][2]&#125; &#123;a[1][0],a[1][1],a[1][2]&#125; &#123;a[2][0],a[2][1],a[2][2]&#125;&#125; double [][] B=&#123;&#123;b[0][0],b[0][1],b[0][2]&#125; &#123;b[1][0],b[1][1],b[1][2]&#125; &#123;b[2][0],b[2][1],b[2][2]&#125;&#125; double [][] C=&#123;&#123;c[0][0],c[0][1],c[0][2]&#125; &#123;c[1][0],c[1][1],c[1][2]&#125; &#123;c[2][0],c[2][1],c[2][2]&#125;&#125; //输入 Scanner in=new Scanner(System in); a[3][3]=scanner.nextLine(); b[3][3]=scanner.nextLine(); //计算 for(int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; double m+=a[i][j]*b[j][i] &#125; &#125; &#125;&#125; 04 矩阵相乘算法12345678910111213141516171819202122232425262728293031323334353637383940public class ArrayMult &#123; public static void main(String[] args) &#123; int[][] a = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; int[][] b = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;; //m表示数组a的行数，n表示数组b的列数，s表示数组a的列数和数组b的行数 int m = a.length, n = b[0].length, s1 = a[0].length, s2 = b.length; //判断两个数组是否能够相乘求积 if(s1 != s2) &#123; System.out.println("数组不能相乘，数组a的列数不等于数组b的行数"); return; &#125; //动态创建数组c用来保存结果 int[][] c = new int[m][n]; for(int i=0; i&lt;m; i++) //i表示数组c的每一行 for(int j=0; j&lt;n; j++) &#123; //j表示数组c的每一列 int temp = 0; for(int k=0; k&lt;s1; k++) //k表示数组a的列号和数组b的行号 temp+=a[i][k]*b[k][j]; c[i][j] = temp; &#125; print(a); print(b); print(c); &#125; private static void print(int[][] c) &#123; int m = c.length; int n = c[0].length; for(int i=0; i&lt;m; i++) &#123; for(int j=0; j&lt;n; j++) &#123; if(c[i][j]&lt;10) System.out.print(" "); System.out.print(c[i][j] + " "); &#125; System.out.println(); &#125; System.out.println("--------------------------------------"); &#125; &#125; 061234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class FingNearstPoints&#123; public static void main(String[] args) &#123; //输入 Scanner input=new Scanner(System in); System.out.println("Enter the number of points:"); int numberOfPoints=intput.nextLine(); // double[][] points=new double[numberOfPoints][2]; System.out.println("Enter"+numberOfPoints+"points"); for(int i=0;i&lt;points.length;i++)&#123; points[i][0]=input.nextDouble(); points[i][1]=input.nextDouble(); &#125; int p1=0,p2=1; double shortDistance=distance(points[p1][0],points[p1][1],points[p2][0],points[p2][1]); for(int i=0;i&lt;points.length;i++)&#123; for(int j=i+1;j&lt;points.length;j++)&#123; double distance=distance(points[i][0],points[i][10],points[j][0],points[j][10]); if(shortDistance&gt;distance)&#123; p1=i;p2=j; shortDistance=distance; &#125; &#125; &#125; System.out.println("The two points are"+"("+points[p1][0]+","+points[p1][1]+")and("+points[p2][0]+","+points[p2][1]+")"); &#125; public static double distance (double x1,double y1,double x2,double y2) &#123; return Math.sqrt(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); &#125; &#125;&#125; 03 日历 时钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466package textchess;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Graphics;import java.util.Date; import java.awt.event.*;import javax.swing.*;import javax.swing.border.TitledBorder; import java.util.*;import javax.swing.JPanel; import javax.swing.JTextField; import java.awt.GridLayout;import javax.swing.JFrame; import javax.swing.JLabel;import javax.swing.SwingUtilities;import javax.swing.UIManager;public class Test extends JFrame&#123; private static final long serialVersionUID = 1L;//测试 public Test() &#123; Clock clock =new Clock(); Calender cal = new Calender(); @SuppressWarnings("unused") JPanel jp2 = new JPanel(); setLocationRelativeTo(null); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(560,300); setVisible(true); this.setContentPane(clock); this.getContentPane().add(cal,BorderLayout.WEST); setResizable(false); &#125;//////////////////////////////////// //画时钟public class DrawClock extends JPanel implements Runnable &#123; private static final long serialVersionUID = 1L; Thread newThread; //线程 public int RADIUS = 80; //时钟的半径 //设置时钟位置 public int centerX = 150; //设置时钟x轴 public int centerY = 120; //设置时钟y轴 public int hr, min, sec; //小时，分钟，秒 public int[] xPoint = new int[4]; //指针的4个坐标 public int[] yPoint = new int[4]; public double hrAlpha, minAlpha, secAlpha, theta; private JTextField timeZone; //启动时钟 public void start() &#123; newThread = new Thread(this); newThread.start(); //启动线程 &#125; //终止线程 public void stop() &#123; newThread = null; &#125; @SuppressWarnings("deprecation") public void paint(Graphics g) &#123; super.paint(g); //画出时钟刻度 double minuteAlpha = Math.PI/30.0; int count = 0; for(double alpha=0; alpha&lt;2.0*Math.PI; alpha+=minuteAlpha) &#123; int tX = (int)(centerX+RADIUS*0.9*Math.sin(alpha)); int tY = (int)(centerY-RADIUS*0.9*Math.cos(alpha)); if(count%5 == 0) &#123; g.setColor(Color.CYAN); g.fill3DRect(tX, tY, 3, 3, false); if(count%3==0) &#123; int m = count /15; switch(m)&#123; case 1: g.drawString("3", centerX+RADIUS-18, centerY+5);break; case 2: g.drawString("6", centerX-3, centerY+RADIUS-10);break; case 3: g.drawString("9", centerX-RADIUS+11,centerY+6);break; default: g.drawString("12", centerX-5, centerY-RADIUS+22); &#125; &#125; &#125; else &#123; g.setColor(Color.DARK_GRAY); g.fill3DRect(tX, tY, 2, 2, false); &#125; count++; &#125; //画出时钟时针 g.setColor(Color.gray); // 定义颜色 drawPointer(g, centerX+2, centerY+2, (int)(RADIUS*0.75), hrAlpha); g.setColor(Color.CYAN); // 定义颜色 drawPointer(g, centerX, centerY, (int)(RADIUS*0.75), hrAlpha); //画出分针 g.setColor(Color.gray); // 定义颜色 drawPointer(g, centerX+2, centerY+2, (int)(RADIUS*0.83), minAlpha); g.setColor(Color.CYAN); // 定义颜色 drawPointer(g, centerX, centerY, (int)(RADIUS*0.83), minAlpha); //画出秒针 g.setColor(Color.DARK_GRAY); //定义颜色 g.drawLine( centerX,centerY, (int)(centerX+(int)(RADIUS*0.79)*Math.sin(secAlpha)), (int)(centerY-(int)(RADIUS*0.79)*Math.cos(secAlpha)) ); setBorder(new TitledBorder("时间")); setBackground(Color.white); // 定义颜色 g.drawRect(85, 210, 130, 20); g.setColor(Color.WHITE); g.setColor(Color.DARK_GRAY); Date timeNow = new Date(); g.drawString(timeNow.toLocaleString(), 100,225); &#125; public Date getDate() &#123; Date timeNow = new Date(); return timeNow; &#125; // 刷新图层 public void update(Graphics g) &#123; paint(g); &#125; // 画出一个帧的图像 public void run() &#123; while(newThread != null) &#123; repaint(); try &#123; Thread.sleep(800); &#125; catch(InterruptedException E) &#123;&#125; Date timeNow = new Date(); @SuppressWarnings("deprecation") int hours = timeNow.getHours(); //这里不知道为什么会画横线的 @SuppressWarnings("deprecation") int minutes = timeNow.getMinutes(); //这里不知道为什么会画横线的 @SuppressWarnings("deprecation") int seconds = timeNow.getSeconds(); //这里不知道为什么会画横线的 hr = hours; min = minutes; sec = seconds; theta = Math.PI/6.0/20.0; hrAlpha = (double)(hr*3600 + min*60 + sec) /(12.0*3600.0)*2.0*Math.PI; minAlpha = (double)(min*60 + sec)/3600.0*2.0*Math.PI; secAlpha = (double)sec/60.0 * 2.0*Math.PI; &#125; &#125; private void drawPointer(Graphics g, int x, int y, int len, double theta) &#123; xPoint[0] = (int)(x+len*0.3*Math.sin(theta-Math.PI)); yPoint[0] = (int)(y-len*0.3*Math.cos(theta-Math.PI)); xPoint[1] = (int)(xPoint[0]+len*0.3*Math.sin (theta-(double)(10.0/180)*Math.PI)); yPoint[1] = (int)(yPoint[0]-len*0.3*Math.cos (theta-(double)(10.0/180)*Math.PI)); xPoint[2] = (int)(xPoint[0]+len * Math.sin(theta)); yPoint[2] = (int)(yPoint[0]-len * Math.cos(theta)); xPoint[3] = (int)(xPoint[0]+len*0.3*Math.sin (theta+(double)(10.0/180)*Math.PI)); yPoint[3] = (int)(yPoint[0]-len*0.3*Math.cos (theta+(double)(10.0/180)*Math.PI)); g.fillPolygon(xPoint, yPoint, 4); &#125; public JTextField getTimeZone() &#123; return timeZone; &#125; public void setTimeZone(JTextField timeZone) &#123; this.timeZone = timeZone; &#125; &#125; ////////////////////////////////// //时钟public class Clock extends JPanel &#123; private static final long serialVersionUID = 1L; private UIManager.LookAndFeelInfo looks[]; private DrawClock clock ; @SuppressWarnings("unused") private JPanel pane_clock ; JPanel pane_cal; public Clock() &#123; super(); looks = UIManager.getInstalledLookAndFeels(); changeTheLookAndFeel(2); clock = new DrawClock(); clock.start(); this.setBackground(Color.GRAY); this.setLayout(new BorderLayout()); this.setOpaque(false); this.add(clock); this.setBorder(new TitledBorder("时间日期")); setSize( 300, 300 ); setVisible( true ); &#125; private void changeTheLookAndFeel(int i) &#123; try &#123; UIManager.setLookAndFeel(looks[i].getClassName()); SwingUtilities.updateComponentTreeUI(this); &#125; catch(Exception exception) &#123; exception.printStackTrace(); &#125; &#125; &#125; /////////////////////////////////// //设计日历public class Calender extends JPanel implements ActionListener &#123; private static final long serialVersionUID = 1L; public final String HOUR_OF_DAY = null; //定义 @SuppressWarnings("rawtypes") JComboBox Month = new JComboBox(); @SuppressWarnings("rawtypes") JComboBox Year = new JComboBox(); JLabel Year_l = new JLabel("年"); JLabel Month_l = new JLabel("月"); Date now_date = new Date(); JLabel[] Label_day = new JLabel[49]; @SuppressWarnings("deprecation") int now_year = now_date.getYear() + 1900; @SuppressWarnings("deprecation") int now_month = now_date.getMonth(); boolean bool = false; String year_int = null; int month_int; JPanel pane_ym = new JPanel(); JPanel pane_day = new JPanel(); @SuppressWarnings("unchecked") public Calender() &#123; super(); //设定年月 for (int i = now_year - 10; i &lt;= now_year + 20; i++) &#123; Year.addItem(i + ""); &#125; for (int i = 1; i &lt; 13; i++) &#123; Month.addItem(i + ""); &#125; Year.setSelectedIndex(10); pane_ym.add(new JLabel(" ")); pane_ym.add(Year); pane_ym.add(Year_l); Month.setSelectedIndex(now_month); pane_ym.add(Month); pane_ym.add(Month_l); pane_ym.add(new JLabel(" ")); Month.addActionListener(this); Year.addActionListener(this); //初始化日期并绘制 pane_day.setLayout(new GridLayout(7, 7, 10, 10)); for (int i = 0; i &lt; 49; i++) &#123; Label_day[i] = new JLabel(" "); pane_day.add(Label_day[i]); &#125; this.setDay(); this.setLayout(new BorderLayout()); this.add(pane_day, BorderLayout.CENTER); this.add(pane_ym, BorderLayout.NORTH); this.setSize(100,200); this.setBorder(new TitledBorder("日历")); setSize(300,300); &#125; @SuppressWarnings("deprecation") void setDay() &#123; if (bool) &#123; year_int = now_year + ""; month_int = now_month; &#125; else &#123; year_int = Year.getSelectedItem().toString(); month_int = Month.getSelectedIndex(); &#125; int year_sel = Integer.parseInt(year_int) - 1900; //获得年份值 //@SuppressWarnings("deprecation") Date dt = new Date(year_sel, month_int, 1); //构造一个日期 GregorianCalendar cal = new GregorianCalendar(); //创建一个Calendar实例 cal.setTime(dt); String week[] = &#123; "日", "一","二", "三", "四", "五", "六" &#125;; int day = 0; int day_week = 0; for (int i = 0; i &lt; 7; i++) &#123; Label_day[i].setText(week[i]); &#125; //月份 if (month_int == 0||month_int == 2 ||month_int == 4 || month_int == 6 || month_int == 9 ||month_int == 11) &#123; day = 31; &#125; else if (month_int == 3 ||month_int == 5 || month_int == 7|| month_int == 8 ||month_int == 10|| month_int == 1) &#123; day = 30; &#125; else &#123; if (cal.isLeapYear(year_sel)) &#123; day = 29; &#125; else &#123; day = 28; &#125; &#125; day_week = 7 + dt.getDay(); int count = 1; for (int i = day_week; i &lt; day_week + day; count++, i++) &#123; if (i % 7 == 0 ||i == 13||i == 20||i == 27|| i == 48 ||i == 34 ||i == 41) &#123; if (i == day_week + now_date.getDate() - 1) &#123; Label_day[i].setForeground(Color.blue); Label_day[i].setText(count + ""); &#125; else &#123; Label_day[i].setForeground(Color.red); Label_day[i].setText(count + ""); &#125; &#125; else &#123; if (i == day_week + now_date.getDate() - 1) &#123; Label_day[i].setForeground(Color.blue); Label_day[i].setText(count + ""); &#125; else &#123; Label_day[i].setForeground(Color.black); Label_day[i].setText(count + ""); &#125; &#125; &#125; if (day_week == 0) &#123; for (int i = day; i &lt; 49; i++) &#123; Label_day[i].setText(" "); &#125; &#125; else &#123; for (int i = 7; i &lt; day_week; i++) &#123; Label_day[i].setText(" "); &#125; for (int i = day_week + day; i &lt; 49; i++) &#123; Label_day[i].setText(" "); &#125; &#125; &#125; public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == Year || e.getSource() == Month) &#123; bool = false; this.setDay(); &#125; &#125; &#125;//////////////////////////////////public static void main(String[] args)&#123;try&#123; Test frame = new Test(); frame.setTitle("日历");&#125;catch (Exception e)&#123; System.out.print("run error!"); &#125;&#125;&#125; 4 棋盘覆盖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226package textchess;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Dimension;import java.awt.FlowLayout;import java.awt.Font;import java.awt.GridLayout;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Random;import javax.print.attribute.standard.JobHoldUntil;import javax.swing.ImageIcon;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class chessBoard extends JFrame &#123; private int tr, tc, dr, dc, size;//定义各成员变量 int tile = 1; float red,green,blue; JPanel centerPanel; JPanel southPanel; JButton[][] button; JTextField TrText, TcText, DrText, DcText, SizeText; JLabel TrLabel, TcLabel, DrLabel, DcLabel, SizeLabel; JButton OKButton; JButton CancelButton; JPanel panel = new JPanel(); public chessBoard() &#123; super(); setTitle("棋盘覆盖"); this.setResizable(false); centerPanel = new JPanel(); southPanel = new JPanel(); OKButton = new JButton("确定或开始"); OKButton.addActionListener(new OKButtonAction()); CancelButton = new JButton("取消或清除"); CancelButton.addActionListener(new OKButtonAction()); setBounds(300, -10, 900, 900);//设置窗口大小与位置 TrText = new JTextField("0",2);//定义各组件 TcText = new JTextField("0",2); DrText = new JTextField("0",2); DcText = new JTextField("0",2); SizeText = new JTextField("4",2); TrLabel = new JLabel("起始方格坐标x: "); TcLabel = new JLabel("起始方格坐标y: "); DrLabel = new JLabel("特殊方格坐标x: "); DcLabel = new JLabel("特殊方格坐标y: "); SizeLabel = new JLabel("棋盘规模size: "); TrText.setEnabled(false); TcText.setEnabled(false); int tR = Integer.parseInt(TrText.getText()); int tC = Integer.parseInt(TcText.getText()); int dR = Integer.parseInt(DrText.getText()); int dC = Integer.parseInt(DcText.getText()); int Size = 1; for (int i=0;i&lt;Integer.parseInt(SizeText.getText());i++) Size*=2; tr = tR; tc = tC; dr = dR; dc = dC; size = Size; southPanel.add(CancelButton);//添加各组件到窗体 southPanel.add(TrLabel); southPanel.add(TrText); southPanel.add(TcLabel); southPanel.add(TcText); southPanel.add(DrLabel); southPanel.add(DrText); southPanel.add(DcLabel); southPanel.add(DcText); southPanel.add(SizeLabel); southPanel.add(SizeText); southPanel.add(OKButton); getContentPane().add(southPanel, BorderLayout.NORTH); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; class gridLayout &#123; public gridLayout() &#123; centerPanel.setLayout(new GridLayout(0, size)); button = new JButton[size][size]; for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; button[i][j] = new JButton(); if (i == dr &amp;&amp; j == dc) &#123; button[i][j].setBackground(Color.BLUE); button[i][j].setText("&lt;html&gt;&lt;font size='3' color='white'&gt;棋盘覆盖&lt;br&gt;Done By Java!&lt;/font&gt;&lt;/html&gt;"); button[i][j].setEnabled(false); &#125; centerPanel.add(button[i][j]); &#125; &#125; &#125; private void sleep() &#123; for (int i=0;i&lt;100;i++) for(int j=0;j&lt;1000;j++); &#125; public void ChessBoard(int tr, int tc, int dr, int dc, int size) &#123;//算法实现 if (size == 1) // 棋盘方格大小为1,说明递归到最里层 return; int t = tile++;// 每次递增1 Random rd = new Random(); red=rd.nextFloat(); green=rd.nextFloat(); blue=rd.nextFloat(); Color col = new Color(red,green,blue); sleep(); int s = size / 2; // 棋盘中间的行、列号(相等的) // 检查特殊方块是否在左上角子棋盘中 if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) // 在 ChessBoard(tr, tc, dr, dc, s); else // 不在，将该子棋盘右下角的方块视为特殊方块 &#123; button[tr + s - 1][tc + s - 1].setBackground(col); button[tr + s - 1][tc + s - 1].setEnabled(false); button[tr + s - 1][tc + s - 1].setText("&lt;html&gt;&lt;Font size='4',color='white'&gt;"+t+"&lt;/Font&gt;&lt;/html&gt;"); ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s); sleep(); &#125; // 检查特殊方块是否在右上角子棋盘中 if (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) // 在 ChessBoard(tr, tc + s, dr, dc, s); else // 不在，将该子棋盘左下角的方块视为特殊方块 &#123; button[tr + s - 1][tc + s].setBackground(col); button[tr + s - 1][tc + s].setEnabled(false); button[tr + s - 1][tc + s ].setText("&lt;html&gt;&lt;Font size='4',color='white'&gt;"+t+"&lt;/Font&gt;&lt;/html&gt;"); ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); sleep(); &#125; // 检查特殊方块是否在左下角子棋盘中 if (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) // 在 ChessBoard(tr + s, tc, dr, dc, s); else // 不在，将该子棋盘右上角的方块视为特殊方块 &#123; button[tr + s][tc + s - 1].setBackground(col); button[tr + s][tc + s - 1].setEnabled(false); button[tr + s ][tc + s - 1].setText("&lt;html&gt;&lt;Font size='4',color='white'&gt;"+t+"&lt;/Font&gt;&lt;/html&gt;"); ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); sleep(); &#125; // 检查特殊方块是否在右下角子棋盘中 if (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) // 在 ChessBoard(tr + s, tc + s, dr, dc, s); else // 不在，将该子棋盘左上角的方块视为特殊方块 &#123; button[tr + s][tc + s].setBackground(col); button[tr + s][tc + s].setEnabled(false); button[tr + s ][tc + s ].setText("&lt;html&gt;&lt;Font size='4',color='white'&gt;"+t+"&lt;/Font&gt;&lt;/html&gt;"); ChessBoard(tr + s, tc + s, tr + s, tc + s, s); sleep(); &#125; &#125; &#125; public class OKButtonAction implements ActionListener &#123;//点下一个按钮时的事件响应 @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub JButton whichButton = (JButton) e.getSource();//获取点击的事件，即是点下了哪个按钮 String whichName = whichButton.getActionCommand(); if(whichName.equals("确定或开始")) &#123; getContentPane().add(centerPanel, BorderLayout.CENTER); int tR = Integer.parseInt(TrText.getText()); int tC = Integer.parseInt(TcText.getText()); int dR = Integer.parseInt(DrText.getText()); int dC = Integer.parseInt(DcText.getText()); int Size = 1; for (int i=0;i&lt;Integer.parseInt(SizeText.getText());i++) Size*=2; tr = tR; tc = tC; dr = dR; dc = dC; size = Size; try &#123; gridLayout grid = new gridLayout(); grid.ChessBoard(tr, tc, dr, dc, size); centerPanel.updateUI(); &#125; catch (Exception EX) &#123; EX.printStackTrace(); &#125; panel.removeAll(); OKButton.setEnabled(false); &#125; if (whichName.equals("取消或清除")) &#123;//当你点下一个提示按钮时的事件响应 JLabel label = new JLabel(); label.setHorizontalAlignment(JLabel.CENTER); label.setText("&lt;html&gt;&lt;Font size='+8',color='red'&gt;&lt;center&gt;&lt;b&gt;&lt;br&gt; 您取消了操作或是 &lt;br&gt;&lt;Font size='+8',color='blue'&gt;&lt;center&gt;您清除了前一个棋盘……" + "&lt;br&gt;&lt;Font size='+8',color='green'&gt;&lt;center&gt;下面是关于题目的介绍&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/b&gt;&lt;/Font&gt;&lt;/html&gt;");// JLabel l = new JLabel("题目要求"); JTextArea area = new JTextArea("在一个2k x 2k ( 即：2^k x 2^k )个方格组成的棋盘中，恰有一个方格与其他方格不同，" + "称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，" + "且任何2个L型骨牌不得重叠覆盖。",7,60); area.setLineWrap(true); area.setBackground(Color.blue); area.setForeground(Color.white); area.setFont (new Font("SansSerif", Font.PLAIN, 14)); area.setEditable(false);// FlowLayout layout = new FlowLayout();// layout.addLayoutComponent(arg0, arg1) panel.add(label,centerPanel );// panel.add(l,southPanel); panel.add(area,southPanel); getContentPane().add(panel, BorderLayout.CENTER); panel.updateUI(); tile=1; centerPanel.removeAll(); OKButton.setEnabled(true); &#125; &#125; &#125; public static void main(String[] args) &#123;//主函数方法实现 chessBoard chess = new chessBoard(); chess.setVisible(true); Runtime run = Runtime.getRuntime(); run.gc();//手动清除数据垃圾 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java开发环境搭建]]></title>
    <url>%2F2018%2F10%2F14%2Fjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.下载jdk想要成功配置Java的环境变量，那肯定就要安装JDK，才能开始配置的。官网下载,一路next。 2.jdk成功标志 3.配置系统变量JAVA_HOME选择【新建系统变量】–弹出“新建系统变量”对话框，在“变量名”文本框输入“JAVA_HOME”,在“变量值”文本框输入JDK的安装路径（也就是步骤5的文件夹路径），单击“确定”按钮，如图： 4.配置系统变量Path在“系统变量”选项区域中查看PATH变量，如果不存在，则新建变量 PATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添加“%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”或者是直接“%JAVA_HOME%\bin;”，单击确定按钮， 5.配置系统变量CLASSPATH 在“系统变量”选项区域中查看CLASSPATH 变量，如果不存在，则新建变量CLASSPATH，否则选中该变量，单击“编辑”按钮，在“变量值”文本框的起始位置添加“.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;”。 6.系统变量成功标志]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[intellij到出jar包]]></title>
    <url>%2F2018%2F10%2F14%2Fintellij%E5%AF%BC%E5%87%BAjar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>intellij</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O处理]]></title>
    <url>%2F2018%2F10%2F14%2FIO%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 创建文件对象 文件常用方法1 文件常用方法4 练习1：找出文件夹中最大/最小文件（不包含子文件夹） 练习2：找出文件夹中最大/最小文件（包含子文件夹） 文件输入/输出流 字节流：InputStream字节输入流 OutputStream字节输出流 用于以字节的形式读取和写入数据 字节流形式读取文件内容 以字节流的形式向文件写入数据 关闭流的方式：在finally中关闭 在try中关闭 f.close(); 字符流：Reader字符输入流 Writer字符输出流 专门用于字符的形式读取和写入数据 使用字符流读取文件 缓存流： BufferedReader 缓存流读取数据 // 缓存流必须建立在一个存在的流的基础上 PrintWrite 同理 flush :有的时候，需要立即把数据写入到硬盘，而不是等缓存满了才写出去。 这时候就需要用到flush 数据流：DataInputStream 数据输入流 DataOutputStream 数据输出流 对象流： 对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘 一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口 Scanner读取字符串 Scanner s = new Scanner(System.in); 一行一行读]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>skills javas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hibernate]]></title>
    <url>%2F2018%2F10%2F14%2Fhibernate%2F</url>
    <content type="text"><![CDATA[完整教程：how2j备忘 使用Criteria,根据name进行模糊查询使用HQL,根据name进行模糊查询使用标准SQL,根据name进行模糊查询hibernate实现多对一关系hibernate实现一对多关系hibernate实现多对多关系 要实现多对多关系，必须有一张中间表 user_product 用于维护 User和Product之间的关系 Hibernate的注解是什么？ 简单的说，本来放在hbm.xml文件里的映射信息，现在不用配置文件做了，改由注解来完成]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 下载打开报错]]></title>
    <url>%2F2018%2F10%2F14%2Feclipse%E4%B8%8B%E8%BD%BD%E5%90%8E%E6%89%93%E5%BC%80%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[1.报错图示 2.问题所在,/h3&gt; eclipse版本与jdk版本位数不一致 Eclipse.ini文件配置信息出错。 Eclipse安装目录有特殊字符（例如：#，！，@等）。 你所使用的Eclipse版本可能太新导致JVM不支持。2.解决方法 推荐在官网下载 Eclipse OXYGEN 添加12-vmC:\Program Files\Java\jdk1.7.0_71\bin\javaw.exe]]></content>
      <categories>
        <category>报错处理</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 快捷键]]></title>
    <url>%2F2018%2F10%2F14%2Feclipse%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[###示例 1 : 批量修改 顶 折ALT+SHIFT+R ###示例 2 : 快速输入主方法 顶 折 敲入main alt+/###示例 3 : 快速输入System.out.println 顶 折 敲入syso alt+/###示例 4 : 快速输入for 顶 折 敲入for alt+/###示例 5 : 查看java源代码 顶 折JDK里提供的类，比如String,Intger,System都是开源的，免费提供其源代码可以很简便的通过eclipse就查看源码 先选中想要查看的方法，比如System.out.println()的 println 敲键F3###示例 6 : 代码格式化 顶 折ctrl+shift+f格式化代码注意： 这个快捷键和搜狗输入法的切换简繁冲突。 所以最好把搜狗的切换简繁取消掉。###示例 7 : 快速助手 顶 折ctrl+shift+oimport 类去掉未使用的类 等等都可以使用###示例 8 : 快速注释 顶 折选中一行或者多行代码 ctrl+shift+c###示例 9 : 大小写转换 顶 折ctrl+shift+x 选中的转换为大写ctrl+shift+y 选中的转换为小写###示例 10 : 快速解决办法提示 顶 折在出错误的行，使用ctrl+1。 比如忘记导入类了，就可以用这个解决###示例 11 : toString getter setter 构造方法的快速生成 顶 折 通过菜单-&gt; Source 就可以看到快速生成的选项 直接使用快捷键 shift+alt+s也可以弹出这个选项]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin安装myEclipse并运行web项目]]></title>
    <url>%2F2018%2F10%2F14%2Fdeepin%E5%AE%89%E8%A3%85myEclipse%E5%B9%B6%E8%BF%90%E8%A1%8Cweb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[deepin安装myEclipse并运行web项目 [webDemo] deepin的myeclipse自带tomcat 直接配置运行]]></content>
  </entry>
  <entry>
    <title><![CDATA[cmd操作mysql数据库]]></title>
    <url>%2F2018%2F10%2F14%2Fcmd%20%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 1.在mysql安装目录bin下打开cmd shift+右键 2.具体操作 登陆 mysql -u root -p 新建数据库 新建表 新建具体表项 select* from table;//查询表项 修改密码 导入数据库 .sql文件 先建数据库 然后 use 数据库名 ； source 路径（不需要；）路径最好是某盘的下面，不然会出稀奇古怪的错误 导出数据库 mysqldump -u用户名 -p密码 数据库名 &gt; 数据库名.sql1mysqldump -uroot -p Ticket &gt; Ticket.sql 云服务器的数据库导入成功截图 多表查询 inner join /left join 区别给表添加外键 alter table card add constraint constraint_card foreign key(stuid) references student(stuid); 这句sql语句意思是：在card表中添加名为dormitoryid的外键约束。删除表中的外键 alter table card drop foreign key constraint_card; 删除card表中的名为constraint_card的外键(表中的外键命名采用constraint_外键表名)外键不删除，不能删除表 删除表中所有数据 delete from tablename;删除带有外键约束的表中的数据 SET FOREIGN_KEY_CHECKS=0； delete from tablename; SET FOREIGN_KEY_CHECKS=1; 向有约束的表插入数据是有限制的 在无锡实训7有介绍。 一对多关系 如：宿舍-学生 肯定先有宿舍信息再有学生。 先插宿舍，再插学生。123456789101112131415161718192021222324create table dormitory(dormitoryid varchar(10) primary key,drcnitorytype varchar(10) not null);create table student(stuid varchar(20) primary key,stuname varchar(20) not null,stuage int not null,dormitoryid varchar(10));create table card(cardid varchar(10) primary key,cardtype varchar(10) not null,money int default 0,stuid varchar(20));//在card表声明一个student外键alter table card add constraint constraint_card foreign key(stuid) references student(stuid);//在student表中声明一个dormitory外键 叫constraint_student （中文：约束学生）alter table student add constraint constraint_student foreign key(dormitoryid) references dormitory(dormitoryid); 插入数据 insert into dormitory values(‘A001’,’4persons’); insert into student values(‘S001’,’wangshicong’,28,’A001’);//相当于把Student放在A001房间。 insert into card values(‘C001’,’ic_card’,800,’S001’);//相当于把卡放在学生S001中。 多表查询 将三张表等值连接后查询1select a.*,b.*,c.*from dormitory a inner join student b on a.dormitoryid=b.dormitoryid inner join card c on b.stuid=c.stuid; left join与inner join与right join 好奇怪：都一样 难道在一对多中无区别？ 多对多关系的表 如何创建约束 如何进行多表查询 多对多关系：subject-student//student就用上面创的，注意：里面有个外键约束。 通过业务表SelectSubject建立约束1234567891011121314151617181920212223create table student(stuid varchar(20) primary key,stuname varchar(20) not null,stuage int not null,dormitoryid varchar(10));create table subject(subjectid varchar(20) primary key,subjectname varchar(20) not null,subjecttype varchar(10) not null);create table SelectSubject(id int(5) primary key,subjectid varchar(10) ,stuid varchar(20));//建立外键约束alter table SelectSubject add constraint constraint_fk1 foreign key(subjectid) references subject(subjectid);alter table SelectSubject add constraint constraint_fk2 foreign key(stuid) references student(stuid); 插入数据 先插student 再插subject 最后插SelectSuject insert into dormitory values(‘A002’,’6persons’); insert student values(‘S002’,’wangjinglin’,35,’A002’); insert subject values(‘SB001’,’math’,’like’); insert into SelectSubject values(1,’SB001’,’S001’); 多表查询-多对多关系表 三张表left链接后查询 1select a.*,b.*,c.*from subject a left join SelectSubject b on a.subjectid=b.subjectid left join student c on b.stuid=c.stuid; 一条记录 left right inner 无差别 多条记录有差别]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sync-setting]]></title>
    <url>%2F2018%2F10%2F14%2Fatom%E6%8F%92%E4%BB%B6sync-setting%2F</url>
    <content type="text"><![CDATA[同步你的Atom设置 atom-ternjs ：js文件代码自动补全，对html文件无效。 Emmet ：html文件html css 代码自动补全 目前知道的是：输入table-&gt; 以前要输入javascript-snippets：html文件js自动补全]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>skills java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux) 报错及解决方法]]></title>
    <url>%2F2018%2F09%2F29%2Frecord2%2F</url>
    <content type="text"><![CDATA[linux mysql access denied for user ‘root’@’localhost’(using password:YES) 教程 update user set authentication_string = password(‘admin’) //失败where user = &apos;root&apos; and Host = &apos;localhost&apos; 启动 mysqld会变成a mysqld process already exists ps -ef | grep mysql kill -9 mysqld-safe 是mysqld的父进程 用于监控数据库运行情况彻底删除mysql教程 成功标准：rpm -qa|grep mysql 不报错无信息 在根据How2j的教程重装 不然一大堆问题。亲测 成功。 mysql的报错日志：vim etc/my.cnf(记住在根目录输)里面看。 scp 上传文件 教程 centos yum安装mysql root用户默认无密码。 mysqladmin -u root password admin mysqladmin: unable to change password; error: ‘Can’t find any matching row in the user table’ mysqladmin -u root password admin //给初安装无密码的mysql添加密码 报错是因为没有user表的权限 进入mysql命令行 解决方法：FLUSH PRIVILEGES ERROR 1227 (42000): Access denied; you need (at least one of) the RELOAD privilege(s) for this operation FLUSH PRIVILEGES;//更新权限表- UPDATE mysql.user SET password=password(‘admin’)WHERE user=’root’ AND host=’localhost’; 2.加参数启动mysql：/usr/bin/mysqld_safe –skip-grant-tables &amp;然后就可以无任何限制的访问mysql 安装deepin后 记得设置自动代理 不然有些网页不能访问 特别是需翻墙与无需翻墙的网页交替时。 在app.json文件中，pages数组，设置在第一个的页面就是默认启动页面，所以你只需要调整你当前开发的页面顺序就好了。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux) 报错及解决方法]]></title>
    <url>%2F2018%2F09%2F29%2Frecord%2F</url>
    <content type="text"><![CDATA[解决桌面卡死 ctrl+alt+t启动终端 /ctrl+alt+f2 终端雷神模式(能打开概率高) ctrl+alt+f1(返回桌面) sudo systemctl restart lightdm 重启终端 可能会报错：无法load etc/profile 的exprot。。。 用vim去掉你配置的java ,tomcat 等的环境变量就行啦。 deepin java环境部署 官方教程 原教程 mysql+tomcat+maven+java mysql 安装成功无密码？-&gt;添加密码 use mysql; update user set password=password(‘admin’) where user=’root’; 无用 显示无password字段 update mysql.user set authentication_string=password(‘admin’) where user=’root’; flush privileges; #立即生效 quit 执行成功但无改变 以上为坑 下为教程 deepin mysql 安装时未提示设置密码 源的问题 最新版的bug（安装不提示设置密码 ） 换源重装 12345sudo apt-get autoremove --purge mysql-server-5.7sudo apt-get remove mysql-serversudo apt-get autoremove mysql-serversudo apt-get remove mysql-commonsudo dpkg -l |grep ^rc|awk '&#123;print $2&#125;' |sudo xargs dpkg -P #清除一些相关的残留数据 先下载后配置apt-get源 下载源来自csdn博主 sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb 更新源 sudo apt-get update 安装mysql sudo apt-get install mysql-server sudo netstat -tap | grep mysql linux下mysql开启远程访问权限及防火墙开放3306端口 update user set host=’%’ where user=’root’;ERROR 1062 (23000): Duplicate entry ‘%-root’ for key ‘PRIMARY’ 不予理会 flush privileges;3306端口 vim /etc/sysconfig/iptables deepin 换apt-get 源 sudo gedit etc/apt/sources.list 先备份 sudo cp etc/apt/sources.list etc/apt/source.list.bak 在设置中的更新设置选中要更新的源sudo apt-get update deepin ssh 链接问题 -&gt;是网的问题 无线网一直卡 有线一下进去啦。。。。 项目使用云服务器数据库 拒绝访问 -&gt;结果有是网的问题。。。。 Access denied for user ‘root‘@’localhost’ (using password: YES) 教程-- 客户端不支持认证协议 Client does not support authentication protocol 终端登录无需密码 ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘linux’;FLUSH PRIVILEGES;WHERE Host = ‘’localhost’’ AND User =’’root’’;//失败 ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘admin’;//失败 ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘admin’;//成功]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin安装/拯救教程]]></title>
    <url>%2F2018%2F09%2F22%2Fdeepin%E6%8B%AF%E6%95%91%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装 官方文档## 拯救死机原因：应用开多，卡死，强制重启 提示：firware bug 固件出错就算出错了也可以用命令行的可能是运行的应用内存占用太多，把系统内存挤没了用top查看当前内存情况运行ps -ef如何跳转到 输入命令的地方 ctrl c尝试一下kill *rootreboot无效吗 shutdown先关机 无效再用exitfsck -y /dev/sdbn 试一下这个能不能修复或者fsck -y /dev/sda4 //恢复文件系统 (我的是sda4)exit试一下成功 教程来自《鸟哥的linux私房菜》]]></content>
  </entry>
  <entry>
    <title><![CDATA[android 面试问答]]></title>
    <url>%2F2018%2F09%2F21%2Fandroid%20%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[酷方科技1.android 四大组件 五大存储 六大布局 四大组件：activity显示界面/service后台运行/ content provider数据通信/ broadcast receiver通知 五大存储:sharedPreferences/文件存储/SQlITE数据库方式/content provider内容提供器方式/网络存储方式 六大布局:Linelayout/tablelayout/relativeLayout/GlidLayout网格/absoluteLayout /FrameLayout帧布局 2.]]></content>
  </entry>
  <entry>
    <title><![CDATA[jackson类库的使用]]></title>
    <url>%2F2018%2F09%2F12%2Fjackson%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[maven引入123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;type&gt;bundle&lt;/type&gt; &lt;/dependency&gt; 导入依赖 编码时没错 运行却找不到ObjectMapper类 依赖导入啦，External Libararies 也有相应的jar包 代码引入ObjectMapper类成功 运行失败 找不到类 原因：项目打包会把jar都复制一份到target/项目名/WEB-INF/记住把第三方jar放进tomcat的lib目录下 项目运行在lib中找jar 可是没找到jackson的jar 解决方法 理论上可行 实际不行 直接下jar 拖到lib下]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hadoop大数据技术]]></title>
    <url>%2F2018%2F09%2F08%2FHadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[大数据是一系列技术的组合运用。 视频教程 知乎学习大数据路线 大数据 = 编程技巧 + 数据结构和算法 + 分析能力 + 数据库技能 + 数学 + 机器学习 + NLP + OS + 密码学 + 并行编程 主要分为 7 个阶段：入门知识 → Java 基础 → Scala 基础 → Hadoop 技术模块 → Hadoop 项目实战 → Spark 技术模块 → 大数据项目实战。 安装hadoop1.在linux云服务器配置java环境2.下载hadoop 并修改hadoop四个配置文件怎么用：eg:大量购物数据输入-&gt;map编程-&gt;reduce编程-&gt;推荐你感兴趣的商品。HDFS 分布式文件 块:固定大小的文件存续的逻辑单元 hadoop 默认64MB namecode：管理节点 存放文件元数据 1.文件-&gt;数据块的映射表 2.数据块-&gt;数据节点datanode的映射表 客户端通过访问namenode的元数据 得知文件存在哪个datanode datacode：数据节点 数据块的集合 datanode-&gt;心跳检测-&gt;namenode 二级namenode 元数据备份到Secondary namenode 防止namenode挂掉 导致无法访问元数据。 写入过程:1.文件拆分成块 2.访问namenode得到空闲块 3.写入相应的datanode 4，流水线复制 5.更新元数据 数据管理策略 每个数据块多个副本 分布在不同机架(datanode的集合)的datanode中 机架/或节点挂啦 其他一样访问 HDFS 特点 三个副本 数据冗余 硬件容错、 一读多写 写入之后没法修改 适合存储大文件 MapReduce :Master-worker构架 eg:1000副牌 少啦一张 分100个人做 先map会得到 100个人算的数据 不同牌给不同reduce再次汇总 得出最终结果 运行流程 job-&gt;多个task(map任务+reduce任务) jobTracker：1.作业调度 2.分配任务 3.检测jobTracker状态 taskTracker: 1.汇报状态 容错机制 1.重新执行 4次依旧报错 -&gt;推测执行 2.推测执行 多弄几个taskTracker 一个执行完就关掉其他的 实例：单词计数 输入一段文本 输出每个单词的个数。 hadoop 2.0 多啦YRAN 分布式文件管理]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python精通学习路径]]></title>
    <url>%2F2018%2F09%2F08%2Fpython%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[python精通 知乎]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廖雪峰python教程学习]]></title>
    <url>%2F2018%2F09%2F07%2Fpython%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[完整教程备忘 下个pycharm吧 命令行一运行带模块的脚本 花式报错 还有一件神奇的事，pycharm内置命令行可以运行成功 cmd不行。。。。WTF pip下载包时注意是pip还是pip3 都安吧，懒得找你的项目是用的那个。 python访问数据库 安装依赖pip install mysql-connector 新建连接实例并sql操作 简单GUI程序 代码命令行运行没对过 下个pycharm ide 一下就对啦 带模块的 命令行不能运行？？？ TCP可靠协议 socket端口通信 从新浪爬点数据 (文件名对导包的影响) UDP不可靠协议 web开发 廖雪峰完整教程 WSGI接口：Web Server Gateway Interface 实现web显示 python web开发框架flask 的使用 一个URL可以对应GET和POST请求，当然还有PUT、DELETE等请求，但是我们通常只考虑最常见的GET和POST请求。 同一个URL/signin分别有GET和POST两种请求，映射到两个处理函数中。 Flask通过Python的装饰器在内部自动地把URL和函数给关联起来 Flask自带的Server在端口5000上监听： python MVC 图片来自廖雪峰网站 这里model=dict 改写上一个脚本 把里面的html代码 用专门的html文件存放 成功页面显示你的登录名 而不是输出一成不变的信息 解释一波self (类实例)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>廖雪峰python教程学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现飞机大战]]></title>
    <url>%2F2018%2F09%2F07%2Fpython%E5%AE%9E%E7%8E%B0%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%2F</url>
    <content type="text"><![CDATA[完整源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489# -*- coding: utf-8 -*-import pygamefrom pygame.locals import *import timeimport random"""1. 搭建游戏界面，主要是完成窗口和背景图的显示2. 通过键盘操作，获取游戏事件3. 在游戏窗口显示飞机，并实现按左右键控制飞机左右移动4. 实现按空格键飞机发射子弹5. 显示敌人飞机6. 优化敌机发射的子弹7. 让敌机移动8. 敌机发射子弹9. 玩家子弹射中敌机，敌机爆炸"""# 创建飞机基类class Plane(object): def __init__(self, x, y, screen): # 设置飞机的默认位置 self.x = x self.y = y # 设置要显示内容的窗口 self.screen = screen # 用来存储飞机发射的子弹 self.bullet_list = []# 创建英雄飞机类class HeroPlane(Plane): def __init__(self, x, y, screen): # 继承父类的init方法 super(HeroPlane, self).__init__(x, y, screen) self.image = pygame.image.load('image/fj5.png') self.image_boom_list = [] self.image_boom_list.append(pygame.image.load('image/hero_blowup_n1.png')) self.image_boom_list.append(pygame.image.load('image/hero_blowup_n2.png')) self.image_boom_list.append(pygame.image.load('image/hero_blowup_n3.png')) self.image_boom_list.append(pygame.image.load('image/hero_blowup_n4.png')) # 用于判断敌机是否爆炸 self.boom = False # 选取敌机爆炸的图片索引 self.image_boom_index = 0 # 爆炸图片切换的间隔 self.num = 1 self.left = False self.right = False self.up = False self.down = False def display(self): if self.left: self.x -= 3 if self.x &lt; -20: self.left = False self.right = True self.up = False self.down = False if self.right: self.x += 3 if self.x &gt; 300: self.left = True self.right = False self.up = False self.down = False if self.up: self.y -= 3 if self.y &lt; 0: self.left = False self.right = False self.up = False self.down = True if self.down: self.y += 3 if self.y &gt; 600: self.left = False self.right = False self.up = True self.down = False if not self.boom: self.screen.blit(self.image, (self.x, self.y)) # 如果子弹越界，先将子弹对象从列表中删除 for bullet in self.bullet_list: if bullet.judge(): self.bullet_list.remove(bullet) for bullet in self.bullet_list: bullet.display() bullet.move() else: if self.image_boom_index &lt; len(self.image_boom_list): if self.num % 5 == 0: self.screen.blit(self.image_boom_list[self.image_boom_index], (self.x, self.y)) self.image_boom_index += 1 self.num += 1 def move_left(self): self.left = True self.right = False self.up = False self.down = False def move_right(self): self.right = True self.left = False self.up = False self.down = False def move_up(self): self.right = False self.left = False self.up = True self.down = False def move_down(self): self.right = False self.left = False self.up = False self.down = True def stop(self): self.right = False self.left = False self.up = False self.down = False def shoot(self): bullet = Bullet(self.x, self.y, self.screen) self.bullet_list.append(bullet) def shoot_by(self, bullet): x1 = self.x + self.image.get_rect().width y1 = self.y + self.image.get_rect().height if bullet.x &lt; x1 and bullet.x &gt; self.x and bullet.y &lt; y1 and bullet.y &gt; self.y: return True else: return False# 创建子弹类class Bullet(object): def __init__(self, x, y, screen): self.x = x + 50 self.y = y - 40 self.screen = screen self.image = pygame.image.load('image/zd10.png') def display(self): self.screen.blit(self.image, (self.x, self.y)) # 修改子弹的位置，在窗口显示为动态的移动 def move(self): self.y -= 4 # 判断子弹是否越界 def judge(self): if self.y &lt; 0: return True else: return False def shoot_by(self, bullet): x1 = self.x + self.image.get_rect().width y1 = self.y + self.image.get_rect().height if bullet.x &lt; x1 and bullet.x &gt; self.x and bullet.y &lt; y1 and bullet.y &gt; self.y: return True else: return False# 创建敌人飞机类class EnemyPlane(Plane): def __init__(self, x, y, screen): super(EnemyPlane, self).__init__(x, y, screen) self.image = pygame.image.load('image/fj3.png') # 将敌机爆炸图片放入到列表，动态显示爆炸效果 self.image_boom_list = [] self.image_boom_list.append(pygame.image.load('image/enemy0_down1.png')) self.image_boom_list.append(pygame.image.load('image/enemy0_down2.png')) self.image_boom_list.append(pygame.image.load('image/enemy0_down3.png')) self.image_boom_list.append(pygame.image.load('image/enemy0_down4.png')) # 存储敌机发射的子弹 self.bullet_list = [] # 指定敌机开始的飞行方向 self.direction = 'right' # 用于判断敌机是否爆炸 self.boom = False # 选取敌机爆炸的图片索引 self.image_boom_index = 0 # 爆炸图片切换的间隔 self.num = 1 def display(self): if not self.boom: self.screen.blit(self.image, (self.x, self.y)) for bullet in self.bullet_list: if bullet.judge(): self.bullet_list.remove(bullet) for bullet in self.bullet_list: bullet.display() bullet.move() self.move() self.shoot() else: if self.image_boom_index &lt; len(self.image_boom_list): if self.num % 5 == 0: self.screen.blit(self.image_boom_list[self.image_boom_index], (self.x, self.y)) self.image_boom_index += 1 self.num += 1 def move(self): # 如果方向是向右，就往右走 if self.direction == 'right': self.x += 2 # 如果方向是向左，就往左走 if self.direction == 'left': self.x -= 2 # 如果到达右边的边界，则向左走 if self.x &gt; 350: self.direction = 'left' # 如果到达左边的边界，则向右走 if self.x &lt; 0: self.direction = 'right' self.y += 1 # 敌机发射子弹，在1-75个整数中，随机取数字，只有数字为25才发射子弹 def shoot(self): num = random.randint(1, 75) if num == 25: bullet = EnemyBullet(self.x, self.y, self.screen) self.bullet_list.append(bullet) # 检查敌机是否被子弹bullet (x, y)击中 def shoot_by(self, bullet): x1 = self.x + self.image.get_rect().width y1 = self.y + self.image.get_rect().height if bullet.x &lt; x1 and bullet.x &gt; self.x and bullet.y &lt; y1 and bullet.y &gt; self.y: return True else: return Falseclass SEnemyPlane(Plane): def __init__(self, x, y, screen): super(SEnemyPlane, self).__init__(x, y, screen) self.image = pygame.image.load('image/fj6.png') # 将敌机爆炸图片放入到列表，动态显示爆炸效果 self.image_boom_list = [] self.image_boom_list.append(pygame.image.load('image/enemy1_down1.png')) self.image_boom_list.append(pygame.image.load('image/enemy1_down2.png')) self.image_boom_list.append(pygame.image.load('image/enemy1_down3.png')) self.image_boom_list.append(pygame.image.load('image/enemy1_down4.png')) # 存储敌机发射的子弹 self.bullet_list = [] # 指定敌机开始的飞行方向 self.direction = 'right' # 用于判断敌机是否爆炸 self.boom = False # 选取敌机爆炸的图片索引 self.image_boom_index = 0 # 爆炸图片切换的间隔 self.num = 1 def display(self): if not self.boom: self.screen.blit(self.image, (self.x, self.y)) for bullet in self.bullet_list: if bullet.judge(): self.bullet_list.remove(bullet) for bullet in self.bullet_list: bullet.display() bullet.move() self.move() self.shoot() else: if self.image_boom_index &lt; len(self.image_boom_list): if self.num % 5 == 0: self.screen.blit(self.image_boom_list[self.image_boom_index], (self.x, self.y)) self.image_boom_index += 1 self.num += 1 def move(self): # 如果方向是向右，就往右走 if self.direction == 'right': self.x += 2 # 如果方向是向左，就往左走 if self.direction == 'left': self.x -= 2 # 如果到达右边的边界，则向左走 if self.x &gt; 350: self.direction = 'left' # 如果到达左边的边界，则向右走 if self.x &lt; 0: self.direction = 'right' self.y += 1 # 敌机发射子弹，在1-75个整数中，随机取数字，只有数字为25才发射子弹 def shoot(self): num = random.randint(1, 100) if num == 25: bullet = SEnemyBullet(self.x, self.y, self.screen) self.bullet_list.append(bullet) # 检查敌机是否被子弹bullet (x, y)击中 def shoot_by(self, bullet): x1 = self.x + self.image.get_rect().width y1 = self.y + self.image.get_rect().height if bullet.x &lt; x1 and bullet.x &gt; self.x and bullet.y &lt; y1 and bullet.y &gt; self.y: return True else: return Falseclass EnemyBullet(object): def __init__(self, x, y, screen): self.x = x + 30 self.y = y + 60 self.screen = screen self.image = pygame.image.load('image/zd7.png') def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y += 2 def judge(self): if self.y &gt; 700: return True else: return Falseclass SEnemyBullet(object): def __init__(self, x, y, screen): self.x = x + 30 self.y = y + 60 self.screen = screen self.image = pygame.image.load('image/zd8.png') def display(self): self.screen.blit(self.image, (self.x, self.y)) def move(self): self.y += 3 def judge(self): if self.y &gt; 700: return True else: return Falseenemy_plane_list = []def add_enemy_plane(screen): num = random.randint(0, 500) x = random.randrange(0, 395, 50) if num &lt; 3: enemy_plane = EnemyPlane(x, 0, screen) enemy_plane_list.append(enemy_plane) if num == 4: enemy_plane = SEnemyPlane(x, 0, screen) enemy_plane_list.append(enemy_plane) return enemy_plane_listdef remove_enemy_plane(screen): for enemy_plane in enemy_plane_list: if enemy_plane.y &gt; 700: enemy_plane_list.remove(enemy_plane)class SB(pygame.sprite.Sprite): def __init__(self,image_name,speed = 1): pygame.sprite.Sprite.__init__(self) self.image = pygame.image.load(image_name) self.rect = self.image.get_rect() self.speed = speed def update(self): self.rect.y += self.speed if self.rect.y &gt;= 700: self.rect.y = -700if __name__ == '__main__': # 创建一个windows窗口用来显示游戏内容 screen = pygame.display.set_mode((395, 700)) pygame.display.set_caption('雷电2018') groups_bg = pygame.sprite.Group() bg = SB('image/bj2.jpg') bg1 = SB('image/bj2.jpg') bg1.rect.y = -700 groups_bg.add(bg,bg1) # 创建一个飞机对象 hero_plane = HeroPlane(145, 550, screen) # 创建一个敌机对象 enemy_plane = EnemyPlane(0, 0, screen) while True: groups_bg.update() groups_bg.draw(screen) # 将飞机对象放到背景图像上显示 hero_plane.display() enemy_plane_list = add_enemy_plane(screen) # 遍历所有英雄飞机发射的子弹，判断是否能射中敌机 for bullet in hero_plane.bullet_list: for enemy_plane in enemy_plane_list: if enemy_plane.shoot_by(bullet): enemy_plane.boom = True for enemy_plane in enemy_plane_list: for bullet in enemy_plane.bullet_list: if hero_plane.shoot_by(bullet): hero_plane.boom = True if hero_plane.boom == True: gameover = pygame.image.load('image/gameover.jpg') screen.blit(gameover, (50, 300)) for enemy_plane in enemy_plane_list: enemy_plane.display() remove_enemy_plane(screen) # 通过键盘获取游戏事件 for event in pygame.event.get(): # 如果点击了退出按钮，则退出游戏 if event.type == QUIT: print('exit') exit() # 判断键盘是否按下了键 elif event.type == KEYDOWN: # 如果按键是a或者是&lt;-键，则控制飞机向左移动 if event.key == K_a or event.key == K_LEFT: hero_plane.move_left() print('left') if event.key == K_w or event.key == K_UP: hero_plane.move_up() print('up') if event.key == K_s or event.key == K_DOWN: hero_plane.move_down() print('down') # 如果按键是d或者是-&gt;键，则控制飞机向右移动 elif event.key == K_d or event.key == K_RIGHT: hero_plane.move_right() print('right') # 如果按键是Esc则停止移动 elif event.key == K_ESCAPE: hero_plane.stop() # 如果按键是空格键，则飞机发射子弹 elif event.key == K_SPACE: hero_plane.shoot() print('space') # 通过延迟的方式，来降低while循环的循环速度，从而降低cpu占用率 time.sleep(0.01) # 更新需要显示的内容 pygame.display.update()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>无锡实训python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot框架剖析]]></title>
    <url>%2F2018%2F09%2F07%2Fspringboot%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[原理：约定优于配置的设计&amp;&amp;开发整合包 springboot框架是对ssm/ssh 配置的简化 配置文件 application.yml 在application.yml 配置spring, mybatis/hibernate server jpa是标准接口 hibernate是其实现1234567891011121314server: port: 8083 servlet: context-path:spring: datasource: username: root password: admin driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbgril jpa: hibernate: ddl-auto: update show-sql: true 依赖组件：pom.xml 配置所需依赖&amp;项目基本信息eg:groupId,artifactId.. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.how2java&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;description&gt;springboot&lt;/description&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- servlet依赖. --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tomcat的支持.--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; maven项目通过搜索导入pom.xml -&gt;alt+insert]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试问答]]></title>
    <url>%2F2018%2F09%2F02%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[中软国际(无锡诺威特分公司)1.事务和锁-锁：对数据库中数据对象进行加锁，防止并发或者多用户操作破坏数据库数据的不一致性。因为可能存在多个事务同时存取同一数据的情况。 事务：事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。1234原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 2.servlet 与jsp servlet:服务器端执行的Java程序，一个被称为Servlet容器的程序（其实就是服务器） 负责执行Java程序 jsp:(Java Server Page)则是一个页面， 由JSP容器负责执行。 JSP便于输出，而Servlet便于进行逻辑处理。 123用Java开发Web应用程序时用到的技术主要有两种，即Servlet和JSP。 Servlet是在服务器端执行的Java程序，一个被称为Servlet容器的程序（其实就是服务器） 负责执行Java程序。而JSP(Java Server Page)则是一个页面， 由JSP容器负责执行。Servlet和JSP两者最大的区别就是，Servlet以Java程序为主， 输出HTML代码时需要使用out.println函数，也就是说Java中内嵌HTML； 而JSP则以HTML页面为主，需要写Java代码时则在页面中直接插入Java代码， 即HTML中内嵌Java。 3.html和jsp jsp=html+java 4.mysql 如何实现分页 MySql数据库提供了分页的函数limit m,n， 查询第20条到第30条的数据的sql是：select from table limit 20,30; -&gt;对应我们的需求就是查询第三页的数据：select from table limit (3-1)*10,10; 分页sql格式是：select from table limit (start-1)limit,limit; 其中start是页码，limit是每页显示的条数。 5.简诉ssm Spring+SpringMVC+MyBatis 存储层：MyBatis 控制层: 6.转发和重定向 重定向:其实是两次request 转发：转发是服务器行为，重定向是客户端行为。 1234567第一次，客户端request?? A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。一句话，转发是服务器行为，重定向是客户端行为。为什么这样说呢，这就要看两个动作的工作流程：1.转发过程：客户浏览器发送http请求——》web服务器接受此请求——》调用内部的一个方法在容器内部完成请求处理和转发动作——》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。2.重定向过程：客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL， 既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。 粤嵌公司1.maven是什么? 我答 包管理工具 正确答案：包管理工具+（相同的目录结构）Java项目管理(构建 文档 生成报告 依赖 SCMs 发布 分发 邮件列表) 12总的来说，Maven 简化了工程的构建过程，并对其标准化。它无缝衔接了编译、发布、文档生成、团队合作和其他任务。Maven 提高了重用性，负责了大部分构建相关的任务。 2.springMVC 前端控制器是哪个类 正确答案：DispatcherServlet springMVC:前端控制器 视图解析器 分发器/控制器 3.分页怎么实现的？ 我答 limit函数 /springboot框架的Page对象 正确答案:有20,30种 通常自己写工具类。 还可以用插件pageHelper 擎动公司1.tcp 三次握手 客户端发送位码SYN=1到服务器 随机产生seq客 服务器收到 返回SYN=1+ACK=1 产生seq服 客户端收到 确认 ack=1 且得到的seq=原seq客+1 正确发送ack+seq 服务器收到确认seq服=seq服+1 ack=1 连接建立成功-123456789IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。 2.有10条数据 计算数据库消费表最近3个月的消费总额。(前提要有时间字段)1SELECT * FROM product where DATE_SUB(CURDATE(), INTERVAL 90 DAY) &lt;= date("creatDate"); 3.单例模式1234567891011121314151617public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 武汉百胜睿迪有限公司mysql数据库去重问题 删除表中多余的重复记录（多个字段），只留有id最小的记录- JAVA理论知识点1.StringBuffer/StringBuilder StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类 而StringBuilder就不是线程安全的类 线程安全(不会同时被多线程修改而变成脏数据) 2.基本数据类型 整型：byte 8位 -2^7~2^7-1 shrot int long 字符型：char 2byte 浮点型：float 4byte double 8byte 布尔型：Boolean 1位 3.final 准确的描述是 当一个变量被final修饰的时候，该变量只有一次赋值的机会 4.获取类对象的3种方法/synchronized修饰类/类方法 同步对象的区别 Class c1=Class.forName() Class c2=hero.class; Class c3=new Hero().getClass(); 在对象方法前，加上修饰符synchronized ，同步对象是当前实例。 在类前，加上修饰符synchronized ，同步对象是当前类对象。 5.反射机制 通过字符串结合配置文件达到构造类对象的目的 6.自定义注解 @interface eg：DButil类用注解 教程 1.设置存储信息 12345678public @interface JDBCConfig &#123; String ip(); int port() default 3306; String database(); String encoding(); String loginName(); String password();&#125; 2.给属性赋值 1@JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin") 3.获得存储信息 通过反射，获取这个DBUtil这个类上的注解对象 1JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class); 4.整合 1234567891011121314151617181920212223242526272829@JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")public class DBUtil &#123; static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException &#123; JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class); String ip = config.ip(); int port = config.port(); String database = config.database(); String encoding = config.encoding(); String loginName = config.loginName(); String password = config.password(); String url = String.format("jdbc:mysql://%s:%d/%s?characterEncoding=%s", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException &#123; Connection c = getConnection(); System.out.println(c); &#125;&#125; 7.staic/final static修饰的成员变量和方法都属于类成员，可以通过类名直接调用 final 不可修改 123456789private static SingleObject instance = new SingleObject();//让构造函数为 private，这样该类就不会被实例化private SingleObject()&#123;&#125;//获取唯一可用的对象public static SingleObject getInstance()&#123; return instance;&#125; 8.ArrayList/LinkList/HashMap/hashSet/collection/collections/Arrays 1.collections/Arrays 工具类 12List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();Collections.reverse(numbers); 2.ArrayList vs hashSet| 集合框架&amp;区别 | 是否有序 | 内容是否可重复 || —— | —— | —— || ArrayList | Y | Y || HashSET | N | N | 3.ArrayList/LinkList 插入&amp;定位数据 ArrayList慢 这是因为表结构不同 9.类实例化顺序 1.类的实例化顺序：先静态再父子 2.父类静态变量-&gt;父类静态代码块-&gt;子类静态变量-&gt;子类静态代码块-&gt;父类非静态变量（父类实例成员变量）-&gt;父类构造函数-&gt;子类非静态变量（子类实例成员变量）-&gt;子类构造函数。 10.继承/聚合 聚合体现的是整体与部分 并不一定指类 继承 一个类继承另一个类 有父类属性方法 还可自定义方法。 11.抽象类/接口 1.实现类区别 抽象类由子类实现 接口由类(包括抽象类)实现 2.有无方法声明/实现区别 抽象类可以有方法声明/方法实现 接口类无方法实现。 3.有无抽象方法 抽象类可以没有 接口没有 4.多继承区别 接口可多继承接口 类只能单根继承。 12.把这几个方法封装一下 | 属性的封装就不说啦 eg:封装System.out.println()方法 思路：新建一个类 定义一个静态方法(这样直接可以类名访问) 然后把需要封装的方法写进去 需要用 System.out.println() 时 直接调用该类的静态方法。 1234567891011public class Util&#123; public staic void out(String str)&#123; System.out.println(str) &#125;&#125;public class use&#123; public staic void main(String[] args)&#123; Util.out("方法的封装") &#125;&#125; 13.把super换成父类名 就一目了然啦12345678910111213141516public class ADHero extends Hero&#123; public ADHero(String name)&#123; super(name);//在子类构造方法中调用父类构造方法=Hero(name) System.out.println("AD Hero的构造方法"); &#125;&#125;public class ADHero extends Hero&#123; public int getMoveSpeed()&#123; return this.moveSpeed;//换成当前类名 &#125; public int getMoveSpeed2()&#123; return super.moveSpeed;//换成父类名 &#125;&#125; 14.4种内部类 详细教程 非静态内部类:可以访问私有方法 静态内部类:可以访问静态方法 匿名类: 本地类:有名字的匿名类 15.注解 how2j教程 元注解 @Target。。 自定义注解 第三方框架注解]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssm框架剖析]]></title>
    <url>%2F2018%2F08%2F21%2Fssm%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SSM=spring+springMVC+mybatis demo how2j 1.主要配置文件web.xml(maven项目自带) applicationContext.xml springMVC.xml 2.有些项目有如jdbc.properties 等.properties文件 这些文件是供xml使用的属性值文件。 3.方法与sql映射配置文件eg:Category.xml 可以由注解代替。 web.xml 项目启动第一个加载的配置文件 1.配置加载spring配置文件applicationContext.xml 完成初始化工作(eg:配置mybatis数据库连接) 2.配置加载springMVC配置文件springMVC.xml 完成请求处理与转发 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; &lt;!-- spring的配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring mvc核心：分发servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; applicationContext.xml 1.配置扫描 将bean mapper service 生命周期纳入spring 管理 2.配置扫描 使 方法与sql映射配置文件eg:Category.xml 生效 (mybitais的sqlSession有关) 3.配置mybatis 完成数据库初始化工作 还可以配置 4.数据库连接池 5.对事务transaction配置 6.分页插件配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package="com.fangjun.bean.service" /&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name="url"&gt; &lt;value&gt;jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8&lt;/value&gt; &lt;/property&gt; &lt;property name="username"&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name="password"&gt; &lt;value&gt;admin&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="typeAliasesPackage" value="com.fangjun.bean.bean" /&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath:com/fangjun/bean/mapper/*.xml"/&gt; &lt;/bean&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.fangjun.bean.mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; springMVC.xml 1.配置注解驱动 以使得访问路径与方法的匹配可以通过注解配置 2.配置静态文件加载支持 如html,css,js,images可以访问 3.视图定位 4.扫描Controller,并将其生命周期纳入Spring管理 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package="com.fangjun.bean.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 视图定位 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt; pom.xml 以上3个配置没问题 再报错 多半包没导12345678910111213141516171819202122 ....&lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;pagehelper.version&gt;5.1.2-beta&lt;/pagehelper.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.spring.version&gt;1.2.3&lt;/mybatis.spring.version&gt; &lt;mybatis.version&gt;3.1.1&lt;/mybatis.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;jsqlparser.version&gt;1.0&lt;/jsqlparser.version&gt; &lt;jackson.version&gt;1.2.7&lt;/jackson.version&gt; &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt; &lt;druid.version&gt;1.0.18&lt;/druid.version&gt; &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt; &lt;commons-logging.version&gt;1.2&lt;/commons-logging.version&gt; &lt;commons-fileupload.version&gt;1.2.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-lang.version&gt;2.6&lt;/commons-lang.version&gt; &lt;aopalliance.version&gt;1.0&lt;/aopalliance.version&gt; &lt;mybatis-generator.version&gt;1.3.5&lt;/mybatis-generator.version&gt;&lt;/properties&gt; .... 问题记录1.jsp 中文乱码声明与c标签使用123&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; 2.后台没有收到form表单提交的数据 代码出错/springMVC.xml配置文件出错 吐槽一下：肉眼看自己写的配置文件和教程没区别 结果就是配置文件错啦。 3.单独说一下文件上传 eg:图片 1.新建类接收img数据 2.在工程目录创建文件夹存储图片 并将文件名设置为 改字段所在表的唯一标示id 方便取用 3.通过session获取ControllerContext,再通过getRealPath定位存放分类图片的路径。如果严格按照本教程的做法，使用idea中的tomcat部署的话，那么图片就会存放在:E:\project\tmall_ssm\target\tmall_ssm\img\category 这里 根据分类id创建文件名 如果/img/category目录不存在，则创建该目录，否则后续保存浏览器传过来图片，会提示无法保存 通过UploadedImageFile 把浏览器传递过来的图片保存在上述指定的位置 通过ImageUtil.change2jpg(file); 确保图片格式一定是jpg，而不仅仅是后缀名是jpg. 客户端跳转到admin_category_list 123456789101112131415161718192021222324RequestMapping("admin_category_add") public String add(Category c, HttpSession session, UploadedImageFile uploadedImageFile) throws IOException &#123; System.out.println(c.getId()); categoryService.add(c); System.out.println(c.getId()); //1.根据上下文 新建文件夹 在target目录下 File imageFolder= new File(session.getServletContext().getRealPath("img/category")); //2.新建文件 此时文件没东西 File file = new File(imageFolder,c.getId()+".jpg"); if(!file.getParentFile().exists()) file.getParentFile().mkdirs(); System.out.println(uploadedImageFile); System.out.println(uploadedImageFile.getImage()); System.out.println(file); //3.向文件放传过来的图片 uploadedImageFile.getImage().transferTo(file); //4.用工具类 转换文件格式 BufferedImage img = ImageUtil.change2jpg(file); //5.再次写入文件 ImageIO.write(img, "jpg", file); return "redirect:/admin_category_list"; &#125; 中文乱码问题 1.web.xml+.jsp配置 2.一个后端字符编码设置 一个前端字符编码设置。 3.数据库编码utf8别忘啦 12345678910111213&lt;!--中文过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 12&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*"%&gt; 分页如何实现的 limit函数方式(每点一次页标都会改变 #{start}，#{count} 再次从数据库/session(一级缓存) sessionFactory(二级缓存)查询数据) 1.新建Page对象(1.开始页数strat 2.每页显示个数count 3.数据总个数total 4.参数param) 2.数据库limit函数 select * from category limit #{start}，#{count} 3.所以分页 需要传Page对象 因为需要参数1.开始页数strat(默认为表的第一项) 2.每页显示个数count(默认为所有) 4.返回的是 id从 #{start}到 #{start}+#{count}的数据集合(X) id从#{start}开始 以#{count}为一页的数据集合(x) limit函数:从查询的结果集仅提取一部分数据(v)。 5.如何使用 6.初始化Page对象时 count=defaultCount=5 service取得数据total传入Page 7.直接显示数据集合 只显示第一页 8.引入分页jsp 配合Page对象的共有方法 控制数据集合不同页之间的跳转。 9.每点一次页标都会改变 #{start}，#{count} 再次查询数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false"%&gt;&lt;script&gt;$(function()&#123; $("ul.pagination li.disabled a").click(function()&#123; return false; &#125;);&#125;);&lt;/script&gt;&lt;nav&gt; &lt;ul class="pagination"&gt; &lt;li &lt;c:if test="$&#123;!page.hasPreviouse&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?start=0$&#123;page.param&#125;" aria-label="Previous" &gt; &lt;span aria-hidden="true"&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test="$&#123;!page.hasPreviouse&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?start=$&#123;page.start-page.count&#125;$&#123;page.param&#125;" aria-label="Previous" &gt; &lt;span aria-hidden="true"&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin="0" end="$&#123;page.totalPage-1&#125;" varStatus="status"&gt; &lt;li &lt;c:if test="$&#123;status.index*page.count==page.start&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?start=$&#123;status.index*page.count&#125;$&#123;page.param&#125;" &lt;c:if test="$&#123;status.index*page.count==page.start&#125;"&gt;class="current"&lt;/c:if&gt; &gt;$&#123;status.count&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:forEach&gt; &lt;li &lt;c:if test="$&#123;!page.hasNext&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?start=$&#123;page.start+page.count&#125;$&#123;page.param&#125;" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &lt;c:if test="$&#123;!page.hasNext&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?start=$&#123;page.last&#125;$&#123;page.param&#125;" aria-label="Next"&gt; &lt;span aria-hidden="true"&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 使用 pageHelper分页插件来实现。 1.不需要total()获取数据总数 list(Page page)函数 指定分页参数 2.PageHelper.offsetPage(page.getStart(),page.getCount()); 代替 limit #{start}，#{count} 指定分页参数。 3.int total = (int) new PageInfo&lt;&gt;(cs).getTotal(); 代替 total() 获取数据总数 4.其他不变 5.需要在applicationContext.xml配置 12345678910111213141516&lt;!--Mybatis的SessionFactory配置--&gt; &lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="typeAliasesPackage" value="com.how2java.tmall.pojo" /&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;value&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 自动生成bean mapper mapper.xml 简化开发 1.OverIsMergeablePlugin类+MybatisGenerator类+generatorConfig.xml 2.OverIsMergeablePlugin类：MybatisGenerator插件是Mybatis官方提供的，这个插件存在一个固有的Bug，即当第一次生成了CategoryMapper.xml之后，再次运行会导致CategoryMapper.xml生成重复内容，而影响正常的运行。 3.generatorConfig.xml(1.配置生成文件所在目录 2. 使用OverIsMergeablePlugin插件 3.指定链接数据库的账号和密码，既然是逆向工程，肯定要先链接到数据库才对啊) 4.需要额外的Mybatis Generator jar包（mybatis-generator-core-1.3.5.jar） maven项目直接在pom.xml中导入 5.MybatisGenerator会生成一个类叫做XXXXExample的。 它的作用是进行排序，条件查询的时候使用。 生成后list()变为selectByExample(Example example) 必须传参数(eg：id desc )用于设置排序、设置根据id字段查询、、 xxxxExamole类 辅助查询类 123456789101112131415public interface CategoryMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Category record); int insertSelective(Category record); List&lt;Category&gt; selectByExample(CategoryExample example); Category selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Category record); int updateByPrimaryKey(Category record);&#125; 12345678@Override public List list(int id) &#123; CategoryExample example =new CategoryExample(); //设置根据id字段查询 example.createCriteria().andIdEqualTo(id); example.setOrderByClause("id desc"); return categoryMapper.selectByExample(example); &#125; mybatis生成的项目 启动慢问题 一直不成功。At least one JAR was scanned for TLDs yet contained no TLDs 尝试1：改tomcat配置文件何去掉jsp中的注解 教程 尝试2：改jre配置文件 教程 No TLD files were found in resource path 什么是TLD?-&gt;标签库描述文件，如要在JSP页面中实现JSP标签，必须首先定义实现标签的类，然后在标签库描述文件（TLD）中将写好的类映射成jsp标签,最后在JSP文件中使用定义好的标签，就可以生成动态的JSP内容 等啦几天，最终自己好啦。what fuck？ Maven打包报错 No sources to compile 等一下就好 网上说不是Maven项目造成的 扯淡 linux重启tomcat1234567891011121314进入Tomcat下的bin目录cd /usr/local/tomcat/bin使用Tomcat关闭命令./shutdown.sh找到tomact 进程netstat –apn | grep 8080使用检测出的进程号，直接杀死Tomcat进程kill -9 7010 //7010代表进程号，每次是不一样的然后继续查看Tomcat是否关闭ps -ef|grep java如果出现以下信息，则表示Tomcat已经关闭root 7010 1 0 Apr19 ? 00:30:30 [java] &lt;defunct&gt;最后，启动Tomcat./startup.sh jar + nohup 永久运行 重启tomcat 对项目不影响。war部署 tomcat没有自动解压。一次可能没有 多重启几次tomcat。maven打包jar运行 报错 无主清单属性。what ？ 打包正常 jar运行 报错 无主清单属性why? pom.xml程序入口没设置 jar、war区别 区别 jar 运行在java环境 要指定入口类 带main()的类 需要打包第三方jar放在同级目录 war 运行在tomcat服务器 重启二次服务器自动解压 war 自动解压后 记得 运行startup.bat (linux：bin下 ./shutdown.sh ./startup.sh) 1.不要在idea中运行tomcat 这样运行的是源项目 不是打包的war 2.查看启动日志(tail -300f /usr/local/tomcat7/logs/catalina.out) 与8080端口是否处于监听状态(netstat -anp|grep 8080) 判断 tomcat是否启动成功。 3.发现自己改啦server.xml 端口号设置为8888 而8888端口被占用啦 netstat -apn|grep 8888 4.所以要看启动日志。tomcat start并不代表就成功啦。。。 win10下 mysql数据库 中文乱码问题 靠谱教程 linux默认utf8what？ 1.我cmd创建数据库 CREATE DATABASE tmall_ssm DEFAULT CHARACTER SET utf8; 插入时，cmd查看数据库乱码，链接软件查看乱码 2.我cmd创建数据库 CREATE DATABASE tmall_ssm (默认编码是lanti) 插入时，cmd查看数据库正常，链接软件查看乱码 what fuck? 3.我一个表一个表的创建就没乱码 直接source导入就出现乱码 whatfuck？ 复制.sql文件的sql语句 到cmd运行 会因为条数太多 执行时报错 一小段一小段运行就可以。。。。 4.现在cmd显示正确 链接软件查看乱码 项目运行也是乱码 ？why？ 1.mysqld 服务端 后台运行 不可见的 2.mysql 客户端 mysql控制台访问 3.软件/jdbc远程访问 是通过 mysql 客户端 进而访问 mysqld 服务端 4.每个层字符集必须一致 否则乱码。 how? 查看字符集 show variables like ‘character_set%’; 修改my.ini文件 (在安装位置一级目录下) [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 重启mysql：win+r-&gt; net stop mysql -&gt; net start mysql 客户端直接导入.sql文件 软件客户端正常 项目jdbc数据正常/ source 导入 软件客户端正常 项目jdbc数据正常 控制台客户端乱码 解决方法：[mysql] default-character-set=utf8 1.[mysql] default-character-set 是客户端默认字符集。如果采用命令行作为客户端，此字符集必须和命令行默认字符集能够匹配，否则出现中文乱码。 [mysql]和[mysqld]数据字符集可以不同，因为MySQL服务器配置文件Index.xml如果有预编译编码，服务器是能够识别客户端数据编码并转换成服务器端编码储存在相应的表中。关键是要在Index.xml配置文件中存在此预编译字符集。 3.开始尝试解决sqlDevelopor远程登陆MySQL客户端出现中文乱码问题 4.必须明确一点，sqlDeveloper首先连接MySQL客户端，然后通过客户端再连接MySQL服务器。因此，必须保证sqlDeveloper和MySQL客户端字符编码集相同。 数据管理系统字符集层次 (全部utf8 cmd乱码 软件客户端正常 项目jdbc数据正常) MySQL数据库字符集具有多层次。在配置文件my.ini中仅定义default-character-set、default-set-server，然而MySQL服务器中却存在多层次的字符集结构。 character-set-client 客户端发送给服务器SQL语句字符集 character-set-connection sokect连接字符集 character-set-results 客户端通过SELECT语句显示数据库查询结果字符集 这三种字符集一般是与default-character-set字符集相同的。当然也可以自定义设置。 character-set-database 数据库储存的数据字符集 character-set-server 服务器字符集 character-set-system 系统字符集 这三种字符集一般是与default-set-server字符集相同的。当然也可以自定义设置。 character-set-filesystem 文件系统字符集]]></content>
  </entry>
  <entry>
    <title><![CDATA[后端框架原理学习(官网+how2j方式)]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[spring 框架 以前学写的教程what? IOC(inversion of Control )反转控制 就是创建、管理所有的Java对象，这些Java对象被称为Bean。实现解耦。 DI(Dependency Inject)依赖注入 就是再创建一个对象的同时给啦加点东西 可以是另一个对象 也可以是其他东西。 AOP(Aspect Oriented Program)面向切面编程 将通用业务从具体逻辑中分离出来why? 简化对象创建呗how? applicationContext类是什么？实用的Bean工厂 。 ClassPathXmlApplicationContext类是什么？从类路径ClassPath中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。 FileSystemXmlApplicationContext是什么？从指定的文件系统路径中寻找指定的XML配置文件 XmlWebApplicationContext是什么？从Web应用中寻找指定的XML配置文件12345678910111213141516171819202122232425262728293031323334/*IOC代码举例*///applicationContext.xml&lt;bean name="c" class="类的相对路径"&gt; &lt;property name="类的属性字段" value="属性值"&gt;&lt;/property&gt;&lt;/bean&gt;//testSpring 测试类//实例化Bean工厂applicationContext 得到context获取要创建的对象实例 可写多个配置文件applicationContext context=new ClassPathXmlApplicationContext(new String[]&#123;"applicationContext.xml"&#125;);Category c=(Category)context.getBean("c");System.out.println(c.getName);/*DI*/&lt;bean name="c" class="类的相对路径/Category"&gt; &lt;property name="类的属性字段" value="属性值"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="P" class="类的相对路径/Product"&gt; &lt;property name="类的属性字段" value="属性值"&gt;&lt;/property&gt; //创建一个属性字段为Category字段 指向name为c的Bean &lt;property name="Category" ref="c"&gt;&lt;/property&gt;&lt;/bean&gt;//testSpring 测试类Product p = (Product) context.getBean("p");System.out.println(p.getName());System.out.println(p.getCategory().getName());/*注解 代替xml写IOC/DI*///&lt;context:component-scan base-package="com.how2java.pojo"/&gt;@Component("p")class Product&#123;&#125;@Resource(name="c")/@Autowriteprivate Category category;/*AOP*///.xml SpringMVC 框架what? 加入啦spring的mvc(模型 视图 分排器 分离)框架 spring Hibernate 框架what? orm对象关系映射框架 解决 关系型数据库中加载和存储对象时我们要面临以下五个不匹配的问题 SessionFactory /Session /httpSession 区别 SessionFactory SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理,生产session的工厂 session 是用来表示，应用程序和数据库的一次交互（会话）。在这个Session中，包含了一般的持久化方法（CRUD） Persistence 持久化 就是瞬时数据(比如内存中的数据，是不能永久保存的)持久化为持久数据(比如持久化至数据库中，能够长久保存)。 对象状态：瞬时(类没与session发生联系 jvm关啦 对象没啦) 持久(session创建没关 数据库有记录) 脱管(session关啦 数据库留下记录) 一个主配置文件(数据库连接信息 加载所有表配置文件) 多个表配置文件(建立表与实体类的对应 主键 属性 集合 一对多关系的配置) eg:Category c = (Category) s.get(Category.class, 1); Set ps = c.getProducts(); 与s.get()不同，当使用load的方式来获取对象的时候，只有访问了这个对象的属性，hibernate才会到数据库中进行查询。否则不会访问数据库。 关系的懒加载(配置文件)，Category c = (Category) s.get(Category.class, 1);不会查询product表。 什么是级联？ 简单的说，没有配置级联的时候，删除分类，其对应的产品不会被删除。 但是如果配置了恰当的级联，那么删除分类的时候，其对应的产品都会被删除掉。级联通常用在one-many和many-to-many。 一级缓存：第一次通过id=1获取对象的时候，session中是没有对应缓存对象的，所以会在”log1”后出现sql查询语句。第二次通过id=1获取对象的时候，session中有对应的缓存对象，所以在”log2”后不会出现sql查询语句 二级缓存 存在sessionFactory里面 hibernate本身不提供二级缓存，都是使用第三方的二级缓存插件。 12345678//没有开启二级缓存的情况创建了两个Session在第一个Session里第一次获取id=1的Category 会执行SQL语句第二次获取id=1的Category，不会执行SQL语句，因为有一级缓存在第二个Session里获取id=1的Category，会执行SQL语句，因为在第二个Session，没有缓存该对象。所以总共会看到两条SQL语句。 EhCache提供的二级缓存 (配置虐) 在第二个Session里无查询语句。 Criteria进行分页查询 123456String name="xxx";Criteria c=s.createCriteria(具体查询类名.class)c.add(Restrictions.like("name","%"+name+"%"));c.setFristResult(2)//第三条数据开始c.setMaxResult(5)//数据总数List&lt;类名&gt;lists=c.list(); 对于id不存在的对象的处理 都通过id=500去获取对象 1. get方式会返回null 2. load方式会抛出异常 Hibernate有两种方式获得session 12345678openSession和getCurrentSession他们的区别在于1. 获取的是否是同一个session对象openSession每次都会得到一个新的Session对象getCurrentSession在同一个线程中，每次都是获取相同的Session对象，但是在不同的线程中获取的是不同的Session对象2. 事务提交的必要性openSession只有在增加，删除，修改的时候需要事务，查询时不需要的getCurrentSession是所有操作都必须放在事务中进行，并且提交事务后，session就自动关闭，不能够再进行关闭 N+1是什么意思呢，首先执行一条sql语句，去查询这100条记录，但是，只返回这100条记录的ID(关键点)然后再根据id,进行进一步查询。如果id在缓存中，就从缓存中获取product对象了，否则再从数据库中获取。 1234567首先通过Query的iterator把所有满足条件的Product的id查出来然后再通过it.next()查询每一个对象如果这个对象在缓存中，就直接从缓存中取了否则就从数据库中获取N+1中的1，就是指只返回id的SQL语句，N指的是如果在缓存中找不到对应的数据，就到数据库中去查 查询总数：首先还是准备一个有统计函数的语句select count(*) from ….根据这条SQL语句创建一个Query对象，调用Query对象的uniqueResult()方法，返回一个long型的数据，即查询总数。 1234Query q =s.createQuery("select count(*) from Product p where p.name like ?"); q.setString(0, "%"+name+"%"); long total= (Long) q.uniqueResult(); System.out.println(total); 乐观锁 (配置虐) 防止多个事务操作统一对象导致数据库数据不一致() 1234567891011121314故意创造一个场景来制造脏数据。1. 通过session1得到id=1的对象 product12. 在product1原来价格的基础上增加10003. 更新product1之前，通过session2得到id=1的对象product24. 在product2原来价格的基础上增加10005. 更新product16. 更新product2最后结果是product的价格只增加了1000，而不是2000假设数据库中产品的价格是10000，version是102. session1,session2分别获取了该对象3. 都修改了对象的价格4. session1试图保存到数据库，检测version依旧=10，成功保存，并把version修改为115. session2试图保存到数据库，检测version=11，说明该数据已经被其他人动过了。 保存失败，抛出异常 数据库连接池：建立数据库连接时比较消耗时间的，所以通常都会采用数据库连接池的技术来建立多条数据库连接，并且在将来持续使用，从而节约掉建立数据库连接的时间hibernate本身是提供了数据库连接池的，但是hibernate官网也不推荐使用他自带的数据库连接池。c3p0连接池 配置虐。(只有在高并发量的情况下性能才会体现) 简而言之，就是提升性能 节约时间的。 注解方式：不用写*表与类/类之间的关联配置文件 让主配置文件加载具体类 具体类中通过注解建立表与实体类的对应 主键 属性 集合 一对多关系的配置 A-&gt;B类 一对多 在A类使用@onetomany 一定在b类@ManyToOne1234567891011121314151617181920212223242526/*一对多注解*///1.为Category再加product集合，并提供getter和setter//2.给getProducts方法加上一对多注解//3.fetch=FetchType.EAGER 表示不进行延迟加载@Entity@Table(name = "category_")public class Category &#123; Set&lt;Product&gt;products; @OneToMany(fetch=FetchType.EAGER) @JoinColumn(name="cid") public Set&lt;Product&gt; getProducts() &#123; return products; &#125;&#125;/*多对一注解*///1.@JoinColumn(name="cid") 表示关系字段是cid@ManyToOne @JoinColumn(name="cid") public Category getCategory() &#123; return category; &#125;Category c = (Category) s.get(Category.class, 1);Set&lt;Product&gt; ps = c.getProducts(); how? 1.关系型数据库配置文件(数据库信息(mysql dialect方言 hbm2.ddl show_sql…)然后是mapping 映射到具体 表与类的关联配置) 2.表与类的关联配置(表名 属性一一映射) 3.根据配置文件创建SessionFactory(初始化hibernate) 开启一个session Session s=sf.openSession(); 3.在session上 开启一个事务s.beginTransction(); s.save(对象实例)； 4.s.close(); sf.close(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*关系型数据库配置文件hibernate.cfg.xml*/&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--database configuration--&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver &lt;/property&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/test？characterEncoding=UTF-8 &lt;/property&gt; &lt;property name="connection.password"&gt;admin &lt;/property&gt; &lt;property name="connection.username"&gt;root &lt;/property&gt; &lt;!--sql dialect 为啦适应数据库改变--&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MYSQLDialect &lt;/property&gt; &lt;!--一个线程管理一个事务--&gt; &lt;property name="current+session_context_class"&gt;thread &lt;/property&gt; &lt;property name="show_sql"&gt;true &lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update &lt;/property&gt; &lt;mappring resource="表与类的关联配置的相对路径"&gt;&lt;/mappring&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;/*表与类/类之间的关联配置*/&lt;hibernate-mapping package="类所在包的相对路劲"&gt; &lt;class name="类名" table="数据库表名"&gt; //主键id 类表对象 数据库本体自增长方式 &lt;id name="id" clumn="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="类属性" clumn=“表字段”&gt;&lt;/property&gt; &lt;property name="类属性" clumn=“表字段”&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;/*使用*/&lt;!--根据配置创建session对象--&gt;SesssionFactory SessionFactory=new Configuration.configure().buildSessionFactory();session s=SessionFactory.openSession();s.beginTransction()s.sava();s.close()SessionFactory.close()//基本curd s.get(类名.class,id) ....../*hibernate的原生sql查询*/Query q=s.createSQLQuery(sql);List&lt;类名&gt; lists=q.list();/*一对多关系*//*另一个类的配置文件*//*第一个类-&gt;另一个类 eg:一对多*/&lt;hibernate-mapping package="另一个类所在包的相对路劲"&gt; &lt;class name="类名" table="数据库表名"&gt; //主键id 类表对象 数据库本体自增长方式 &lt;id name="id" clumn="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="类属性" clumn=“表字段”&gt;&lt;/property&gt; &lt;property name="类属性" clumn=“表字段”&gt;&lt;/property&gt; &lt; &lt;/class&gt;&lt;/hibernate-mapping&gt; struct 框架what? web.xml就是前端控制器的配置 可以用Filter拦截请求并交给-&gt; struct.xml分配到具体的类执行。 session存放会议数据的容器 并提供啦操作数据的方法。 123456789101112131415struts中的Session有两个一个是传统的servlet包下的HttpSession另一个是Struts中自己定义的Session传统的servlet包下的session的获取办法是：ServletActionContext.getRequest().getSession();使用该方法，需要在eclipse的项目中导入servlet-api.jar，可以在右边下载新的Session的获取办法是Map m = ActionContext.getContext().getSession();这个session以Map类的形式出现，其中的值和HttpSession中的值是同步的 product.setName("iphone7");Map m = ActionContext.getContext().getSession(); m.put("name", product.getName()); return "show"; iterrator 迭代器标签 12345678910111213//.jsp&lt;s:iterator value="products" var="p" status="st"&gt; &lt;tr&gt; &lt;td&gt;$&#123;p.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;p.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.index&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.last&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.odd&#125;&lt;/td&gt; &lt;td&gt;$&#123;st.even&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; form 标签 123456&lt;form id="addProduct" name="addProduct" action="addProduct.action" method="post"&gt;//struct.xml&lt;action name="addProduct" class="com.how2java.action.ProductAction" method="add"&gt; &lt;result name="input"&gt;addProduct.jsp&lt;/result&gt; &lt;result name="show"&gt;show.jsp&lt;/result&gt;&lt;/action&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java Spring Boot企业微信点餐系统的坑]]></title>
    <url>%2F2018%2F08%2F16%2FJava%20Spring%20Boot%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[遇坑集合 配置数据没设置UTF-8编码(记不住) 导致数据库乱码 没有设置spring-boot-starter-parent版本与教程一致 导致jpa.findOne()等方法报错 忘记写@Runner(SpringRunner.class)+@SpringBootTest注解导致测试类方法一直不成功 删除啦默认构造函数导致jpa默写方法失效报错No identifier specified for entity 还没搞清楚Date怎么自动记录当前时间并提交(已懂：不是通过注解实现的 是sql语句。。。。) @Id 忘啦设置导致No identifier specified for entity @Service 忘啦 报错Error creating bean with name java.util.Date 测试报错could not execute statement 换成java.sql.Date 并在数据库端更改字符集为utf8 测试sava()成功 自动生成创建时间 不能用java.sql.Date 又改回来 enums 枚举类中没有构造方法 会报错 需要@Getter 不需要set方法 把Data当字段 应该Date @Data 是注解 Page findByBuyerOpenid(String buyerOpenid, Pageable pageable); (在jpa中加个这方法 花式报错 说参数不对) 不等价(测试时遇到的)12345List&lt;ProductInfo&gt;productInfos=null;//正常错、对 Assert.assertNotEquals(0,productInfos.size()); //测试一直对 Aseert.assertNouNull(productInfos); 用注解实现创建时间 更新时间 字段 教程 @EntityListeners @CreatedDate @LastModifiedDate @EnableJpaAuditing 缺一不可 123456789101112@EntityListeners(AuditingEntityListener.class)public class ProductCategory &#123; @CreatedDate @Column(name="create_time") private Date createTime; @LastModifiedDate @Column(name = "update_time") private Date updateTime;&#125;//启动类加注解@EnableJpaAuditing 用注解实现表之间的关系 （eg:插入一列ProductInfo数据 必须先指定一个ProductCategory）教程- @OneToOne @ManyToOne @OneToMany @ManyToMany @Column（name = “自定义字段名”，length = “自定义长度”，nullable = “是否可以空”，unique = “是否唯一”，columnDefinition = “自定义该字段的类型和长度”） @Transient 表示该属性并非一个到数据库表的字段的映射 OneToOne关系映射OneToMany/ManyToOneOneToOne关系映射12345678//ProductInfo@ManyToOneprivate ProductCategory productCategory;//ProductCategory//categoryType是关联属性 两个表都有//上面单方管理有问题 下面没问题@OneToManyList&lt;ProductInfo&gt; productInfoList; ManyToMany关系映射jpa自定义sql实现复杂查询 自定义 select * from product_category 可以 下面sql语句数据库可以查出来 程序测试不同 未解决。 网上说：Select后面没有别名！！！ 靠 多表关联查询不能有*吗？ select a.category_id ,b.product_id from Product_category a inner join Product_info b on a.category_type=b.category_type 测试通过。。。。 123 //jpa中学原生sql@Query(value="select a.* ,b.* from Product_category a inner join Product_info b on a.category_type=b.category_type", nativeQuery = true)List&lt;Object&gt; testsql(); 引错包 导致Page 分页参数错误 应该是import org.springframework.data.domain.Pageable; 而不是import java.awt.print.Pageable; 更正后测试通过 数据库sql建表 一直存在的误区 CONSTRAINT fk_property_category FOREIGN KEY (cid) REFERENCES category (id) 只是建立外键约束 不一定是 一对多/一对一 意思是 property表中cid指向category表的id 两者一样 ，在property表插入数据，其cid的值必须在category的id中存在，否则插入失败。 一对多等表之间的关系在实体类中体现。 123456789101112class Dormitory&#123; int id; String name; int size; private List&lt;Student&gt; students;&#125;class Student&#123; int id; int did;//外键字段 String name; private Dormitory dormitory;&#125; 一个表的外键一定是另一个表的主键吗? of cource!个毛 网上两种说法：1.对，2.不一定是主键，但必须是维一索引，主键是维一索引。 区别 主键可以有多个 主键约束（PRIMARY KEY） 唯一性约束（UNIQUE） 唯一索引（INDEX） 放弃jpa建表 用原生sql建表 jpa 建立外键约束 教程 @JoinColumn(name = “tid”,foreignKey = @ForeignKey(name = “none”,value = ConstraintMode.NO_CONSTRAINT)) name值会在创建数据库自动创建外键tid字段。(所以实体类不用声明外键字段) 目前问题：外键自动创建啦 但不管插什么都是空 1234567@ManyToOne@JoinColumn(name = "tid",foreignKey = @ForeignKey(name = "none",value = ConstraintMode.NO_CONSTRAINT))private Teacher teacher;@OneToMany(mappedBy = "teacher")@org.hibernate.annotations.ForeignKey(name = "none")private List&lt;Student&gt; students; 好的东西 lombok插件 +@Data注解=get/set/toString() idea中下载lombok插件并在pom.xml配置 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; springboot框架注解 按ctrl+鼠标点方法 可以看到源代码 统一api接口返回的json格式。 freemaker（.ftl）模板引擎的使用(特定语法完成分页细节判断) pom.xml引入 突然发现artifactId有spring-boot-starter groupId则为org.springframework.boot 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; gson的使用 1234&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 批量修改/修改统一字段 ctrl+shift+R redis 的使用 pom.xml引入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; websocket 的使用 pom.xml引入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocker&lt;/artifactId&gt;&lt;/dependency&gt; springboot用Pagedui对象+freemaker模板引擎做一个分页demo总结一下 1.知道啦jpa的优势和不足 建表还是用原生sql、 2.在jpa中自定义原生sql查询 3.数据拼装以及返回格式统一。 4.RestController与Controller的区别 5.事务、服务、实体类等注解 和第三方的插件lombok 6.好用的api接口测试软件postman]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端恶补原生js_jquery_es6]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%89%8D%E7%AB%AF%E6%81%B6%E8%A1%A5%E5%8E%9F%E7%94%9Fjs_jquery_es6%2F</url>
    <content type="text"><![CDATA[解释一波 原生态js是指遵循ECMAscript标准的javascript jquery 是js框架 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术（异步通讯） ES6 就是ECMAScript 6是新版本JavaScript语言的标准 原生js 怎么学？需要掌握哪些知识？回顾1 ajax异步通讯12345678910111213141516171819202122232425262728293031323334//客户端游览器//jquery实现 需要导包&lt;script&gt; fuction send()&#123; //在此实现数据获取和显示 var path="LoginServlet.action"; $.ajax(&#123; //调用Servlet取得数据 url:path, //返回类型 dataType: 'json', type:'get', success:fuction(data)&#123; //这里面创建页面 alert(data.name); //获得放数据位置的div var content=document.getElementById("content"); var message="&lt;p&gt;welcome"+data.name+"&lt;/p&gt;" //将内容放进去 content.innerHTML=message; &#125; &#125; ); &#125;&lt;/script&gt;&lt;div id="content"&gt;把js中的数据显示在这里&lt;/div&gt;//不能用submit（提交就完蛋啦） 用send&lt;form action="logServlet" method="post"&gt;&lt;button onClick="send"&gt;&lt;/button&gt;&lt;/form&gt; 回顾2 天猫前端how2j教程学习尝试自己写轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0; padding: 0; text-decoration: none; &#125; body &#123; padding: 20px; &#125; #container &#123; position: relative; width: 600px; height: 400px; border: 3px solid #333; overflow: hidden; &#125; #list &#123; position: absolute; z-index: 1; width: 4200px; height: 400px; &#125; #list img &#123; float: left; width: 600px; height: 400px; &#125; #buttons &#123; position: absolute; left: 250px; bottom: 20px; z-index: 2; height: 10px; width: 100px; &#125; #buttons span &#123; float: left; margin-right: 5px; width: 10px; height: 10px; border: 1px solid #fff; border-radius: 50%; background: #333; cursor: pointer; &#125; #buttons .on &#123; background: orangered; &#125; .arrow &#123; position: absolute; top: 180px; z-index: 2; display: none; width: 40px; height: 40px; font-size: 36px; font-weight: bold; line-height: 39px; text-align: center; color: #fff; background-color: RGBA(0, 0, 0, .3); cursor: pointer; &#125; .arrow:hover &#123; background-color: RGBA(0, 0, 0, .7); &#125; #container:hover .arrow &#123; display: block; &#125; #prev &#123; left: 20px; &#125; #next &#123; right: 20px; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; /* 知识点： */ /* this用法 */ /* DOM事件 */ /* 定时器 */ window.onload = function () &#123; var container = document.getElementById('container'); var list = document.getElementById('list'); var buttons = document.getElementById('buttons').getElementsByTagName('span'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var index = 1; var timer; function animate(offset) &#123; //获取的是style.left，是相对左边获取距离，所以第一张图后style.left都为负值， //且style.left获取的是字符串，需要用parseInt()取整转化为数字。 var newLeft = parseInt(list.style.left) + offset; list.style.left = newLeft + 'px'; //无限滚动判断 if (newLeft &gt; -600) &#123; list.style.left = -3000 + 'px'; &#125; if (newLeft &lt; -3000) &#123; list.style.left = -600 + 'px'; &#125; &#125; function play() &#123; //重复执行的定时器 timer = setInterval(function () &#123; next.onclick(); &#125;, 2000) &#125; function stop() &#123; clearInterval(timer); &#125; function buttonsShow() &#123; //将之前的小圆点的样式清除 for (var i = 0; i &lt; buttons.length; i++) &#123; if (buttons[i].className == "on") &#123; buttons[i].className = ""; &#125; &#125; //数组从0开始，故index需要-1 buttons[index - 1].className = "on"; &#125; prev.onclick = function () &#123; index -= 1; if (index &lt; 1) &#123; index = 5 &#125; buttonsShow(); animate(600); &#125;; next.onclick = function () &#123; //由于上边定时器的作用，index会一直递增下去，我们只有5个小圆点，所以需要做出判断 index += 1; if (index &gt; 5) &#123; index = 1 &#125; animate(-600); buttonsShow(); &#125;; for (var i = 0; i &lt; buttons.length; i++) &#123; (function (i) &#123; buttons[i].onclick = function () &#123; /* 这里获得鼠标移动到小圆点的位置，用this把index绑定到对象buttons[i]上，去谷歌this的用法 */ /* 由于这里的index是自定义属性，需要用到getAttribute()这个DOM2级方法，去获取自定义index的属性*/ var clickIndex = parseInt(this.getAttribute('index')); var offset = 600 * (index - clickIndex); //这个index是当前图片停留时的index animate(offset); index = clickIndex; //存放鼠标点击后的位置，用于小圆点的正常显示 buttonsShow(); &#125; &#125;)(i) &#125; container.onmouseover = stop; container.onmouseout = play; play(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container"&gt; &lt;div id="list" style="left: -600px;"&gt; &lt;img src="img/5.jpg" alt="1"/&gt; &lt;img src="img/1.jpg" alt="1"/&gt; &lt;img src="img/2.jpg" alt="2"/&gt; &lt;img src="img/3.jpg" alt="3"/&gt; &lt;img src="img/4.jpg" alt="4"/&gt; &lt;img src="img/5.jpg" alt="5"/&gt; &lt;img src="img/1.jpg" alt="5"/&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;span index="1" class="on"&gt;&lt;/span&gt; &lt;span index="2"&gt;&lt;/span&gt; &lt;span index="3"&gt;&lt;/span&gt; &lt;span index="4"&gt;&lt;/span&gt; &lt;span index="5"&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="javascript:;" id="prev" class="arrow"&gt;&amp;lt;&lt;/a&gt; &lt;a href="javascript:;" id="next" class="arrow"&gt;&amp;gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot进阶之web进阶]]></title>
    <url>%2F2018%2F08%2F11%2Fspringboot%E8%BF%9B%E9%98%B6%E4%B9%8Bweb%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[慕课网完整教程以下教程完整源码@Valid 表单验证1234567891011121314151617//控制器@PostMapping("/insert") public Gril insert(@Valid Gril g1, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; System.out.println(bindingResult.getFieldError().getDefaultMessage()); &#125; Gril g=new Gril(); g.setAge(g1.getAge()); g.setCupSize(g1.getCupSize()); return grilRepository.save(g); &#125;//实体类@Min(value = 18,message = "没成年不能插入数据库")private Integer age; AOP 面向切面编程思想 图解:将通用业务从具体逻辑中分离出来 AOP记录http请求 @After @Before @AfterReturning 统一异常处理自己写返回格式 新建Result类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Result&lt;T&gt; &#123; //错误码 private Integer code; //错误信息 private String msg; //数据 T是个泛型 private T data; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125;/*//通一异常处理 单个对象返回json举例//错误时&#123; "code":1, "msg":"金额必传", "data":null&#125;//正确时&#123; "code":0, "msg":"成功", "data":&#123; "id":20, "cupSize":"B", "age":25, "money":1.2 &#125;&#125;*/ 在controller类使用12345678910111213141516171819202122public Object insert(@Valid Gril g1, BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123;// System.out.println(bindingResult.getFieldError().getDefaultMessage()); //改进 统一异常处理 @Autowrite引入报错 Result result=new Result(); result.setCode(1); result.setMsg(bindingResult.getFieldError().getDefaultMessage()); result.setData(null); return result; &#125; Gril g=new Gril(); g.setAge(g1.getAge()); g.setCupSize(g1.getCupSize()); Result result=new Result(); result.setCode(0); result.setMsg("成功"); result.setData(grilRepository.save(g)); return result; &#125; 把上面的代码用工具类ResultUtil 封装 实现年龄判断并做相应处理 统一异常返回格式。 ResultUtil.err(1,”未成年禁止入内”); @ControllerAdvance @ExceptionHandel @ResponseBody123456789101112131415161718192021222324252627282930313233343536373839404142434445//新建工具类public class ResultUtil &#123; public static Result success(Object object)&#123; Result result=new Result(); result.setCode(0); result.setMsg("成功"); result.setData(object); return result; &#125; public static Result success()&#123; return success(null); &#125; public static Result err(Integer code,String msg)&#123; Result result=new Result(); result.setCode(code); result.setMsg(msg); return result; &#125;&#125;//GrilServicepublic void getAge(Integer id)throws Exception&#123; Gril gril=grilRepository.getOne(id); if(gril.getAge()&lt;10)&#123; throw new Exception("你在上小学"); &#125;else if(gril.getAge()&lt;30)&#123; throw new Exception("你在上初中"); &#125; &#125;//Controller@GetMapping(value = "/getAge/&#123;id&#125;") public void getAge(@PathVariable("id")Integer id)throws Exception&#123; grilService.getAge(id); &#125;//ExceptionHandel@ControllerAdvicepublic class ExceptionHandel &#123; //获取具体Controller类抛出的异常 @ExceptionHandler(value = Exception.class) @ResponseBody public Result handel(Exception e)&#123; return ResultUtil.err(100,e.getMessage()); &#125;&#125; 在改进 自定义异常GrilException123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class GrilException extends RuntimeException&#123; private Integer code; public GrilException(Integer code ,String msg) &#123; super(msg); this.code = code; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125;//使用//GrilServicepublic void getAge(Integer id)throws Exception&#123; Gril gril=grilRepository.getOne(id); if(gril.getAge()&lt;10)&#123; throw new GrilException(100,"你在上小学"); &#125;else if(gril.getAge()&lt;30)&#123; throw new GrilException(101,"你在上初中"); &#125; &#125;//GrilController@GetMapping(value = "/getAge/&#123;id&#125;") public void getAge(@PathVariable("id")Integer id)throws Exception&#123; grilService.getAge(id); &#125;//ExceptionHandel@ControllerAdvicepublic class ExceptionHandel &#123; private final static Logger logger=LoggerFactory.getLogger(ExceptionHandler.class); //获取具体Controller类抛出的异常 @ExceptionHandler(value = Exception.class) @ResponseBody public Result handel(Exception e)&#123; if(e instanceof GrilException)&#123; GrilException grilException=(GrilException)e; return ResultUtil.err(grilException.getCode(),grilException.getMessage()); &#125;else &#123; logger.error("【系统异常】&#123;&#125;"); return ResultUtil.err(-1,"未知错误"); &#125; &#125; 在改进 把错误码方法enum中管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//ResultEnumpublic enum ResultEnum &#123; UNKNOW_ERROR(-1,"未知错误"), SUCCESS(0,"成功"), PRIMARY_SCHOOL(100,"还在上小学"), MIDDLE_SCHOOL(101,"还在上初中"), ; private Integer code; private String msg; ResultEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125;//使用//GrilServicepublic void getAge(Integer id)throws Exception&#123; Gril gril=grilRepository.getOne(id); if(gril.getAge()&lt;10)&#123; throw new GrilException(ResultEnum.PRIMARY_SCHOOL.getCode(),ResultEnum.PRIMARY_SCHOOL.getMsg()); &#125;else if(gril.getAge()&lt;30)&#123; throw new GrilException(ResultEnum.MIDDLE_SCHOOL.getCode(),ResultEnum.MIDDLE_SCHOOL.getMsg()); &#125; &#125;//GrilControllerpublic void getAge(Integer id)throws Exception&#123; Gril gril=grilRepository.getOne(id); if(gril.getAge()&lt;10)&#123; throw new GrilException(ResultEnum.PRIMARY_SCHOOL); &#125;else if(gril.getAge()&lt;30)&#123; throw new GrilException(ResultEnum.MIDDLE_SCHOOL); &#125; &#125;//报错 需改 GrilExceptionpublic class GrilException extends RuntimeException&#123; private Integer code; public GrilException(ResultEnum resultEnum) &#123; super(resultEnum.getMsg()); this.code = resultEnum.getCode(); &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125;&#125;//ExceptionHandel 不用改@ControllerAdvicepublic class ExceptionHandel &#123; private final static Logger logger=LoggerFactory.getLogger(ExceptionHandler.class); //获取具体Controller类抛出的异常 @ExceptionHandler(value = Exception.class) @ResponseBody public Result handel(Exception e)&#123; if(e instanceof GrilException)&#123; GrilException grilException=(GrilException)e; return ResultUtil.err(grilException.getCode(),grilException.getMessage()); &#125;else &#123; logger.error("【系统异常】&#123;&#125;"); return ResultUtil.err(-1,"未知错误"); &#125; &#125;&#125; 单元测试 对api接口(Mappering(url)) /service/ controller方法进行测试 @RunWith @SpringBootTest @AutoConfigureMockMvc 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class GrilControllerTest &#123; @Autowired private MockMvc mvc; @Test public void grilList() throws Exception&#123; mvc.perform(MockMvcRequestBuilders.get("/grilList")) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().string("abc")); &#125;&#125; 多个单元测试 项目打包时会自动运行测试类 有错则打包失败]]></content>
  </entry>
  <entry>
    <title><![CDATA[2小时入门springboot]]></title>
    <url>%2F2018%2F08%2F10%2F2%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8springboot%2F</url>
    <content type="text"><![CDATA[慕课网完整教程遇到问题首选Google 不然会被百度坑死 tomcat把（64位） 与jvm （32位）版本不兼容 解决方法：重新下载jdk 更换jdk并配置 java -version 报错 can’t find java runtime environment 解决方法：把%JAVA_HOME%/bin移到最前面 然后重启 pom.xml 引入两个依赖：mysql.jdbc/jpa 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 配置mysql数据库连接信息 服务器信息 jpa信息 123456789101112131415161718server: port: 8081 servlet: context-path: /grilspring: datasource: url: jdbc:mysql://127.0.0.1:3306/dbgril username: root password: admin driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: create show-sql: true //执行的sql操作会打印在控制台# profiles:## active: dev //使用开发环境配置 总结下注解/请求方式/关键类注解 @Controller //返回json会抱错 @RestController //可返回json @Entry //关联实体类 用于创建数据库 @Id + @GeneratedValue //设置id自增长 @…Mappering @Value(“${cupSize}”) @Component + @ConfigurationProperties(prefix = “gril”) //把配置分组 @Transactional //事务管理 123456789101112131415161718192021222324252627282930313233343536373839404142//获得配置文件单个属性值@Value("$&#123;cupSize&#125;")private String cupSize;//类型在这时候才确定//属性值太多-》分组//application.ymlgril: cupSize: B age: 16//GrilProperties@Component@ConfigurationProperties(prefix = "gril")public class GrilProperties &#123; private String cupSize; private Integer age; public String getCupSize() &#123; return cupSize; &#125; public void setCupSize(String cupSize) &#123; this.cupSize = cupSize; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125;//使用@Autowired private GrilProperties grilProperties; @RequestMapping(value = &#123;"/showgril","showboy"&#125;,method=RequestMethod.GET) public String show()&#123; return grilProperties.getCupSize()+grilProperties.getAge(); &#125; 123456789101112131415161718192021222324252627282930//事务管理注释举例//RestController@RestControllerpublic class GrilController &#123; @Autowired private GrilService grilService; @PostMapping("/inserTwo") public void insertTwo()&#123; grilService.insertTwo(); &#125;//grilService//@Servicepublic class GrilService &#123; @Autowired GrilRepository grilRepository; @Transactional public void insertTwo()&#123; Gril grilA=new Gril(); grilA.setCupSize("A"); grilA.setAge(8); grilRepository.save(grilA); Gril grilB=new Gril(); grilB.setCupSize("A"); grilB.setAge(8); grilRepository.save(grilB); &#125;&#125; 关键类 JpaRepository:继承啦很多数据库操作 eg:findAll()…. 12public interface GrilRepository extends JpaRepository&lt;Gril,Integer&gt; &#123;&#125; 请求方式：主要是GET/POST 接口测试工具 postman 区别1：get 不提交数据到服务器 只从服务器获得数据 区别：post 提交/不提交数据到服务器 返回/不返回数据 123456789101112131415@PostMapping("/insert") public Gril insert(@RequestParam("cupSize")String cupSize, @RequestParam("age") Integer age)&#123; Gril g=new Gril(); g.setAge(age); g.setCupSize(cupSize); grilRepository.save(g); return g; &#125; @GetMapping("select") public List&lt;Gril&gt; findall()&#123; return grilRepository.findAll(); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[私有云owncloud的docker搭建方式]]></title>
    <url>%2F2018%2F08%2F02%2F%E7%A7%81%E6%9C%89%E4%BA%91owncloud%E7%9A%84docker%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[靠谱教程报错 端口80被占用 解决方法：netstat -anp 4|grep 80 发现80端口被httpd占用 kill 6487 命名重复 nc docker rm nc 在试啦20多篇坑爹教程后 LZ终于成功啦！！！！！！！！！！！！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux)运行tomcat权限问题]]></title>
    <url>%2F2018%2F08%2F02%2Fdeepin(linux)%E8%BF%90%E8%A1%8Ctomcat%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[linux启动tomcat权限不足touch: 无法创建’tomcat8/logs/catalina.out’: 权限不够./tomcat7/bin/catalina.sh: 396: ./tomcat7/bin/catalina.sh: cannot create /usr/local/java/tomcat7/logs/catalina.out: Permission denied 解决方法 sudo chown -R 你的用户名 tomcat整个目录1234eg:sudo chown -R fangjun tomcat8 (在tomcat8当前目录运行)发现个奇怪的问题：官网下的tomcat第一次运行 说权限不够。第二次就行了。从how2j下的tomcat 运行说权限不够，给他权限啦。还是报错。。。。成功截图 linux 查看权限 ls -la chown 777 文件名 //所有人可读写。]]></content>
  </entry>
  <entry>
    <title><![CDATA[page与request与session与application的区别]]></title>
    <url>%2F2018%2F08%2F02%2Fpage%E4%B8%8Erequest%E4%B8%8Esession%E4%B8%8Eapplication%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[page与request与session与application的区别page,request,session以及application这4个对象的范围是逐个增加的：page作用于只在一个jsp页面；request只在一个请求的范围内；session 是在浏览器窗口的范围内；application则是在整个服务器的运行过程中。 application 存数据 取数据(通常放登录信息 eg:显示当前用户..)12345@Autowiredprivate ServletContext application;application.setAttribute("username",user.getName());//jsp/themeleaf &lt;a th:text="$&#123;application.username&#125;"&gt;&lt;/a&gt; session /request 存数据 取数据(通常放用户相关信息 eg:显示当前用户..) application与session/request 取得对象的方式不同(X) 存取都是set/getAttribute; 一个是声明对象 一个是参数传入(X) session/request/application放在()里面声明和外面没差。 1234567891011121314public String login2main(User user, Model m, HttpServletRequest request, HttpSession session,ServletContext application) &#123; User user1 = userMapper.getByname(user.getName()); if (user1.getName() != null&amp;&amp;user.equals(user)) &#123; request.setAttribute("username2",user.getName()); session.setAttribute("username1",user.getName()); application.setAttribute("username",user.getName()); return "fristPage"; &#125; else &#123; return "login"; &#125;//jsp/themeleaf&lt;a th:text="$&#123;session.username&#125;"&gt;&lt;/a&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信小程序学习1]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[小程序 就是把javaWeb项目的jsp/(thymeleaf)html的代码放在小程序写。两者的区别 action=”wxtest”|| url: ‘http://localhost:8035/wxtest&#39;,123456789101112131415161718192021222324252627282930313233//jsp&lt;form action="wxtest" method="post"&gt; name: &lt;input name="username"/&gt; &lt;br/&gt; name: &lt;input name="password"/&gt; &lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt;//wx//Page(&#123; // bindtest按钮监听事件 bindtest:function()&#123; wx.request(&#123; url: 'http://localhost:8035/wxtest', data:&#123; username:"001", password:"abc", &#125;, method:"GET", header:&#123; 'content-type': 'application/json' //默认值 &#125;, success: function (res) &#123; console.log(res.data); &#125;, fail: function (res) &#123; console.log("失败"); &#125; &#125;) &#125;&#125;) ((idea)springboot框架)后端+前端(微信小程序)的demo:简单数据交互 完整教程1234567891011121314151617181920212223242526272829303132333435363738394041//后端public class wxController extends HttpServlet &#123; @RequestMapping("/wxtest") public void wxtest(User u, HttpServletResponse response) throws IOException &#123; System.out.println("username:" + u.getUsername() + "passsword:" + u.getPassword()); System.out.println("username:" + u.getUsername() + "passsword:" + u.getPassword()); System.out.println("username:" + u.getUsername() + "passsword:" + u.getPassword()); System.out.println("username:" + u.getUsername() + "passsword:" + u.getPassword()); System.out.println("username:" + u.getUsername() + "passsword:" + u.getPassword()); Writer out=response.getWriter(); out.write("enter wxBack"); out.flush(); &#125;&#125;//前端Page(&#123; // bindtest按钮监听事件 bindtest:function()&#123; wx.request(&#123; url: 'http://localhost:8035/wxtest', data:&#123; username:"001", password:"abc", &#125;, method:"GET", header:&#123; 'content-type': 'application/json' //默认值 &#125;, success: function (res) &#123; console.log(res.data); &#125;, fail: function (res) &#123; console.log("失败"); &#125; &#125;) &#125;&#125;) 把数据库的数据显示在微信小程序页面 结合工具postman理解 后端从数据库取出数据封装成集合对象 发送给微信小程序 小程序在显示 如何发送到小程序 小程序如何调用集合对象并显示？]]></content>
  </entry>
  <entry>
    <title><![CDATA[ajax实现异步通讯]]></title>
    <url>%2F2018%2F07%2F24%2Fajax%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[大致内容 页面向服务器发送request，获取request时页面不刷新。用js实现页面数据更新。 weather 天气数据显示 把对象转换成json对象 把它传到页面 用js显示数据 (以前是直接传对象||集合) ### 1234567891011121314151617181920212223242526//数据是对象的话Student s=new Student(1,"zhangsan",88);//用导入的包的函数 import net.sf.jsoon.JSONObjectJSONObject json=JSONObject.fromObject(s);Sting message=json.toString();System.out.println(s.toString());//数据是集合 //用导入的包的函数 import net.sf.json.JSONArrayList&lt;Student&gt; list =new ArrayList&lt;Student&gt;();list.add(new Student(1,"zhangsan",88));list.add(new Student(1,"zhangsan",88));list.add(new Student(1,"zhangsan",88));list.add(new Student(1,"zhangsan",88));list.add(new Student(1,"zhangsan",88));JSONArray array=JSONArray.fromObject(list);System.out.println(list.toString());//数据是map集合(包含上面两种数据)//把数据合一 用put方法Map map=new HashMap();map.put("stu",s);map.put("stus",list);JSONObject jsonmap=JSONObject.fromObject(map);System.out.println(map.toString()); 实现往客户端输出&amp;客户端接收 完整源码12345//loginAction 这时候页面是不刷新的PrintWriter out=response.getWriter()out.println(message);out.flush();// 12345678910111213141516171819202122232425262728293031323334//客户端游览器//jquery实现 需要导包&lt;script&gt; fuction send()&#123; //在此实现数据获取和显示 var path="LoginServlet.action"; $.ajax(&#123; //调用Servlet取得数据 url:path, //返回类型 dataType: 'json', type:'get', success:fuction(data)&#123; //这里面创建页面 alert(data.name); //获得放数据位置的div var content=document.getElementById("content"); var message="&lt;p&gt;welcome"+data.name+"&lt;/p&gt;" //将内容放进去 content.innerHTML=message; &#125; &#125; ); &#125;&lt;/script&gt;&lt;div id="content"&gt;把js中的数据显示在这里&lt;/div&gt;//不能用submit（提交就完蛋啦） 用send&lt;form action="logServlet" method="post"&gt;&lt;button onClick="send"&gt;&lt;/button&gt;&lt;/form&gt; 成功截图：记住把第三方jar放进tomcat的lib目录下，不然会报错 找不到类。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux)myEclipse的tomcat配置问题]]></title>
    <url>%2F2018%2F07%2F23%2Fdeepin(linux)myEclipse%E7%9A%84tomcat%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[自带tomcat没有把jdbc,jar部署。(直接把第三方jar赋值到tomcat的lib目录下) 本地预览样式表没问题，部署到tomcat出现问题。。。。。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring(ApplicationContext.xml) 就是创建各种对象的工厂。]]></title>
    <url>%2F2018%2F07%2F23%2FSpring%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[大致内容 只要给id 就能根据id 所指的class对象创建出来的工厂。 可以把相关联的对象也创建出来(这就是依赖注入。。。) ApplicationContext.xml lesson14 bean 可以创建对象 方便action里面的操作 要web服务器 加载时 创建出来 对象。 所有对象都实现 所有的action能不能用spring进行创建？ 通过id 能创建对象 并创建其关联对象 spring 对web的支持。 web.xml 建立监听器 以前手动通过文件创建对象 spring 则帮你创建并能实现关联。 spring 就是一个创建对象的工厂。 发现问题：web一般是用代理模式，有没有一种方法：用到代理对象，今后直接在ApplicationContext.xml里面配置？ 需要修改工厂的代理对象方法。 代理对象中获取session web层对象？ 用ThreadLocal spring在加载lisener是把request对象放在啦ThreadLocal 什么时候开始用spring-&gt;从action开始用的 比LoginServet还要早。 在任何地方获得request 就可以获得session 实现类配置时不引用代理类 直接引用实现类。 12ApplicationContext context =Object o=context.getBean("id") spring 创建代理对象。(以前是工厂获得代理对象)12345678//代理对象的配置。&lt;bean id="UserProxy" class=".....factory" factory-method="getProxyInstance"&gt;&lt;constructor-arg ref="UserDao"&gt;&lt;/bean&gt;//把UserDao换成UserProxy&lt;bean id="UserDao" class=".....UserDao" &gt;&lt;property name="id" ref="UserProxy"&gt;&lt;/property&gt;&lt;/bean&gt; 在任何地方获得request 就可以获得session 两种情况： 以前是Application类来实现 代理实现权限控制。123import org.springframeworkHttpServletRequest request=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).kdhfHttpServlet httpsession=request.getSesion(); 123456Uer u=(User)httpsession.getAttributes("user");if(u==null)&#123; result=method.invoke(target,args);&#125;//第一次调用 代理对象String role=u.getRole(); 总结一下 spring 创建对象并创建关联对象-&gt; bean 标签 通过id获取其指向类的对象。 spring 创建代理对象 spring 在全局获得session 并用代理实现权限控制。 12345678910//创建一般对象及其关联 对象&lt;bean id="IUserDao" class=".....IUserDao" &gt;&lt;property name="id" ref="UserDao"&gt;&lt;/property&gt;&lt;/bean&gt;//代理对象创建方法(因为以前是工厂获得代理对象)&lt;bean id="UserProxy" class=".....factory" factory-method="getProxyInstance"&gt;&lt;constructor-arg ref="UserDao"&gt;&lt;/bean&gt;//把UserDao换成UserProxy&lt;bean id="IUserDao" class=".....IUserDao" &gt;&lt;property name="id" ref="UserProxy"&gt;&lt;/property&gt;&lt;/bean&gt; 1234567891011//全局获得request的session对象import org.springframeworkHttpServletRequest request=((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).kdhf；HttpServlet httpsession=request.getSesion();Uer u=(User)httpsession.getAttributes("user");if(u==null)&#123; result=method.invoke(target,args);&#125;//第一次调用 代理对象String role=u.getRole(); 等源码发下来在理一遍。设计步骤- 1.搭建环境：util包里面的东西。jar包 。 sessionFactory.java …. 。ApplicationContext.xml。 log4j。 异常捕获问题。 在web如何显示异常 把异常抛给tomcat服务器， exception.jsp 在web.xml里面配置error Page 把java。lang.Exception和jsp引入 123&lt;h1&gt;服务器出现异常 原因如下&lt;/h1&gt;&lt;%=exception.getMessage() %&gt; 控制器拦截样式表(请求、对字符处理) 新建EncodingFilte implement Filte ; 在web.xml里面配置filter。 拦截器就是对页面跳转的限制。 session 如果dao操作得到的session不为空 session.serAttribute()放进去- 完整全家 过滤器 字符 servlet 对异常统一处理 web 端]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[票务管理系统数据库文档说明]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[文档概览 数据库建表SQL语句 表的说明 票务系统原型界面及功能介绍 数据库建表SQL语句train表123456789101112131415create table train(trid char(30) primary key,trty char(20) not null,trss varchar(50) not null,trsa varchar(50) not null,trst date not null,trat date not null,trcc Integer not null,trsc Integer not null,trkm integer not null,sname varchar(50),)alter table trainadd constraint constraint_fk6foreign key(sname) references station(sname) ticket表123456789101112131415create table ticket(tiid char(8) primary key,tiss varchar(50) not null,tias varchar(50) not null,tist date not null,tiat date not null,tipr decimal(9) not null,titp char(10) not null,tity char(10) not null,tino integer not null,sname varchar(50) ,)alter table ticketadd constraint constraint_fk7foreign key(sname) references station(sname) seller表123456create table seller(slid char(50) primary key,slna varchar(50) not null,slpa varchar(50) not null,sname varchar(50)) station表12345678910create table station(sname varchar(50) primary key,scna varchar(50) not null,spr varchar(12) not null,slid char(50) not null,)alter table stationadd constraint constraint_fk2foreign key(slid) references seller(slid) sale表123456789101112create table sale(tiid char(8) primary key,slid char(50) ,sname varchar(50),slti date not null,)alter table saleadd constraint constraint_fk3foreign key(slid) references seller(slid)alter table saleadd constraint constraint_fk4foreign key(sname) references station(sname) back表12345678create table back(tiid char(8) primary key,slid char(50) ,returnprice decimal(9) not null)alter table backadd constraint constraint_fk5foreign key(slid) references seller(slid) 表的说明train表 ticket表 seller表 station表 sale表 back表 票务系统原型界面及功能介绍登录界面login.jsp 实现登录验证功能 票务系统主界面mian_ticket.jsp 登录成功显示nav.jsp(导航栏)和fristPage.jsp(首页：包含项目简单介绍) 具体功能跳转具体jsp页面(将nav.jsp作为模块引入所有jsp页面) 具体功能包括：1.显示所有列车信息 2.显示所有车票信息 3.信息管理(eg：订单信息管理，用户信息管理。。。) 4.提供信息全局搜索(eg：输入用户名——&gt;输出与之相关的所有信息) 5.显示当前用户。]]></content>
  </entry>
  <entry>
    <title><![CDATA[自己写框架]]></title>
    <url>%2F2018%2F07%2F20%2F%E8%87%AA%E5%B7%B1%E5%86%99%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[大致内容 过滤器实现字符控制：避免乱吗 servlet:就是转发页面(jsp,html)数据，页面跳转。 静态网页和服务器通讯：get post 方法 action 写要访问到那个服务器。 该服务器继承HttpServlet 写doPost do doPost 执行后台业务逻辑 ：dao取得数据 out的缺点：改动不易。 jsp:html+java 将servlet的业务在jsp中执行。 servlet 处理业务逻辑和页面转发 jsp 显示数据 mvc的设计模式 jsp/html serlvet:控制层 业务层 jsp更方便的显示数据。eg:显示对象，集合(用c标签)。 el表达式显示对象 一个request相当于一个请求，下次在请求数据不在啦。 解决方法：通过request新建session，再把数据放在session里面。 el表达式显示对象12345//在jsp中通过键值对取到对象。User user=(User)request.getAttribute("user");//这句可以不要 你在控制写好键值对就行user.getName()//通过request得到对象 通过对象方法取得数据//直接用$&#123;user.name&#125; 显示集合12345678910111213141516171819202122232425262728//在控制层取到数据放入List&lt;User&gt; users=new List&lt;&gt;();//把容器放在request里面//在jsp添加c标签库 引入依赖才能用c标签//user是集合放的单个对象&lt;c:forEach items="$users" var="user"&gt;$&#123;user.name&#125;&lt;/c:forEach&gt;//显示表格&lt;table&gt;&lt;c:forEach items="$users" var="user"&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;.....&lt;/td&gt; &lt;td&gt;.....&lt;/td&gt; &lt;td&gt;&lt;form action="delServlet" method="Post"&gt; &lt;input tpye="hidden" name="userid" value="$&#123;user.id&#125;"/&gt; &lt;button tpye="submit"&gt;删除&lt;/button&gt; &lt;/form&gt;&lt;/td&gt; //另一种方式 &lt;td&gt;&lt;a&gt; &lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt; 菜单根据权限显示 用c标签 选择性的显示。 123&lt;c:test="$&#123;1&gt;2&#125;"&gt; 东西显示不出来&lt;/c&gt; 一个request相当于一个请求，下次在请求数据不在啦。 解决方法：通过request新建session，再把数据放在session里面。 登录对象，菜单对象 12345HttpSession session=request.getSession();- session.addAttribute("sessionusers",users);//在其他页面 通过sessionusers获得对象$&#123;sessionuser.name&#125; 全局对象 sesrvletContext对象 不管谁访问 都可以改 共jihe同拥有。 1request.getServletContext(); 实操表单提交的本质(springboot/ssm框架都对以下内容进行啦封装，用注解直接就可以实现) 通过action指定访问的服务器 通过POST方法发出请求 doPOST方法中获取页面发来的模型层信息 将通过DAO从数据库取到的对象/集合 赋给request.addAttribute(“users”,users) 建立键值对 返回到请求页面。通过键值对访问到对象 重点：键值对]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux)连接云服务器]]></title>
    <url>%2F2018%2F07%2F20%2Fdeepin(linux)%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[windows用的是WINSCP(GUI)和cecuret-ssh(终端) winscp方便上传文件 cecuret-ssh方便部署命令语句的填写。 deepin(linux) 没有WINSCP(GUI)和cecuret-ssh(终端) 怎么办？ssh deepin官网教程 sudo apt-get install openssh-client ssh root@47.95.236.184 之后操作一样 winscp(替代工具)GFTP deepin官网教程 sudo apt-get install gftp 终端输入gftp 即可使用 注意：协议是SSH2 其他协议 内容显示不出来]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写框架1]]></title>
    <url>%2F2018%2F07%2F20%2F%E8%87%AA%E5%B7%B1%E5%86%99%E6%A1%86%E6%9E%B61%2F</url>
    <content type="text"><![CDATA[大致内容 C标签可以干很多事 设计好目录登录窗口 class=”prelodaer” 转动。。 index.jsp自动跳转其他页面 login.jsp 登录窗口 form表单提交。 form表单的数据并没有封装进对象。 数据都给啦一个name值 设计servlet：loginServlet 在loginServlet实现数据的封装- 1&lt;jsp:forward&gt; 1234567891011121314151617181920212223242526272829303132333435363738void doPost()&#123; request.sertContentType("text/html;charset=utf-8"); String username=request.getParameter("username"); String password=request.getParameter("password"); LoginForm f1=new LoginForm(); f1.setUsername(username); f1.setPassword(password); Action action=new LoginAction(); action.execute(); //在在LoginAction的execute()执行业务操作。 //z只是换个地方进行业务逻辑处理。&#125;execute()&#123; LoginForm lf=(LoginForm)form; String name=lf.getUsername(); String password=lf.getPassword(); IUser ud=new User(); Usesr u=ud,getUserById(name,pw); //执行dao取到数据库的数据 //比较表单数据和数据库数据是否相同 //在登录成功或返回错误信息 if(use!=null)&#123; HttpSession session=request.getSession(); session.setAttribute("currenUser",u); request.getRequstDispatcher(".....main.jsp").forward(request,response); &#125;else&#123; //封装错误信息 //跳转回去login.jsp request.setAttribute("error1",error1); //实现页面跳转，很原始6666666666666 request.getRequstDispatcher(...login.jsp)forward(request,respone); &#125;&#125; 在loginServlet实现数据的封装 新建loginForm实体类(不带参的构造方法) 新建ActionForm实体类 新建loginForm父类 Action 登录成功 到主菜单main.jsp 取出currentUser 并显示当前用户。 宿舍管理&amp;学生管理的CURD. 1.——跳转addUser.jsp 2.—–没有数据，没有from(数据) 有action(处理) 业务逻辑 ——–showStudent.jsp 共同点：必须通过servlet进行数据转发。页面跳转。 jsp实现菜单选项的权限控制。&lt;c:if test=”${user.name!=null}&amp;&amp;${user.role=admin}” 过滤器拦截非login.do ？实现字符集的过滤。 统一编码utf-8 不登录根本进不去main.jsp 新建ActionFilter继承Filter 修改web.xml- `javaActionFilter{ private String encoding; private List list}isExit(Listlist String value){ boolean fla}doFilter(){ arg0.setCharacterEncoding(encoding); arg1.setCharacterEncoding(encoding); HttpServletRequest request=(HttpServletRequest)arg0; HttpServletResponse respose=(HttpServletResponse)arg1; String path=request.getRequstUrl().toString(); //获取地址url / 后面的内容 String actionpath=path.subString(path.lastIndexOf(“/“)+1); if(list.contains(actionpath)){ arg2.doFilter(arg0,arg1) }else{ User u=(User)session.getAttribute(“currenUser”); if(u==null){ request.getRequstDispatcher(“…..login.jsp”).forward(request,arg1); } } }init(){ encoding=arg0.getInitParameter(“encoding”); //设置可以直接跳转的路径 String path=arg0.getInitParameter(“actionpath”);}]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day12]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day12%2F</url>
    <content type="text"><![CDATA[大致内容 loginServlet类的doGet/doPost方法获取表单数据。 自己搭web开发框架。。。。(是真的麻烦) 自己动手实现对表的CURD(GUI) –以前都是直接套用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LoginServlet extends HttpServlet &#123; /** * Constructor of the object. */ public LoginServlet() &#123; super(); &#125; /** * Destruction of the servlet. &lt;br&gt; */ public void destroy() &#123; super.destroy(); // Just puts "destroy" string in log // Put your code here &#125; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred * * */ public void print()&#123; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request,response); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); //servlet里面的 response 可以实现 打印网页的形式 输出一个网页 // 1.页面的调度功能 //request.getRequestDispatcher("adddormitry.html").forward(request, response); //2 取得数据 //2.1 获得从客户端提交的数据 String username=request.getParameter("username"); String pw=request.getParameter("password"); System.out.println(username+"----------------"+pw); IUserDao ud=new UserDao(); User u=ud.getUserByNameandPw(username, pw); //要在转发的页面上显示现在的数据 request.setAttribute("user", u); request.setCharacterEncoding("utf-8"); request.getRequestDispatcher("welcome.jsp").forward(request, response); //servlet是纯JAVA代码 优势：处理业务逻辑 劣势：不适合显示数据 //html --纯的静态网页 //jsp---内容上来说 jsp=html+java 运行原理上 jsp==serlvet &#125; /** * Initialization of the servlet. &lt;br&gt; * * @throws ServletException if an error occurs */ public void init() throws ServletException &#123; // Put your code here &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;style type="text/css"&gt; .cc&#123; height: 300px; background-color: aqua; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-md-12 cc"&gt; aaaaaaaaa &lt;/div&gt; &lt;/div&gt; &lt;div class="row" &gt; &lt;div id="table_positon" class="col-md-6 col-md-push-6"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var wangzhichao = &#123; stus: [&#123; id: "001", name: "wzc", age: 18 &#125;, &#123; id: "002", name: "zzw", age: 19 &#125;, &#123; id: "003", name: "cyf", age: 19 &#125;, &#123; id: "004", name: "dhl", age: 16 &#125;], del_studbyId: function(id) &#123; //-------------删除方法 for (var n = 0; n &lt; this.stus.length; n++) &#123; if (this.stus[n].id == id) &#123; this.stus.splice(n, 1); break; &#125; &#125; &#125;, ths: ["学号", "姓名", "年龄", "操作"], tds: ["id", "name", "age"], init: function() &#123; var body = document.body; var div1 = document.createElement("div"); div1.setAttribute("class", "container"); var div2 = document.createElement("div"); div2.setAttribute("class", "row"); var div3 = document.createElement("div"); div3.setAttribute("class", "col-md-6 col-md-push-3"); body.appendChild(div1); div1.appendChild(div2); div2.appendChild(div3); var table = document.createElement("table"); var table_position=document.getElementById("table_positon"); table_position.appendChild(table); table.setAttribute("class", "table table-bordered"); var tr = document.createElement("tr"); table.appendChild(tr); for (var i = 0; i &lt; this.ths.length; i++) &#123; var th = document.createElement("th"); th.setAttribute("class", "text-center"); th.innerHTML = this.ths[i]; th.style.border = "1px solid #ddd"; tr.appendChild(th); &#125; for (var j = 0; j &lt; this.stus.length; j++) &#123; var tr1 = document.createElement("tr"); /* tr1.onmouseover=function()&#123; tr1.style.backgroundColor = "red"; &#125;*/ tr1.onmouseover = (function(tr1) &#123; // alert("----------"); // tr1.style.backgroundColor = "red"; return function() &#123; tr1.style.backgroundColor = "#f5f5f5"; &#125;; &#125;)(tr1); tr1.onmouseout = (function(tr1) &#123; return function() &#123; tr1.style.backgroundColor = "#f9f9f9"; &#125; &#125;)(tr1); // if(j) table.appendChild(tr1); for (var k = 0; k &lt; this.tds.length; k++) &#123; var td = document.createElement("td"); // if (j % 3 == 0) td.style.backgroundColor = "#f9f9f9"; td.setAttribute("class", "text-center"); td.style.border = "1px solid #ddd"; td.innerHTML = this.stus[j][this.tds[k]]; tr1.appendChild(td); &#125; var td_last = document.createElement("td"); // if (j % 3 == 0) td_last.style.backgroundColor = "#f9f9f9"; td_last.setAttribute("class", "text-center"); var button = document.createElement("button"); button.setAttribute("class", "btn btn-sm btn-danger"); button.innerHTML = "删除"; tr1.appendChild(td_last); td_last.style.border = "1px solid #ddd"; td_last.appendChild(button); button.onclick = function(event) &#123; var target = event.target; var del_target = target.parentNode.parentNode; var stuid = del_target.firstChild.textContent; alert(stuid); table.removeChild(del_target); wangzhichao.del_studbyId(stuid); //————调用方法 &#125; console.info(this.stus); &#125; &#125; &#125;; window.onload = function() &#123; wangzhichao.init(); &#125;&lt;/script&gt;&lt;/html&gt; 如何将js创建的table 在body中引用。1234//在table 标签下创建表，把table标签赋给 id=table_positon的divvar table = document.createElement("table");var table_position=document.getElementById("table_positon");table_position.appendChild(table); &lt;div id="table_positon" class="col-md-6 col-md-push-6"&gt;]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表的CURD操作]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E8%A1%A8%E7%9A%84CURD%2F</url>
    <content type="text"><![CDATA[自己动手写表的CURD (springboot+themeleaf环境) 源码 Category(int id,String name)表名及属性 Mybatis通用分页插件PageHelper Properties类的作用 理解PageHelperConfig类如何用properties类来实现分页。 新建实体类Category 新建CategoryMapper类 将方法映射到具体的sql查询语句。 新建CategoryController类，根据游览器传过来的url 执行mapper的不同方法。 已成功完成，如果你的不行，可能原因： 1.注释没写，页面跳转，数据库出错。。。。。。。。 重点：页面如何获得控制层取到的数据集合-&gt;传入页面的model层 使用键值对，m.addAttribute(“page”,page). 另一种获取表单的方法，大同小异 1234567891011Properties类提供了几个主要的方法：1． getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。2． load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。3． setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。4． store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。5． clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。 PageHelperConfig类 PageHelper Mybatis通用分页插件 将包含键值信息的properties对象赋给怕个Helper对象 1234567891011121314@Configurationpublic class PageHelperConfig &#123; //PageHelper分页插件 知道咋用就行 @Bean public PageHelper pageHelper() &#123; PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty("offsetAsPageNum", "true"); p.setProperty("rowBoundsWithCount", "true"); p.setProperty("reasonable", "true"); pageHelper.setProperties(p); return pageHelper; &#125;&#125; CategoryMapper类 注解省啦很多事 12345678910111213141516171819@Mapperpublic interface CategoryMapper &#123; //通过注解让方法关联sql @Select("select * from category_ ") List&lt;Category&gt; findAll(); @Insert(" insert into category_ ( name ) values (#&#123;name&#125;) ") public int save(Category category); @Delete(" delete from category_ where id= #&#123;id&#125; ") public void delete(int id); @Select("select * from category_ where id= #&#123;id&#125; ") public Category get(int id); @Update("update category_ set name=#&#123;name&#125; where id=#&#123;id&#125; ") public int update(Category category);&#125; CategoryController类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Controllerpublic class CategoryController &#123; @Autowired CategoryMapper categoryMapper; @RequestMapping("/addCategory") public String listCategory(Category c) throws Exception &#123; categoryMapper.save(c); return "redirect:listCategory"; &#125; @RequestMapping("/deleteCategory") public String deleteCategory(Category c) throws Exception &#123; categoryMapper.delete(c.getId()); return "redirect:listCategory"; &#125; @RequestMapping("/updateCategory") public String updateCategory(Category c) throws Exception &#123; //调用categoryMapper的方法 间接调用sql语句 categoryMapper.update(c); return "redirect:listCategory"; &#125; @RequestMapping("/editCategory") public String listCategory(int id,Model m) throws Exception &#123; //通过id查找对象 Category c= categoryMapper.get(id); //在传入的模型层对象m 添加键值对，使m所在页面能通过key("c") 访问到value(c) m.addAttribute("c", c); //此时返回ListCategory页面 模型层对象m 可以通过“c”访问到对象c return "editCategory"; &#125; @RequestMapping("/listCategory") public String listCategory(Model m,@RequestParam(value = "start", defaultValue = "0") int start,@RequestParam(value = "size", defaultValue = "5") int size) throws Exception &#123; //以上，参数：传入listCategory页面的模型层对象m 和分页要用到的参数 //以下，设置pageHelp插件让数据以id自减显示并设置开始 和每页的数量。 PageHelper.startPage(start,size,"id desc"); //通过mapper的findAll方法间接调用sql查询到的数据封装到List容器 &lt;Category&gt; cs中 List&lt;Category&gt; cs=categoryMapper.findAll(); //将List容器 cs&lt;Category&gt; 赋值给PageInfo容器 &lt;Category&gt; page PageInfo&lt;Category&gt; page = new PageInfo&lt;&gt;(cs); //在传入的模型层对象m 添加键值对，使m所在页面能通过key("page") 访问到value(page) m.addAttribute("page", page); //此时返回ListCategory页面 模型层对象m 可以通过“page”访问到page容器 return "listCategory"; &#125;&#125; listCategory.html&amp;editCategory.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="width:500px;margin:20px auto;text-align: center"&gt; &lt;table align='center' border='1' cellspacing='0'&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;td&gt;编辑&lt;/td&gt; &lt;td&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;!-- 此处通过控制层在模型层添加的键值对，可以通过page字符串访问到page对象，并调用其方法--&gt; &lt;tr th:each="c:$&#123;page.list&#125;"&gt; &lt;td th:text="$&#123;c.id&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;c.name&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;a th:href="@&#123;/editCategory(id=$&#123;c.id&#125;)&#125;"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;a th:href="@&#123;/deleteCategory(id=$&#123;c.id&#125;)&#125;"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br/&gt; &lt;div&gt; &lt;!--分页 --&gt; &lt;a th:href="@&#123;/listCategory(start=0)&#125;"&gt;[首 页]&lt;/a&gt; &lt;a th:href="@&#123;/listCategory(start=$&#123;page.pageNum-1&#125;)&#125;"&gt;[上一页]&lt;/a&gt; &lt;a th:href="@&#123;/listCategory(start=$&#123;page.pageNum+1&#125;)&#125;"&gt;[下一页]&lt;/a&gt; &lt;a th:href="@&#123;/listCategory(start=$&#123;page.pages&#125;)&#125;"&gt;[末 页]&lt;/a&gt; &lt;/div&gt; &lt;br/&gt; &lt;!--这里字符串到控制层怎么变成Category对象的？ 运行程序，一步步剖析 应该是把name字符串通过键值对 赋给啦Category对象的name属性 然后在跳转到控制层时 传入该Category对象 通过mapper间接调用sql将该对象的name属性添加到数据库 --&gt; &lt;form action="addCategory" method="post"&gt; name: &lt;input name="name"/&gt; &lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="margin:0px auto; width:500px"&gt;&lt;!--因为editCategory页面的模型层已经m.addAttribute("c",c) 所以，在提交表单时，c.name,c.id都会注入对象Category 当跳转到控制层只会传入这个Category对象 --&gt; &lt;form action="updateCategory" method="post"&gt; name: &lt;input name="name" th:value="$&#123;c.name&#125;"/&gt; &lt;br/&gt; &lt;input name="id" type="hidden" th:value="$&#123;c.id&#125;"/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux)自建数据库代码集合记录。]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%87%AA%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81%E7%BB%93%E5%90%88%2F</url>
    <content type="text"><![CDATA[目的是为啦以后同步到云服务器 当然你也可以从本地导出处后上传到云服务器。 在导入到到云服务器的数据库。 我就是熟悉熟悉数据库操作。 create database how2javatable:category_12345CREATE TABLE category_ (id int(11) NOT NULL AUTO_INCREMENT,name varchar(30),PRIMARY KEY (id)) DEFAULT CHARSET=UTF8; table：drom_12345create table dorm_(id int(30) NOT NULL AUTO_INCREMENT,type varchar(30),primary key (id)) DEFAULT CHARSET=UTF8; create database Ticket 数据库文档说明table:trian123456789101112131415161718create table train(trid int ,trty varchar(20) ,trss varchar(50) ,trsa varchar(50) ,trst varchar(50) ,trat varchar(50) ,trcc int(30) ,trsc int(30) ,trkm int(30) ,sname varchar(50))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table train add constraint tm_train_id primary key (trid);//id自增长alter table train change trid trid int auto_increment;//外键约束alter table train add constraint fk_train_station foreign key (sname) references station(sname); 1insert into train values (null, '和谐号', '武汉', '无锡','2018-7-3|11:00','2018-7-3|17:00',8,4,200,null); table:ticket123456789101112131415161718create table ticket(tiid int(30),tiss varchar(50) ,tias varchar(50) ,tist varchar(30) ,tiat varchar(30) ,tipr int(30) ,titp char(10) ,tity char(10) ,tino varchar(30) ,sname varchar(50))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table ticket add constraint tm_ticket_id primary key (tiid);//id自增长alter table ticket change tiid tiid int auto_increment;//外键约束alter table ticket add constraint fk_ticket_station foreign key (sname) references station(sname); 1insert into ticket values (null, '无锡', '武汉', '2018-7-3|11:00','2018-7-3|17:00',260,'硬座','动车票','06-15',null); table:seller12345678910111213create table seller(slid int(50),slna varchar(50) ,slpa varchar(50) ,sname varchar(50))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table seller add constraint tm_seller_id primary key (slid);//id自增长alter table seller change slid slid int auto_increment;//外键约束alter table seller add constraint fk_seller_station foreign key (sname) references station(sname); 1insert into seller values (null,'王思聪' ,'666666',null); table:station123456789101112create table station(sname varchar(50),scna varchar(50) ,spr varchar(12),slid int(50))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table station add constraint tm_station_id primary key (sname);//id自增长//外键约束alter table station add constraint fk_station_seller foreign key (slid) references seller(slid); 1insert into station values ('武汉站','武汉' ,'湖北',1); table:sale1234567891011121314create table sale(tiid int(8),slid int(50) ,sname varchar(50),slti varchar(30))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table sale add constraint tm_sale_id primary key (tiid);//id自增长alter table sale change tiid tiid int auto_increment;//外键约束alter table sale add constraint fk_sale_seller foreign key (slid) references seller(slid);alter table sale add constraint fk_sale_station foreign key (sname) references station(sname); 1insert into sale values (null,1 ,'武汉站','2018-7-3|17:00'); table:back1234567891011create table back(tiid int(8) ,slid int(50) ,backprice varchar(30))ENGINE InnoDB DEFAULT CHARSET=UTF8;//主键约束alter table back add constraint tm_back_id primary key (tiid);//id自增长alter table back change tiid tiid int auto_increment;//外键约束alter table back add constraint fk_back_seller foreign key (slid) references seller(slid); 1insert into back values (null,1 ,'520'); 为啦多表查询方便 先插station 再插trian表123456insert into station values ('无锡南站','无锡','江苏',1);insert into train values (null, '和谐号', '太原', '无锡','2018-7-3|11:00','2018-7-3|17:00',8,4,200,'无锡南站');//以上失败 因为springboot没有用string获取对象 而是id//写back station 表的多表查询insert into station values ('无锡南站','无锡','江苏',4);insert into back values (7,4,'500'); 微信点餐数据库sellcreate database sell;table:product_category create_time timestamp not null default current_timestamp comment ‘创建时间’, (数据库版本原因，在默认或更新时间戳时只能有一个时间戳列) defalut 只有一个 放在所有timestamp字段的最前面 不然报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566-- 类目create table `product_category` ( `category_id` int not null auto_increment, `category_name` varchar(64) not null comment '类目名字', `category_type` int not null comment '类目编号', `create_time` timestamp not null default current_timestamp comment '创建时间', `update_time` timestamp not null comment '修改时间', primary key (`category_id`));-- 商品create table `product_info` ( `product_id` varchar(32) not null, `product_name` varchar(64) not null comment '商品名称', `product_price` decimal(8,2) not null comment '单价', `product_stock` int not null comment '库存', `product_description` varchar(64) comment '描述', `product_icon` varchar(512) comment '小图', `product_status` tinyint(3) DEFAULT '0' COMMENT '商品状态,0正常1下架', `category_type` int not null comment '类目编号', `create_time` timestamp not null default current_timestamp comment '创建时间', `update_time` timestamp not null comment '修改时间', primary key (`product_id`));-- 订单create table `order_master` ( `order_id` varchar(32) not null, `buyer_name` varchar(32) not null comment '买家名字', `buyer_phone` varchar(32) not null comment '买家电话', `buyer_address` varchar(128) not null comment '买家地址', `buyer_openid` varchar(64) not null comment '买家微信openid', `order_amount` decimal(8,2) not null comment '订单总金额', `order_status` tinyint(3) not null default '0' comment '订单状态, 默认为新下单', `pay_status` tinyint(3) not null default '0' comment '支付状态, 默认未支付', `create_time` timestamp not null default current_timestamp comment '创建时间', `update_time` timestamp not null comment '修改时间', primary key (`order_id`), key `idx_buyer_openid` (`buyer_openid`));-- 订单商品create table `order_detail` ( `detail_id` varchar(32) not null, `order_id` varchar(32) not null, `product_id` varchar(32) not null, `product_name` varchar(64) not null comment '商品名称', `product_price` decimal(8,2) not null comment '当前价格,单位分', `product_quantity` int not null comment '数量', `product_icon` varchar(512) comment '小图', `create_time` timestamp not null default current_timestamp comment '创建时间', `update_time` timestamp not null comment '修改时间', primary key (`detail_id`), key `idx_order_id` (`order_id`));-- 卖家(登录后台使用, 卖家登录之后可能直接采用微信扫码登录，不使用账号密码)create table `seller_info` ( `id` varchar(32) not null, `username` varchar(32) not null, `password` varchar(32) not null, `openid` varchar(64) not null comment '微信openid', `create_time` timestamp not null default current_timestamp comment '创建时间', `update_time` timestamp not null comment '修改时间', primary key (`id`)) comment '卖家信息表';]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day11]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day11%2F</url>
    <content type="text"><![CDATA[大致内容 hover方法 / 组件.style.Border(“”)改变样式 移动js写表格的位置。设置div的id=”table_postion”; var table_postion=document.getElementById(“table_postion”); table_postion.appendChild(table);//table是最高级父标签 闭包：用内存模型图理解。 web开发：web project 并不是maven project。 怎么配置web.xml 请求与响应模型。 1.php jsp seevelt 发到客户端的全部是静态的部分 以数据流 2.不管服务器怎么执行 最后以 数据流的方式把数据《html》+数据的方式 发到游览器端 html+js 3.图片的加载 jsp=java+html。 jsp就是servelet 如何理解js内存模型 java内存模型：你知道new 对象时内存发生的变化和方法压栈就行 js内存模型：你要知道function何时被调用就行 如何解决闭包： 加(function(){})()； 自动运行 1234567891011121314151617181920212223242526272829303132&lt;script type="text/javascript"&gt; function f1()&#123; //局部变量 var a=10; var b=function f2()&#123; alert(a); &#125; a=20; return b;//等于20 &#125; //先运行a=10 在运行a=20 再运行b这个函数。-》闭包 //闭包：在函数里面写函数，用于获取函数的局部变量时 里面的function不运行。 //闭包产生的原因：变量搞完，方法才使用。 function f2()&#123; var arr=new Array(); for(var i=0;i&lt;10;i++)&#123; arr[i]=function()&#123; alert(i) &#125; &#125; return arr;//变量搞完之后 调用方法function。 &#125; var aa=f1();//执行f2 里面的function不运行。 for(var j=0;j&lt;aa.length;j++)&#123; aa[j](); &#125; //如何让里面的function自动运行 加() arr[i]=(function()&#123; alert(i) &#125;)(i);//传过来i 并自动运行。&lt;/script&gt; web开发 Linux上没有myeclipse 直接用自己熟悉的idea工具。 Springboot框架 开发宿舍管理系统 页面跳转/获取客户端传来的表单from数据。 根据名字name取]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用chrome对html文件debug]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%A6%82%E4%BD%95%E5%AF%B9html%E6%96%87%E4%BB%B6debug%2F</url>
    <content type="text"><![CDATA[推荐使用atom+Emmet+javascript-snippets Emmet 对html文件的html css 部分智能提示 javascript-snippets 对html文件的js部分智能提示 chrome的开发者工具 fn+F12 打开console 鼠标放上去会显示错误原因。 atom-ternjs ：js文件代码自动补全，对html文件无效。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day10]]></title>
    <url>%2F2018%2F07%2F17%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day10%2F</url>
    <content type="text"><![CDATA[大致内容 js：能干啥？难点。 js继承：原型链 与java继承不同 fuction函数的三个角色(可以干多种工作)：一般函数，构造函数，对象 必须清楚fuction的角色 才能使用。 js写表格 不用div table等标签。 网页的实现原理：div都是以对象的方式展现在内存上。对象的包含思想。 所有东西都包含在window对象里面。 解释执行，一行一行执行，如果是函数，则加载。script中 看到数据就分配空间。 var a=10; script中 这个a在window对象中 可以window.a调用 (window可以省略) var 可以是任意类型。看你赋给它什么值。 4种数据封装 数据产生一个集合 然后转化成json格式传给你。 函数的实现以及闭包的思想。 定义函数 函数作为参数传递。 属性封装 方法用原型琏进行添加。 动态的生成网页。 创建对象的三种方法 json格式 构造函数 需要new 构造函数 不需要new 12345678910111213141516171819202122var s1=&#123; id:'0001', name: 'zhangsan', age:20&#125;;//用构造函数new一个对象function stu1(id,name,age)&#123; this.id=id; this.name=name; this.age=age;&#125;var s3=new stu1('0004','liuer',50);//不用new 直接调用function stuInstance(id,name,age)&#123; var m=new object(); m.id=id; m.name=name; m.age=age; return m;&#125;var m2=stuInstance('00009','www',60); 重点：原型内存模型图 原始教程 新建一个对象都会默认有一个prototype 指向构造函数。输出该prototype会返回一个完整的构造函数，有啥用？鬼知道。 只要清除用原型创建方法就行。 这个不像java，有栈区，静态方法区，堆区。 所有函数初始化完成后都会创建一个函数对象和一个原型对象，并且通过prototype、construcor属性相互引用 重点：作用域琏内存模型图 原始教程js作用域 作用域是指当前正在执行的代码能够访问到变量的范围; 每个函数都有各自的作用域，存储函数所有的局部变量(严格来说作用域存的是指针)变量对象 变量对象用于存储函数各自的局部变量 每个函数都有各自的变量对象，并且在函数执行时被创建 作用域中存储的其实是变量对象的引用，而变量对象才是存储函数局部变量的地。如图。 JS作用域的内存模型属性封装 方法用原型琏进行添加。 原型是什么?为什么要使用原型？ 为什么属性不?用原型琏进行添加？ 要清楚数据的流动。(在内存是怎么传递的) 1.new 一个对象 会 prototype。 函数：四种方法对函数的调用函数之间的继承 son.prototype=father.prototype; 12345678910111213141516171819202122232425262728293031&lt;script&gt;//为什么用继承 实现继承 function father(name)&#123; this.name=name;&#125;//用原型添加father的方法 father.prototype.getName=function()&#123; return this.name; &#125; fuction son(name,age)&#123; //让father成为Son的属性 //父类依赖子类、执行 father.call(this,name); //此时方法没有进来 this.age=age;&#125; //让son的原型对象指向father的原型对象，此时son.prototype可以通过Father.prototype访问到 father的方法。 son.prototype=father.prototype; //或者这样写 Object 把father的原型prototype拷贝一份。 son.prototype=object(father.prototype); //用原型添加father的方法 26 28 顺序不能换 一换就把 son.prototype.getAge=function()&#123; return this.age; &#125; var s=new Date()//子类创建对象 完成啦对父类对象的使用。//---------------去看内存结构图&lt;/script&gt; 实操用js写表格 只要会新建标签createElement()，设置setAttribute() ,从任何形式数组取数据，给组件赋值赋值innerHTML。 重点说一下：从任何形式数组取数据 eg:从weather数组取数据。 var container=document.createElemement(“div”);//创建标签 container.setAttribute(“class”,”container”);//设置style 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;script&gt;//body也是对象。 var studs=[&#123;id:'0000001',name:'李星',age:20&#125;, &#123;id:'0000002',name:'李星1',age:30&#125;, &#123;id:'0000003',name:'李星2',age:40&#125;]; var tableheads=["学号","姓名","年龄","操作"]; var studattribution=["学号","姓名","年龄","操作"]; function init()&#123; //所有东西都是对象 有可以得到 没有可以创建。 var body=document.body; var container=document.createElemement("div"); container.setAttribute("class","container"); //添加带class="container"的div body.appendChild(container); var row=document.createElemement("div") row.setAttribute("class","row"); container.appendChild(row); var col=document.createElemement("div") col.setAttribute("class","col-md-12"); row.appendChild(col); //-------------weather return col; &#125; function inittable(col)&#123; var table=document.v=createElement("table"); table.setAttribute("table "); var tr_head=document.createElement("tr"); table.appendChild(tr_head); //创建表头 for(var i=0;i&lt;tableheads.length;i++)&#123; var th=document.createElement("th"); th.setAttribute("class","text-center"); th.innerHTML=tableheads[i]; table.appendChild(th); &#125; //生产td 表项 for(var j=0;j&lt;studs.length;j++)&#123; var tr=document.createElement("tr"); for(var k=0;k&lt;studs.length;j++)&#123; var td=document.createElement("td"); td.setAttribute("class","text-center"); td.innerHTML=studs[j][studattribution[k]]; tr.appendChild(td); &#125; //写删除按钮 var td_last=document.createElement("td"); td_last.setAttribute("class","text-center"); var button=document.createElement("button"); button.setAttribute("class","btn bg-warning"); button.innerHTML="删除"; button.onclick=function(event)&#123; var target=event.target; var t=target.parentNode.parentNode; // alert(t); table.removeChild(t); // alert(t); &#125;; td_last.appendChild(button); tr.appendChild(td_last); table.appendChild(tr); &#125; &#125; window.onload=function()&#123; inittable(init()); &#125;&lt;/script&gt; 重点说一下：从任何形式数组取数据 eg:从weather数组取数据。 顺便看一下js的其他数组 js没有集合，或者说使用数组实现的集合。 取weather数组数据的思路：取到数组最外部对象，然后一步步深入 weather数组里面有date,message,status,city,count,data，yesterday，forecast对象 (称为一级属性) data属性里面有n个二级属性 ，yesterday属性里面有n个二级属性，forecast对象是对象数组，每个二级对象含有n的三级属性。 weather[8][1].date 就获取到啦forecast的第一个对象的date属性值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; //js的数组 js没有集合 所以数组很重要 var stu=[]; var stud=new Array(); var nums=[1,2,3,4,5,6]; //全部赋值 //如何实现 item 每一项 index 索引 (item,index)也行 nums.forEach(function(item,index,array)&#123; alert(index); &#125;); //对象数组 var ss=[&#123;id:1,name:'zhangsan',age:20&#125;,&#123;id:1,name:'zhangsan',age:20&#125;,&#123;id:1,name:'zhangsan',age:20&#125;] //数组遍历 for(var i=0;i&lt;ss.lenghtl;i++)&#123; document.write(ss[i].name+" "); &#125; //----------------------- var message='&#123;id:1,name:'zhangsan',age:20&#125;'; var message1='&#123;"id":1,"name":'zhangsan',"age":20&#125;'; alert(message)； //转化为json数据格式 var m1=JSON.parse(message); var mobjct=eval('('+message+')'); //-------------weather 网上给的是字符串 赋值给weather weather就是Json对象。 var weather=&#123;"date":"20180717", "message":"Success !", "status":200, "city":"北京", "count":2, "data": &#123;"shidu":"95%","pm25":9.0,"pm10":13.0,"quality":"优","wendu":"22","ganmao":"各类人群可自由活动", "yesterday": &#123;"date":"16日星期一","sunrise":"04:58","high":"高温 30.0℃","low":"低温 24.0℃","sunset":"19:42","aqi":49.0,"fx":"南风","fl":"&lt;3级","type":"雷阵雨","notice":"带好雨具，别在树下躲雨"&#125;, "forecast": [&#123;"date":"17日星期二","sunrise":"04:59","high":"高温 27.0℃","low":"低温 23.0℃","sunset":"19:41","aqi":74.0,"fx":"西风","fl":"&lt;3级","type":"中雨","notice":"记得随身携带雨伞哦"&#125;, &#123;"date":"18日星期三","sunrise":"04:59","high":"高温 32.0℃","low":"低温 24.0℃","sunset":"19:41","aqi":97.0,"fx":"南风","fl":"&lt;3级","type":"小雨","notice":"雨虽小，注意保暖别感冒"&#125;, &#123;"date":"19日星期四","sunrise":"05:00","high":"高温 33.0℃","low":"低温 26.0℃","sunset":"19:40","aqi":101.0,"fx":"南风","fl":"&lt;3级","type":"多云","notice":"阴晴之间，谨防紫外线侵扰"&#125;, &#123;"date":"20日星期五","sunrise":"05:01","high":"高温 34.0℃","low":"低温 27.0℃","sunset":"19:39","aqi":113.0,"fx":"南风","fl":"&lt;3级","type":"多云","notice":"阴晴之间，谨防紫外线侵扰"&#125;, &#123;"date":"21日星期六","sunrise":"05:02","high":"高温 34.0℃","low":"低温 27.0℃","sunset":"19:39","aqi":112.0,"fx":"南风","fl":"&lt;3级","type":"晴","notice":"愿你拥有比阳光明媚的心情"&#125;]&#125;&#125;;//-------------weather//取weather数据的数据//设计一级 二级菜单 格式//如何设计菜单的数据&lt;/script&gt; 将字符串转化为json对象123456789101112131415161718&lt;script&gt; var stus='[&#123;"id":"lf","age":20&#125;,&#123;"id":"zs","age":40&#125;]'; alert(stus); var stuarray=JSON.parse(stus); // stuarray=eval('('+stus+')'); stuarray.forEach(function(item,index,array)&#123; alert(index); &#125;); // alert(stuarray); for(var i=0;i&lt;stuarray.length;i++)&#123; // document.write(stuarray[i].id+"&lt;br&gt;"); &#125;&lt;/script&gt; 闭包+原型链+继承]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux)安装nodejs]]></title>
    <url>%2F2018%2F07%2F17%2Fdeepin(linux)%E5%AE%89%E8%A3%85nodejs%2F</url>
    <content type="text"><![CDATA[下载地址 安装步骤 sudo apt-get install -y nodejs sudo apt-get install -y npm node -v npm -v]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin安装tomcat]]></title>
    <url>%2F2018%2F07%2F16%2Fdeepin%E5%AE%89%E8%A3%85tomcat%2F</url>
    <content type="text"><![CDATA[原始教程下载 并解压1tar -xzvf apache-tomcat-8.5.32.tar.gz -C/home/fangjun/Documents/tomcat 启动服务 进入解压目录的bin文件夹，运行命令./startup.sh 如果显示tomcat start 则说明安装成功 deepin配置tomcat环境 原始教程 deepin(linux)配置环境变量都在etc/profile里面。 更新profile： source etc/profile 获取路径：echo $CATALINA_HOME]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day9]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day9%2F</url>
    <content type="text"><![CDATA[大致内容 html(head body) 表格table：行和列合并。 表单from：与用户交互，填充信息。 会用样式 eg: 设计.containner样式 有需要用的 直接 class=”containner” bootstrap的网格布局Grid 元素自适应屏幕 移动端优先。 本体引入bootsrap/线上引入bootstrap 菜鸟工具 ：bottstrap可视化html编辑工具 直接拖。。。 barckt编辑器 表的样式 直接&lt;table class=”table/table-striped/“ 123456789&lt;link href="css/bootstrap.css" rel="stylesheet" type="text/css"/&gt;&lt;script src="js/jquery文件.js"/&gt;&lt;script src="js/bootstrap文件.js"/&gt;//线上引入&lt;script src="http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt;&lt;link href="http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css" rel="stylesheet"&gt;&lt;script src="http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js"&gt;&lt;/script&gt; 栅格布局12345678910&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6"&gt;一半&lt;/div&gt; &lt;div class="col-xs-6"&gt;一半&lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-xs-4"&gt;1/3&lt;/div&gt; &lt;div class="col-xs-4"&gt;1/3&lt;/div&gt; &lt;div class="col-xs-4"&gt;1/3&lt;/div&gt; &lt;/div&gt; bottstrap可视化 1.先设置栅格布局 2.然后放元素。 如何快速搞出一个像样的静态网站 把bootstrap官网的example复制下来自己改。 下载位置及显示效果如下图 注意：如果要转移html文件，不要忘啦将其所用到的css，js文件一起转移。 如何搞一个像样的动态网站 表单 表格你要熟。 怎么从数据库取数据并显示在web端。 后台curd java开发框架 分层你要熟。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day8]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day8%2F</url>
    <content type="text"><![CDATA[大致内容 如何让工厂模式同时创建其关联模式实现通用 解决创建一个对象时 把其关联对象也创建好。 代理对象解决事务管理 权限的控制 自定义注解 反射机制 两个文件 ：factory.Properties和ApplicationContext.xml。 通用：不出现任何类 通过字符串 在堆区的大Class对象找到方法，并调用。 工厂层 事务 代理 全部动态即通用设计。 动态工厂(动态生产实现类对象和代理类对象赋给实现类接口) 通过MyInnvactionHandler类 根据注解 选择不同处理方式handler，生成代理类对象时引入处理方式。 返回类型Object，需要具体类型自己换 eg:(IRegisterServiceDao)Factory.getProxyInstance(“RegisterServiceDao”); 反射 封装类的结构信息 Student s=new Student(); 1 硬盘-静态方法区 2 堆区创建封装啦这个类的信息的对象 继承信息 父类方法 大Class对象 3种得到大Class对象的方法 Class c1=Student.class;//获得大Class对象 Class c2=s.getClass(); Class c3=Class.forName(“com.whgc.model.Student”)//最通用，不用创建对象 大Class封装啦所有信息(类的信息的对象 继承信息 父类方法 注释方法 只要是这个类improt的其他类 在大Class对象中都可以找到) Field(成员变量) Constructor(构造方法) Method(成员方法) 123456PrivilegeAnnotation p= m.getDeclaredAnnotation(PrivilegeAnnotation.class);``` ```javaClass c3=Class.forName("com.whgc.model.Student")；Method[] methods=c3. 自定义注释(通过反射实现：字符串在大Class里面找)： 通过方法提供属性1234- 注释在引用类的表现方式：类当方法用，方法当属性引用- 默认注解- @Retention(RetentionPolicy.RUNTIME)- @Target(ElementType.METHOD) 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface PrivilegeAnnotation &#123; boolean isValidate(); String[] roles();&#125; 12345678public class StudentDao implements IStudentTDao &#123; @Override //类当方法用，方法当属性引用 @PrivilegeAnnotation(isValidate=true,roles = &#123;"admin","teacher"&#125;) public void addStudent() &#123; System.out.println("addStudent"); &#125; java框架：权限的控制 (反射机制 实现权限管理) 事务控制sessionApplicationContext.xml 类似factory.prppretise 用于根据id创建对象。 区别： 1234&lt;bean id="userdao" class="org.whgc.UserDao"&gt;&lt;/bean&gt;//属性所关联的对象也搞啦&lt;bean id="registerDao" class="org.whgc.RegisterDao"&gt;&lt;/bean&gt;&lt;property &gt;&lt;/property&gt; 实操反射机制 完整源码 根本是通过字符串拼接在堆区的大class对象找到所需要的方法。 获取大class对象有三种方法 newInstance()创建大Class对象实例 getDeclaredMethods()获取其方法 invoke()调用其方法 全程没有创建一个对象，却完成啦创建对象可以完成的所有操作，更改Class.forName()就可已完成对一个类对象的操作。达到通用的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* * 反射:主要作用于访问一个类的私有字段和私有方法 * 使用流程1(已知类的字段以及方法): * A:获取对象Class * B:实例化对象 * C:根据字段名反射私有字段 class.getDeclaredField(字段名) * D:打开允许访问的开关 setAccessible(true); * E:赋值(set): name.set(dog, "二哈"); 访问(get): name.get(dog) * F:根据方法名反射私有方法cls.getDeclaredMethod("eat", String.class, String.class); * G:打开开关 * H:访问私有方法 m2.invoke(dog, "阿拉斯加", "全家桶"); * 使用流程2(不知道类的字段及方法): * A:获取对象Class * B:根据Class反射所有的字段名称以及类型(循环Field[]得出字段名以及字段类型) * C:根据Class反射构造方法 * D:根据构造方法创建对象(object类型) * E:根据B中得到的字段名称和类型分别定义Field并打开开关然后给私有字段赋值 Field name = cls.getDeclaredField("name"); * F:访问私有字段 * G:反射私有方法(也可以反射Method[]数组 循环得出方法名等,类似反射字段数组) * H:打开开关并访问私有方法 */ class Test&#123; main()&#123; Class c1=Student.class;//获得大Class对象 Student s=new Student(1,"王五"); Class c2=s.getClass(); try &#123; Class c3=Class.forName("com.whgc.model.Student"); //大Class可以创建对象 try &#123; Object o=c3.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; //获取其中的method信息 Method[] methods=c3.getMethods(); for(Method m1:methods)&#123; System.out.println(m1.getName()); &#125; //获取其中的成员变量信息 Field[] fields=c3.getFields(); for(Field field:fields)&#123; System.out.println(field.getName()); &#125; //有趣的例子 //id-----对象 StudentDao 属性cd ----CardDao 文件实现关联 //文件配置 id=20 s.setId(20);//不通用 //通用方法 //没有出现类 //依赖注入 //在堆区中，使用大Class对象通过属性得到方法并运行d //特点没有新建类 所有类都可以用 //换类 改Class.forName("com..........") //通过字符串实现方法自动运行 String fieldname1="id";//在大Class对象通过id找到get set方法 并运行 String methodname1="set"+fieldname1.substring(0,1).toUpperCase()+fieldname1.substring(1); System.out.println(methodname1); Method m2=null; for(Method m1:methods)&#123; if(m1.getName().equals(methodname1))&#123; m2=m1; break; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /* output: Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gasp java.lang.InstantiationException: com.whgc.model.Student setId at java.lang.Class.newInstance(Class.java:427) getName setName at com.whgc.test.Test.main(Test.java:19) getId Caused by: java.lang.NoSuchMethodException: com.whgc.model.Student.&lt;init&gt;() wait wait at java.lang.Class.getConstructor0(Class.java:3082) wait equals at java.lang.Class.newInstance(Class.java:412) toString ... 1 more hashCode getClass notify notifyAll setId Process finished with exit code 0 */ 用反射实现通用工厂方法(需配合配置文件) 需要配置文件factory.proprieties(就是ssm中的ApplicationContext.xml)。 通过静态块把配置文件key value 传给 Properties对象 props 在factory.proprieties中key可以随便写，为什么？ 传入字符串通过key获得value（类字符串）用于创建对象 通过key获得value（类字符串）用于创建对象,创建实现类dao对象并返回，全程没有出现某个具体类的创建，实现啦通用工厂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Factory&#123; //.... void getInstance(String name)&#123; String value=props.getProperty(name); object=Class.forName(value).newInstance(); &#125; &#125;``` ```javaclass Factory&#123; //文件+键值实现通用工厂 private static Properties props=new Properties(); static &#123; ResourceBundle rb=ResourceBundle.getBundle("factory"); Enumeration enumeration=rb.getKeys();//类似迭代器 while (enumeration.hasMoreElements())&#123; String key=enumeration.nextElement().toString(); String value=rb.getString(key); props.setProperty(key,value); &#125; &#125; public static Object getInstance(String name)&#123; Object object=null; String value=props.getProperty(name); System.out.println(props); System.out.println(name); try &#123; object=Class.forName(value).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125;class Test1&#123; main()&#123; IStudentDao id=(IStudentDao)Factory.getInstance("studentdao"); id.addStudent(); &#125;&#125;/* factory.proprieties: studentdao=org.whgc.dao.StudentDao userdao=org.whgc.dao.UserDao*//* output： Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gasp &#123;studentdao=com.whgc.dao.StudentDao&#125; studentdao addStudent Process finished with exit code 0*/``` ### 如何自定义注释 使用注释 注释何用 反射调用方法时如何加载注释。- 注解与其他类在形式上不同- 注解类上的默认注解是啥？```java@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface PrivilegeAnnotation &#123; boolean isValidate(); String[] roles();&#125; 如何在其他类方法中使用注解 注解类引入时当方法用，方法当属性用。 12345678class StudentDao&#123; @Override @PrivilegeAnnotation(isValidate=true,roles= &#123;"admin","teacher"&#125;) public void addStudent() &#123; // TODO Auto-generated method stub System.out.println("addStudent"); &#125;&#125; 注解何用：权限控制 事务控制用session(封装啦Connection对象和statement对象) 反射调用方法时如何加载注释 实现权限控制。 加载注释，得到roles进行判断。 123456789101112131415161718192021222324252627282930313233class Test&#123; main()&#123; Object o = null; Class c = forName("com.whgc.dao.StudentDao"); o=c.newInstance(); Method[] methods = c.getDeclaredMethods(); for (Method m1 : methods) &#123; //找有没有带注释的方法 PrivilegeAnnotation p = m1.getDeclaredAnnotation(PrivilegeAnnotation.class); if (p != null) &#123; System.out.println(p); &#125; else &#123; try &#123; m1.invoke(o, null); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; m1.invoke(o,null); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/* output:Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=gasp@com.whgc.util.PrivilegeAnnotation(isValidate=true, roles=[admin, teacher])addStudentProcess finished with exit code 0*/ 用反射实现通用代理 如何自定义异常 使用异常 如何自定义异常 使用自定义异常 1234567891011public class MySqlException extends RuntimeException &#123; //private String message; public MySqlException(String message) &#123; super(message); //this.message = message; &#125;&#125;throw newMyException("error"); 解释一波ApplicationContext.xml和factory.properties的区别。 factory文件只能通过实现类字符串找到其实现类。 ApplicationContext文件能通过实现类字符串找到其实现类并找到与其关联的类。 ApplicationContext文件要完成他的工作必须导第三方jar包。 12345678910111213factory.properties：studentdao=org.whgc.dao.StudentDaouserdao=org.whgc.dao.UserDaoApplicationContext.xml：&lt;Beans&gt;&lt;bean id="userdao" class="org.whgc.dao.UserDao"&gt;&lt;/bean&gt;&lt;bean id="registerdao" class="org.whgc.servicedao.RegisterServiceDao"&gt;//&lt;property name="iud" ref="userdao"&gt;&lt;/property&gt;&lt;property name="U" ref="userdao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/Beans&gt; ApplicationContext.xml的使用与factory.properties不同。1234567891011121314151617181920212223242526272829private static Properties props=new Properties();static &#123; ResourceBundle rb=ResourceBundle.getBundle("factory"); Enumeration enumeration=rb.getKeys();//类似迭代器 while (enumeration.hasMoreElements())&#123; String key=enumeration.nextElement().toString(); String value=rb.getString(key); props.setProperty(key,value); &#125;&#125;String value=props.getProperty(name)/*---------------------------*/ApplicationContext context=new ClassPathXmlApplicationContext("applicationContext.xml"); IUserDao iud=(IUserDao) context.getBean("userdao"); iud.print(); // IRegisterServiceDao isd=(IRegisterServiceDao)context.getBean("RegisterServiceDao"); isd.Register();``` ```text /* output: userdao 's print Method is invoked....... 登录 Process finished with exit code 0 */ 现在来实现动态代理(所有类的可以使用的生产代理类的方法) 并用MyInnvactionHandler类加权限控制 完整源码 全程没有new 新建对象。 关键：MyInnvactionHandler类 和Factory的getProxyInstance(String name)方法。 有啥用？写一个=写啦无数个，效率高。 顺便温习下通用工厂 动态代理还是用工厂实现 如此，我们的工厂就两个通用方法：通用生产实现类对象的方法 &amp; 通用生成实现类代理类的方法。 如果用的是ApplicationContext.xml文件的话，不用static块啦。 MyInnvactionHandler类用于对代理类加处理方式eg:权限控制。 iud-&gt;u 和RegisterServiceDao中的getU()有关？ 12345678910111213141516171819202122232425/*1.传入实体类字符串到Factory的getProxyInstance(String name)方法中 2.通过实体类字符串找到实体类位置 3.创建大Class对象(配置文件不同，找的方式也不同。ApplicationContext.xml更方便)。 4.新建MyInnvactionHandler对象handler并传入实体类对象实现关联。 5.在MyInnvactionHandler类中定义invoke()方法传入需要重写的 实现类对象， 需重写的方法，对象数组Object[] args(这个什么鬼？) 6.将 实现类加载器，实现类接口类型，handler对象作为参数传入java.lang.reflect.Proxy的newProxyInstance()方法。 7.将生成的代理类对象返回给调用getProxyINstance()所要赋给的对象。 8.如何使用代理类对象？看实现类有那些方法就行。 9.当调用代理类的任意方法时都会调用这个方法invoke()，用到了反射，在这儿是管理权限的关键 10.动态代理没有具体类和具体重写方法，看的有点懵逼。 11.MyInnvactionHandler implements InvocationHandler 12.重写java.lang.reflect.InvocationHandler的invoke()方法。 13.MyInnvactionHandler就是代理类。就这样理解把 14.代理类权限控制不是重写方法，是根据注释决定合适能调用被代理方法。*/Object object=null;//创建实现类Object target=getInstance(name);//将实现类对象传入代理类MyInnvactionHandler handler=new MyInnvactionHandler(target);//生产代理类并将实体类对象传给代理类，建立关联，方法属性：类加载器 接口类型 处理方式object=java.lang.reflect.Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),handler);return object; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInnvactionHandler&#123; //实现类 private Object target; //通过构造函数传进来 代理与实现关联 //工厂创建代理类 public MyInnvactionHandler(Object target) &#123; this.target = target; &#125; public boolean isValidate(String[] roles,String role)&#123; boolean flag=false; return flag; &#125; //执行的句柄，当调用代理类的任意方法时都会调用这个方法，用到了反射，在这儿是管理权限的关键 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=null; //根据method获得target实现类的method Method m1=target.getClass().getDeclaredMethod(method.getName(),method.getParameterTypes());//方法名 参数类型 //加权限 找方法的注释 PrivilegeAnnotation privilegeAnnotation=m1.getDeclaredAnnotation(PrivilegeAnnotation.class); Session session=SessionFactory.getSession(); session.beginTransaction(); result=method.invoke(target,args); //为空则不需要权限控制 //取注释 if(privilegeAnnotation==null)&#123; //调用实现类方法 result=method.invoke(target,args); &#125;else &#123; boolean flag=privilegeAnnotation.isValidate(); if(!flag)&#123; result=method.invoke(target,args); System.out.println("sssssssss2"); &#125;else &#123; //获取使用方法的角色信息 String role=Application.getU().getRole(); //获取方法注释的角色信息 String[] roles=privilegeAnnotation.roles(); //看role是否在roles里面。 boolean flag1=isValidate(roles,role); if(flag1)&#123; System.out.println("sssssssss1"); result=method.invoke(target,args); &#125;else &#123; throw new MySqlException("权限不够"); &#125; &#125; &#125; return result; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Factory &#123; private static Properties props=new Properties(); static &#123; ResourceBundle rb=ResourceBundle.getBundle("factory"); //rb. Enumeration&lt;String&gt; enumers= rb.getKeys(); while(enumers.hasMoreElements()) &#123; String key=enumers.nextElement(); String value=rb.getString(key); props.setProperty(key, value); System.out.println(key+value); &#125; &#125; //dao 提供不带参数的构造方法 public static Object getInstance(String name) &#123; Object object=null; String value=props.getProperty(name); System.out.println(value); try &#123; object=Class.forName(value).newInstance(); System.out.println(object.getClass().getName()); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return object; &#125; //通用事务方法 实现权限控制 //创建动态代理。创建代理类 public static Object getProxyInstance(String name)&#123; Object object=null; //创建实现类 Object target=getInstance(name); //将实现类对象传入代理类 MyInnvactionHandler handler=new MyInnvactionHandler(target); //类加载器 接口类型 处理方式 object=java.lang.reflect.Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),handler); return object; &#125;&#125;class Test3&#123; main()&#123; User u=new User("admin"); Application.setU(u); IRegisterServiceDao ird=(IRegisterServiceDao)Factory.getProxyInstance("RegisterServiceDao"); ird.Register(); &#125;&#125; 动态代理实现权限控制(简易版思路) 1.新建对象并设置role ，存入Application类的user对象。 2.在MyInnvactionHandler类中引入实现类对象并获得方法注释roles与Application中的role做比较。 3.如果role在roles[]中 则可以调用该方法，反之则抛出异常。 反射机制实现事务控制 1.对ServiceDao实现权限控制 2.然后在里面写事务不就完成啦对事务的控制。 3.权限控制包括：一般方法控制，事务控制等。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发宿舍管理系统day_1]]></title>
    <url>%2F2018%2F07%2F10%2F%E5%BC%80%E5%8F%91%E5%AE%BF%E8%88%8D%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fday_1%2F</url>
    <content type="text"><![CDATA[数据库&amp;原型建立 (springboot+themeleaf环境下) 遇到小问题：css,js等文件不放在static目录下，html文件是访问不到的。 原因吗？很可能是过滤器，框架不是自己写的，不知到怎么改。 登录功能开发]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[deppin安装mysql]]></title>
    <url>%2F2018%2F07%2F10%2Fdeepin(linux)%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[sudo apt-get install mysql-server 会提示输入密码 sudo apt-get install mysql-clientsudo apt-get install libmysqlclient-devsudo netstat -tap | grep mysql 如果看到有mysql 的socket处于 listen 状态则表示安装成功。 mysql -u root -p linux//linux是我自己设置的密码 show databases; use 数据库名； show tables；]]></content>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day7]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day7%2F</url>
    <content type="text"><![CDATA[大致内容 数据库的表之间的关系 一对多 一对一 表之间存在约束时 插入 删除是有顺序的。 宿舍-学生-卡 说明 一对多 ：一个宿舍多名学生，一个学生多张卡。 接下来实现多对多，需要三张表subject表/student表/##electSubject业务表。 多表查询语句/删除约束/新建约束 drop dormitory是会报错 Student的外键正在引用 为减少耦合度 在表外add dormitory 为 Student外键。 mysql -cmd 事务管理 12345select a.*,b.*，c.* from student a left join SelectSubject b on a.stuid=b.stuidleft jion subject c on c.subjectid=b.subjectid wherebegin traninsert into dormitory values('A1003','4 persons');rollback(出错时)/commit(正确时) 多表查询 inner join /left join 区别 给表添加外键 alter table card add constraint constraint_card foreign key(stuid) references student(stuid); 这句sql语句意思是：在card表中添加名为dormitoryid的外键约束。 删除表中的外键 alter table card drop foreign key constraint_card; 删除card表中的名为constraint_card的外键(表中的外键命名采用constraint_外键表名) 外键不删除，不能删除表删除表中所有数据 delete from tablename; 删除带有外键约束的表中的数据 SET FOREIGN_KEY_CHECKS=0； delete from tablename; SET FOREIGN_KEY_CHECKS=1; 向有约束的表插入数据是有限制的 一对多关系 如：宿舍-学生 肯定先有宿舍信息再有学生。 先插宿舍，再插学生。 123456789101112131415161718192021222324create table dormitory(dormitoryid varchar(10) primary key,drcnitorytype varchar(10) not null);create table student(stuid varchar(20) primary key,stuname varchar(20) not null,stuage int not null,dormitoryid varchar(10));create table card(cardid varchar(10) primary key,cardtype varchar(10) not null,money int default 0,stuid varchar(20));//在card表声明一个student外键alter table card add constraint constraint_card foreign key(stuid) references student(stuid);//在student表中声明一个dormitory外键 叫constraint_student （中文：约束学生）alter table student add constraint constraint_student foreign key(dormitoryid) references dormitory(dormitoryid); 插入数据 insert into dormitory values(‘A001’,’4persons’); insert into student values(‘S001’,’wangshicong’,28,’A001’);//相当于把Student放在A001房间。 insert into card values(‘C001’,’ic_card’,800,’S001’);//相当于把卡放在学生S001中。 多表查询 将三张表等值连接后查询1select a.*,b.*,c.*from dormitory a inner join student b on a.dormitoryid=b.dormitoryid inner join card c on b.stuid=c.stuid; left join与inner join与right join 好奇怪：都一样 难道在一对多中无区别？ 多对多关系的表 如何创建约束 如何进行多表查询 多对多关系：subject-student//student就用上面创的，注意：里面有个外键约束。 通过业务表SelectSubject建立约束 1234567891011121314151617181920212223create table student(stuid varchar(20) primary key,stuname varchar(20) not null,stuage int not null,dormitoryid varchar(10));create table subject(subjectid varchar(20) primary key,subjectname varchar(20) not null,subjecttype varchar(10) not null);create table SelectSubject(id int(5) primary key,subjectid varchar(10) ,stuid varchar(20));//建立外键约束alter table SelectSubject add constraint constraint_fk1 foreign key(subjectid) references subject(subjectid);alter table SelectSubject add constraint constraint_fk2 foreign key(stuid) references student(stuid); 插入数据 先插student 再插subject 最后插SelectSuject insert into dormitory values(‘A002’,’6persons’); insert student values(‘S002’,’wangjinglin’,35,’A002’); insert subject values(‘SB001’,’math’,’like’); insert into SelectSubject values(1,’SB001’,’S001’); 多表查询-多对多关系表 三张表left链接后查询 1select a.*,b.*,c.*from subject a left join SelectSubject b on a.subjectid=b.subjectid left join student c on b.stuid=c.stuid; 一条记录 left right inner 无差别 多条记录有差别 java端设计类 对应表 实现多表查询和数据存放 一对多关系的表的查询 取得的数据 如何存放 多对多关系的表查询 取得的数据 如何存放 打印输出 类的属性设计123456789101112131415161718192021class dormitory&#123; private String dormitryid; private String dromitrytype; private Set&lt;Student&gt; stus=new HashSet&lt;Student&gt;();&#125;class student&#123; private String stuid; private String stuname; private int age; private Dormitry dorm; private Card card; private Set&lt;Subject&gt; subjects =new HashSet&lt;Subject&gt;(); private Set&lt;Card&gt; card =new HashSet&lt;Card&gt;();&#125;class card&#123; private String cardid; private String cardtype; private int money;&#125; 在dao中实现把student 数据放在dormitory对象的Set容器中 并返回dormitory对象 简而言之，将三张表链接后查询得到的结果statement.executeQuery()指向resultSet 注意：resultSet类似游标的东西，并不存储 数据。 123456789101112131415161718192021222324252627282930313233343536373839public Dormitry getDormitryById(String dormid) &#123; // TODO Auto-generated method stub Dormitry dorm=null; Session session=null; session=SessionFactory.getSession(); session.beginTransaction();//begin tran // insert update delete //select count(*) from table String sql="select * from dormitry where dormitryid=?"; StringBuffer buffer=new StringBuffer(); buffer.append("select a.* ,b.* from dormitry a left join student b "); buffer.append("on a.dormitryid=b.dormitryid where a.dormitryid=?"); java.sql.PreparedStatement statement=session.getPreparedStatement(buffer.toString()); try &#123; statement.setString(1, dormid); java.sql.ResultSet resultSet=statement.executeQuery(); boolean flag=true; Set&lt;Student&gt; stus=null; while(resultSet.next()) &#123; if(flag) &#123; dorm=new Dormitry(resultSet.getString(1),resultSet.getString(2)); stus=dorm.getStus(); &#125; stus.add(new Student(resultSet.getString(3),resultSet.getString(4),resultSet.getInt(5))); dorm.setStus(stus); flag=false; &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); throw new org.whgc.util.MySqlException("sql异常 请和管理员联系"+e.getMessage()); &#125; // java.sql.ResultSet result=session.getResultSet(sql) return dorm; &#125; 注意：这个时候取出来的数据有dormitory的对象的所有属性值和Set 完整源码 因为是把dormitory和Student表链接后查询. ResultSet所指向的数据有这些字段. Set只有Student对象 没有其他数据. 不能通过student.getDorm().getDormitryid()得到dormotory对象 有方法，但student的属性dormit对象是null. 问题来啦？把dormitory，student,card链接起来，查询数据sql太长怎么写？。 java端sql语句写的方式. 每个字符串后面记得空一格 不然你的sql语句就有错误啦。 1234StringBuffer buffer=new StringBuffer(); buffer.append("select a.* ,b.*,c.* from dormitory a left join student b "); buffer.append("on a.dormitoryid=b.dormitoryid inner join card c on b.stuid=c.stuid "); buffer.append("where a.dormitoryid=?"); 查询到的数据字段有如下表 目前只是把resultset的前2个字段赋给相应的对象dormitory 后三个字段赋给Student对象再放入Set容器。 当我把第6个字段赋给Student对象报错？因为表有dormitoryid属性 ，类中没有 怎么把ResultSet指向的数据集合的cardid cardtype money字段取出来放在dormitory的属性Set容器的Student对象的属性Set容器中 完整源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class DormitoryDao&#123; statement.setString(1, dormid); java.sql.ResultSet resultSet=statement.executeQuery(); boolean flag=true; Set&lt;Student&gt; stus=null; Set&lt;Card&gt; scard=null; while(resultSet.next()) &#123; if(flag) &#123; //把dormitory属性赋给dormitory对象 dorm=new Dormitory(resultSet.getString(1),resultSet.getString(2)); //获得dormitory对象属性Set&lt;Student&gt; stu容器 stus=dorm.getStus(); &#125; //向stu容器添加Student对象属性 stus.add(new Student(resultSet.getString(3),resultSet.getString(4),resultSet.getInt(5))); //用迭代器取出每一个Student对象并向其属性Set&lt;Card&gt; scard容器添加card的字段信息 Iterator&lt;Student&gt; iterator=stus.iterator(); while (iterator.hasNext())&#123; Student student=iterator.next(); scard=student.getScard(); scard.add(new Card(resultSet.getString(7),resultSet.getString(8),resultSet.getInt(9))); student.setScard(scard); //把Student对象放入dormitory对象的属性Set&lt;Student&gt;容器中 dorm.getStus().add(student); &#125; dorm.setStus(stus); flag=false; &#125;&#125;class Test&#123; main()&#123; IDormitryDao iDormitryDao=Factory.getDormitryDaoInstance(); Dormitory dormitory =iDormitryDao.getDormitryById("A001"); System.out.println("寝室id"+dormitory.getDormitryid()+"寝室类型"+dormitory.getDromitrytype()); Set&lt;Student&gt; stu= dormitory.getStus(); Iterator&lt;Student&gt; iterator=stu.iterator(); while (iterator.hasNext())&#123; Student student=iterator.next(); System.out.println("寝室"+dormitory.getDormitryid()+"的"+"学生id"+student.getStuid() +"学生名字"+student.getStuname()+"学生年龄"+student.getAge()); //获得该学生对象的Set&lt;Card&gt;容器 Set&lt;Card&gt; scard=student.getScard(); Iterator&lt;Card&gt; iterator1=scard.iterator(); while (iterator1.hasNext())&#123; Card card=iterator1.next(); System.out.println("学生"+student.getStuname()+"的"+"卡id"+card.getCardid()+"卡类型"+card.getCardtype()+"卡的钱"+card.getMoney()); &#125; &#125; &#125; &#125;&#125; 目前已完成：java端对 dormitor(一对多) student(一对多)card 表的多表查询 返回一个寝室的信息 该寝室的所有学生信息 该寝室所有学生的所有卡的信息 现在完成：subject(多对多)student表 的多表查询 数据库的表结构 1234567891011121314151617181920212223create table student(stuid varchar(20) primary key,stuname varchar(20) not null,stuage int not null,dormitoryid varchar(10));create table subject(subjectid varchar(20) primary key,subjectname varchar(20) not null,subjecttype varchar(10) not null);create table SelectSubject(id int(5) primary key,subjectid varchar(10) ,stuid varchar(20));//建立外键约束alter table SelectSubject add constraint constraint_fk1 foreign key(subjectid) references subject(subjectid);alter table SelectSubject add constraint constraint_fk2 foreign key(stuid) references student(stuid); 终端多表查询1select a.*,b.* ,c.*from subject a inner join SelectSubject b on a.subjectid=b.subjectid inner join student c on b.stuid=c.stuid where a.subjectid=&quot;SB001&quot;; 查询结果 java端把数据取出来并存在相应容器Set,Set 和属性中 说白啦，就是把一对多 反向做一次 eg:设计SubjectDao弄到subject对象基本属性和容器属性，查subjectid得到全部。 设计StudentDao弄到subject对象基本属性和容器属性，查stuid得到全部。 sql :insert update delete 事务型操作 select count(*) from table; select count(*) as nums from table;//给取得数据起别名。 select 返回一行（id是主键） 返回多行 state.executeQuery()//不是executeUpdate() ResultSet 指针 没有数据对象 指向多表查询的数据。 white（ResultSet.next） ResultSet.getString(3) 返回 查到的数据 第三列的东西 工厂模式 代理模式 写多表数据查询。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop分布式集群搭建]]></title>
    <url>%2F2018%2F07%2F09%2Fhadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[什么是全分布式集群？ 分布式：一个业务分拆多个子业务，部署在不同的服务器上 集群：同一个业务，部署在多个服务器上]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js遍历图片并显示在html中]]></title>
    <url>%2F2018%2F07%2F09%2Fjs%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8html%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;style type="text/css"&gt; #pic img&#123; border:1px solid #ccc; padding:1px; margin:3px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="pic"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var tbsource = "1";//本地文件夹路径var hdfiles = "";var objFSO =new ActiveXObject('Scripting.FileSystemObject');if(!objFSO.FolderExists(tbsource))&#123;alert("&lt;"+tbsource+"&gt;该文件夹路径不存在，或者路径不能含文件名！");objFSO = null;//return;&#125;var objFolder = objFSO.GetFolder(tbsource);var colFiles = new Enumerator(objFolder.Files);//var re_inf1 = /\.jpg$/; 验证文件夹文件是否jpg文件//var re_inf1 = /\[.](jpg|gif|bmg)$/;var re_inf1 =/\.(gif|jpg|jpeg|bmp)$/i;for (; !colFiles.atEnd(); colFiles.moveNext()) //读取文件夹下文件&#123; var objFile = colFiles.item(); if(re_inf1.test(objFile.Name.toLowerCase())) &#123; hdfiles = hdfiles+"&lt;img src='1/"+objFile.Name+"'&gt;"; &#125;&#125;alert(hdfiles);document.getElementById("pic").innerHTML=hdfiles;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day6]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day6%2F</url>
    <content type="text"><![CDATA[大致内容 引入数据库 创建数据库和表 链接数据库 异常处理机制 什么是原子型操作 线程解决Servicedao 对原子型dao统一进行事务管理 为什么要用Servicedao 为什么在servicedao统一进行事务管理，为什么单个原子型dao要用代理类实现事务控制 注意：在lesson9向表user插入数据时 1.获得Connection对象conn=DriverManager.getConnection(url) 2.获得PreparedStatement 的对象 statement=conn.prepareStatement(sql); 3.statement.setString(1, userid);statement.setString(2, name); statement.setInt(3, age); 4.设置自动提交为false：conn.setAutoCommit(false); 5.执行更新：statement.executeUpdate(); 问题来啦：在lesson10中老师加入session ，为什么加入session(事务)？ session完成啦对connetion对象和statement对象的封装，方便调用。 创建数据库 create database Student； 1234567891011121314151617181920212223create table users( id int(30) primary key, userid varchar(10) unique not null, usename varchar(20) not null, age int check(age&gt;=0 and age&lt;100), gj varchar(20));INSERT INTO user ( id, userid,usename,age,gj ) VALUES ( 1, '001','zhangsan',20,'china' );select * from users;create table log_student( id int(10) primary key, logname varchar(16) not null, logaction varchar(20) not null);insert into user (logname,logaction)values('zhangsan','log in');select *from log_student; java链接数据库/事务/ 基本类库 第三方jar 链接数据库 引入类可能发生异常，不要在main() throws exception 123Class.forName(com.mysql.jdbc.Driver);//引入jar 加载相关类库Connection conn= DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/Student?characterEncoding=YTF-8","root","linux");System.out.println("链接成功")； 异常处理机制:强异常捕获，弱异常抛出。 强异常捕获，弱异常抛出。解决问题：调用方式 里面处理的异常你你看不到 throws Expetion() //向下传递 throw 生成一个炸弹抛出 try catch //处理 强异常：代码编译不通过：eg：Socket socket=new Socket(“localhost”,8080); 强异常：IOExpetion UnKnownHostExpetion 必须处理，不能传递 弱异常：代码编译可以通过 eg:int a=3/0; 异常栈：用内存模型图来理解。 RuntimeExpetion exception 举例 12345678910111213Socket socket=new Socket("localhost",8080);Connection conn= DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/Student?characterEncoding=YTF-8","root","linux");System.out.println("链接成功")；String sql="insert into users(uesrid,username,age)values(?,?,?)";PreparedStatement statement=conn.PreparedStatement(sql);statement.setString(1,uesrid);statement.setString(2,usename);statement.setInt(3,age);statement.executeUpdate();System.out.println("插入成功")； 重点： 事务机制：多条记录curd出错 保持数据不变/管理connuser表与log_student表在事务中有关联 修改表会在log_student表插入记录实操用工厂生成conn对像实现类不是原子型操作 提交失败后回滚 sesion是对connection对象和PreparedStatement对象的封装 ，方便调用。 service是对多个原子型操作的封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748addUser(User u)&#123; Session session=SessionFactory.getSession(); //Session session1=SessionFactory.getSession(); session.beginTranction(); String sql="insert into user(username)values)('')" PreparedStatement statement=session.getPreparedStatement(sql); try&#123; statement.setString(1,user.getUserid()); statement.setString(2,user.getUserid()); statement.setString(3,user.getUserid()); &#125;catch&#123; e.prinStackTrace(); session.rollbackTransaction();//出错时回滚 &#125;finally&#123; session.closeSession();//关闭事务 &#125;&#125;rollbackTransaction()&#123; try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;closeSession()&#123;if(state!=null) try &#123; state.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;if(conn!=null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 以上流程存在问题：对user的操作 和 堆log_student是分开的 他们有事务关联 ServiceDao解决此问题。ServiceDao /IService ：按照业务分类原子型dao 对两个表进行操作 事务控制问题：两个dao 都是 同一个session 实现对两个表的操作 同时失败 同时成功。 解决方法：在线程中保存session 12345class MyThread&#123; Thread thread=Thread.currentThread(); System.out.println(thread.getname() );&#125; 1234567class MyThread extends Thread&#123; public void run() &#123; // TODO Auto-generated method stub Thread t=Thread.currentThread(); System.out.println(t.getName()); &#125;&#125; 123456class SessionFactory&#123; ... private static threadLocal&lt;Session&gt; threadLocal=new threadLocal&lt;Session&gt;(); public static Session &#125;// 在原子dao不提交，不关闭 在servicedao统一进行提交(事务管理) ServiceDao 对多个表进行操作 uesrdao对单个表进行操作 单独的dao都没有提交事务，所以在servicedao实现对事务的统一管理 要单独进行原子型操作，用代理类。 所以在原子dao不提交，不关闭 在servicedao统一进行提交(事务管理) 不写userDao事务控制，用代理对象实现以下方法 解决方法：session.commitTransaction()/rollbackTransaction()/closeSession() 写在代理对象。 因为如果你在usedao logstudentdao写事务的话，你写ServiceDAO的时候会造成影响， 比如，userdao处理事务退出啦 logstudentdao处理事务没退出。 问题举例 1234//伪代码1：对user进行dao操作int a=2/0;//伪代码2：对logstudent进行dao操作session.commitTransaction(); 实操：登录并实现插入记录到logstudent 完整源码 目的：知道为什么要用Servicedao 为什么在servicedao统一进行事务管理，为什么单个原子型dao要用代理类实现事务控制 同时成功 同时失败 你要懂代理模式，session Service 原子型操作 线程 工厂模式 自定义异常 throw 异常 单例模式确保session是一致的。(老师实现的不是单利模式，是通过工厂判断 从而始终生产一个对象) 保证conn statement 只有一个 12345678910class sessionFactory&#123; public static Session getSession() &#123; Session session=null; session=threadloacl.get(); if(session==null) &#123; session=new Session(SessionFactory.getConnection()); threadloacl.set(session); &#125;&#125; 目前已将两个表的commit操作放入线程并放在啦RegisterServicDao实现 目前原子型操作(要用代理类)没写 已完成 不报错时 同时提交 报错时 同时回滚。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void RegisterUser(User u, LogStudent logstu) &#123; Thread t=new Thread()&#123; @Override public void run() &#123; int i=1; while (i&lt;2)&#123; Session sessionForUesr=SessionFactory.getSession(); Session sessionForLog=SessionFactory.getSession(); if(sessionForLog==sessionForUesr)&#123; System.out.println("两者的session一样"); &#125;else &#123; System.out.println("两者的session不一样"); &#125; try&#123; UserDao ud=UserDaoFactory.getUseDao(); sessionForUesr=ud.addUser(u); System.out.println("提交user的信息"); sessionForUesr.commitTransaction(); System.out.println("users表插入成功"); System.out.println(); LogStudentDao lgstu1=LogStudentDaoFactory.getLogStudentDao(); sessionForLog=lgstu1.addLogStudent(logstu); System.out.println("提交log的信息"); sessionForLog.commitTransaction(); System.out.println("log表插入成功"); &#125;catch (Exception e)&#123; sessionForLog.rollbackTransaction(); sessionForUesr.rollbackTransaction(); System.out.println("插入失败，已 回滚"); &#125; i+=1; &#125; &#125; &#125;; t.start(); &#125; 把数据改成一个错，一个对，运行结果。 用代理类实现原子性操作（先放着） 上面的是用addUsers(User u)返回session对象进行操作 忽略啦session是单例模式。 void addUser(User u)再做一遍源码 123456789101112131415161718try&#123; Session session=SessionFactory.getSession(); IUserDao user=UserDaoFactory.getUseDao(); ILogStudentDao log=LogStudentDaoFactory.getLogStudentDao(); user.addUser(u); log.addLogStudent(logstu); session.commitTransaction(); System.out.println("插入成功"); &#125;catch (Exception e)&#123; sessionForLog.rollbackTransaction(); sessionForUesr.rollbackTransaction(); System.out.println("插入失败，已 回滚"); &#125; 说白啦就是对一个表dao操作的叠加，理解下图 再以扩散思维理解 事务Service 所有的事务控制不在Servicedao中，而由代理去实现。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker的安装与使用]]></title>
    <url>%2F2018%2F07%2F07%2Fdocker%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker非常详细的使用教程docker是什么？ docker是系统镜像的容器。可以干嘛？ 在电脑安装docker 在docker里面安装centerOS 就可以模拟centerOS服务器 然后可以向云服务器一样部署项目。安装 (我的电脑系统是国产的linux系统-deepin 推荐使用) 官网教程 已确认每步可行 使用安装 镜像 sudo docker pull ubuntu:16.04 sudo docker pull centos 安装资源 sudo docker pull nginx sudo docker pull mysql sudo docker pull tomcat使用镜像 sudo docker run -t -i ubuntu:16.04 /bin/bash 跟阿里云服务器一样使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day5]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day5%2F</url>
    <content type="text"><![CDATA[大致内容 接口和多态的设计模式解决啥问题？eg:植物大战僵尸 多个植物 多个僵尸 方法都是打，但有区别。这时候怎么办？ 适配器模式：实现类一个 接口一个 适配器多个 比较常用的保存数据的集合：List Set Collection Stack Map 在内存中的存储方式不同 遍历方式也不同 表中如何体现：一对一 一对多 一对一：A类中 private Student stu； 一对多：A类中 Set stu =new hashCode(); Stack：两个Stack容器实现撤销操作 思路：撤销时 当时操作对象由A栈出进如B栈 需要时在返回A栈。s.push() /s.pop() List的遍历(for循环 迭代器) Set容器的遍历(迭代器) Collocation 是List Set 等容器的超级接口 应该也可以用迭代器 重点：Map容器key-value 键 值 Map map=new HashMap&lt;String,Student&gt;(); 容器就是对数据的封装，eg：map.entrySet(); 返回的实体对象 内有属性类型 String 和Student 还有get/set方法。 Map容器的存取：map.containKey(s.getStuId);//判断有没有这个键 map.remove(s);//删除一行记录 map.get(s.getStuiId);/根据学生对象的id获取Item对象 也可以取其他数据 遍历map容器：将map容器的数据封装成Entry的集合存入Set容器 Set就可以用迭代器啦。 和ArrayList()不同 hashset() hashMap() 是无序 用treemap()排序 接口与多态 ：两个接口类 通过工厂实现具体实现类之间的交互操作。完整源码 定义植物接口Zhiwu 僵尸接口Jiangshi 通过工厂生产不同具体植物 定义具体具体植物实现类implement植物接口 重写hit(Jaingshi j) 实现类中 将传入的具体僵尸类接口对象(jaingshi j =Factory.getInstance(int id)) 就实现啦具体植物对象打具体僵尸的方法。 简而言之，你要不择手段的把具体僵尸在堆里的数据传入具体植物类里面操作。 适配器模式：实现类一个 接口一个 适配器多个 解决啥问题？ 123456789101112131415public class Adapter1 extends Adaptee implements Target &#123; @Override public void sort1() &#123; // TODO Auto-generated method stub this.print(); &#125; @Override public void sort2() &#123; // TODO Auto-generated method stub &#125;&#125; 12345678910111213141516171819202122public class Adapter2 implements Target &#123; private Adaptee adaptee; public Adapter2(Adaptee adaptee) &#123; super(); this.adaptee = adaptee; &#125; @Override public void sort1() &#123; // TODO Auto-generated method stub adaptee.print(); &#125; @Override public void sort2() &#123; // TODO Auto-generated method stub &#125;&#125; 对象适配器模式 与适配器模式的不同在于，把继承改成关联，降低子类对父类的依赖程度。 Stack：两个Stack容器实现撤销操作12345678910111213141516171819Stack&lt;Shape&gt; stack1=new Stack&lt;Shape&gt;(); Stack&lt;Shape&gt; stack2=new Stack&lt;Shape&gt;(); Shape s1=Factory.getInstance(1); Shape s2=Factory.getInstance(1); Shape s3=Factory.getInstance(1); stack1.push(s1); stack1.push(s2); stack1.push(s3); draw(stack1); Shape sp=stack1.pop(); stack2.push(sp); stack1.push(stack2.pop()); draw(stack1); 遍历map容器：将map容器的数据封装程实体类对象的集合存入Set容器1234567891011Set&lt;Entry&lt;String,Student&gt;&gt; keyvalues=map.entrySet(); Iterator&lt;Entry&lt;String,Student&gt;&gt; ite=keyvalues.iterator(); while(ite.hasNext()) &#123; Entry&lt;String,Student&gt; kv=ite.next(); System.out.println(kv.getKey()+"-----------"+kv.getValue().getName()); &#125; 身份验证算法 十七位数字本体码和一位校验码组成 两个表 （根据位数与第一个表按照位置相乘）%11得到的数安照第二个表查询所对应项 然后 判断与最后一位是否相等。 S = Sum(Ai * Wi), i = 0, … , 16 ，先对前17位数字的权求和 Ai:表示第i位置上的身份证号码数字值(0~9) Wi:7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 （表示第i位置上的加权因子） Y = mod(S, 11) Y: 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 注意：字符‘2’强制转int(‘2’)=52 int(‘2’-‘2’)=2123456789101112131415161718192021222324252627282930String idString="420704199607284250"; char[] idChar=idString.toCharArray(); System.out.println("身份证号"+idString); int[] quanX=&#123;7 ,9 ,10 ,5 ,8 ,4 ,2 ,1, 6 ,3 ,7 ,9 ,10, 5, 8 ,4 ,2&#125;; int num=0; for(int i=0;i&lt;idString.length()-2;i++)&#123;// num+=((int) idChar[i])*(quanX[i]); int b=(int)(idChar[i]-'0');//"2”转换int是52； int a=quanX[i]; num=num+a*b;// num+=Math.pow(quanX[i],(int)idChar[i]);// System.out.println(a);// System.out.println(b);// System.out.println(num); &#125; System.out.println("加权总和"+num); int endMod=mod(num,11); System.out.println("11取模后的结果"+endMod); char[] reseltComform=&#123;'1','0','X' ,'9' ,'8' ,'7', '6' ,'5','4' ,'3' ,'2'&#125;; System.out.println("身份证最后一位为"+idChar[17]); if(reseltComform[endMod-1]==idChar[17]) System.out.println("验证正确"); else System.out.println("验证失败"); /*output:身份证号420704199607284250 加权总和343 11取模后的结果2 身份证最后一位为0 验证正确*/ 简单购物车：打印出购物车中所有商品的价格，数量，总价 所有商品总价。完整源码 首先定义实体类Product 再定义一个类Item封装num与Product(【因为num不是Product的属性，所以这样办) 定义容器Map&lt;String,Item&gt; map=new hashMap&lt;String,Product&gt;(); 买一个东西放一个item对象 最后把所有数据全部取出来，进行算数运算，打印输出 简而言之，就是对Map容器的存取操作(先封装成Entry在存在Set容器中，再用迭代器查询) 迭代器取数据多种方法 kv.getKey()/kv.getValue()/kv.getValue().getProduct().getPrice()是产品的价格属性/kv.getValue()是Item对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445float num=0f; Map&lt;String,Item&gt;map=new HashMap&lt;String,Item&gt;(); Product p1=new Product("001","icecream",5.0f); Product p2=new Product("002","apple",10.0f); Product p3=new Product("003","cookie",15.0f); Product p4=new Product("004","water",20.0f); Product p5=new Product("005","books",25.0f); Item item1=new Item(10,p1); Item item2=new Item(20,p2); Item item3=new Item(30,p3); Item item4=new Item(40,p4); Item item5=new Item(50,p5); System.out.println("把数据放入map"); map.put(p1.getPid(),item1); map.put(p2.getPid(),item2); map.put(p3.getPid(),item3); map.put(p4.getPid(),item4); map.put(p5.getPid(),item5); System.out.println("输出篮子里面的信息"); Set&lt;Map.Entry&lt;String,Item&gt;&gt; keyvalues=map.entrySet(); Iterator&lt;Map.Entry&lt;String,Item&gt;&gt; ite=keyvalues.iterator(); while (ite.hasNext())&#123; Map.Entry&lt;String,Item&gt; kv=ite.next(); System.out.println("key="+kv.getKey()+" "+"name="+kv.getValue().getProduct().getName()+" "+ "价格"+kv.getValue().getProduct().getPrice()+"num="+kv.getValue().getNum()); &#125; System.out.println("打印订单"); System.out.println("欢迎光临"); System.out.println("---------------------------------------------"); Iterator&lt;Map.Entry&lt;String,Item&gt;&gt; ite1=keyvalues.iterator(); while (ite1.hasNext())&#123; Map.Entry&lt;String ,Item&gt; kv=ite1.next(); System.out.println(kv.getValue().getProduct().getName()+"的总价："+" " +kv.getValue().getNum()+ "*"+kv.getValue().getProduct().getPrice()+" =" +kv.getValue().getNum()*kv.getValue().getProduct().getPrice()); num+=kv.getValue().getProduct().getPrice()*kv.getValue().getNum(); &#125; System.out.println("总账单价格"); System.out.println(num); 想方设法直接从从map里面的item对象对其num进行修改，失败。 换种思路，取出它的num 新建Product 新建Item 最后map.put(item.getProduct().getPid(),item)覆盖到原来的]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day4]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day4%2F</url>
    <content type="text"><![CDATA[大致内容 所有新建的类(string类 int类 等)继承java.lang.Object 会拥有一些基础方法(eg:equals() hashCode() 方法 区别对象) Student s=new Student(); Student s1=new Student(); s.hashCode()!=s1.hashCode() s!=s1(正真辨别真伪) 要使s=equals(s1) Student类里面重写equal() 要使s.hashCode()=s1.hashCode() 重写hashCode() extends 不能接final修饰的类（特点：方法不能重写） 修饰常量 final static （static 目的是只生成一份拷贝） 缺省的适配器模式 继承抽象类与继承一般父类区别（抽象类就是方法的精简版 具体完整功能由继承的类实现） 抽象类继承抽象类？允许有抽象方法 非抽象方法 把 继承抽象类扩展想一下就明白啦 非抽象类继承抽象类：不允许有抽象方法 目的：遗留方法等待实现 接口(定义规范用的) 与抽象类的区别：接口类里面只有方法名 比抽象类更精简。 一般类 extends 抽象类 implement 接口类 会发生什么？注意 抽象方法 非抽象方法 在不同类的存在情况。 在类中使用其他类常量调用(常量所在的包不同)：improt导入类 类.属性 String m=s.ip调用 另一种导入方法：improve static 包名.类.* 可直接 属性 eg：String m=ip;调用 接口(接口是一种规范)的多继承 ：一般类/抽象类 implement 接口1 ，接口2 DAO设计模式：模型层model 接口层IDAO（只有方法名） 实现层DAO(链接数据库实现接口层) 工厂层Factory(用来返回接口) 业务层IServiceDao(包含多个c/u/r/d) tool层(工具类) 接口类型可以指向子类对象 类比 父类指向子类 何用？方便调用用子类方法。 原来如何调用(耦合度太高)vs 现在如何调用(用工厂实现 类比 继承与工厂模式 想 接口与工厂模式) 即通过接口调用实现类方法。 List findStudentBySurname(Stringname); //list 容器存储多个对象 每个对象包含多个属性 。 spring替代Factory层。hibernate代替实现层。 无参数的构造方法是默认的，但是如果你创造了一个带有参数的构造方法，那么无参的构造方法必须显式的写出来，否则会编译失败 无参构造方法是为了反射服务的：反射会调用无参构造方法 找到set get 方法 完成属性的调用。 代理模式(静态代理 动态代理 ) 数据多啦用对象保存 对象多啦用 数组/集合保存 eg:List ArrayList(地址数组方式存储) List(地址链表方式存储) ArrayList 模拟数据库 多个线程调用同一个对象 数据不安全问题 博客有写 站内搜。 集合的查询方法 ： while循环 ：迭代器(Iteratorite=list.iterator();) for循环：for(Student s:list){} 泛型(规定容器里面放的东西)：List list=new ArrayList(); 对象(包含数据)过来怎么排序 ?工具类 eg：StudentComprator 深复制 浅复制 (复制list&lt;&gt;再排序 不要飘絮原来的list&lt;&gt;) Collections.sort(list_age,new StudentComparator()) 对容器的对象排序 角色 权限 eg：addStudent() 拦截 可以在内部写逻辑 但不好 代理类解决 ：它和实现类同时实现同一个接口 eg:StudentDaoProxy 类 implement IStudentDao 在代理类中调用实现类方法之前 之后都可以设置限制。 让实现类成为它的关联对象 就可以改实现类的方法addStudent() Factory调用代理类 不是实现类 强异常try catch 弱异常 throws RuntimeException(“权限不够”) 要使s=equals(s1) Student类里面重写父类Object的equal() 方法 此时，s.equals(s1)=true;1234567public boolean equals(Object obj)&#123; boolean flag=false; Student s=null; if(obj instanceof Student) s=(Student)obj; flag=this.id==s.getId()?true:false; return flag;&#125; 要使s.hashCode()=s1.hashCode() 重写hashCode()12345@Overridepublic int hashCode() &#123; // TODO Auto-generated method stub return this.id;&#125; 对象(包含数据)过来怎么排序 ?工具类 eg：StudentComprator123public class StudentComprator implement Comparator&lt;Student&gt;&#123;&#125; 静态代理从方法层进行拦截 最细致。用代理类实现权限控制: 简而言之（内存模型图 解释很清晰）：将堆区实现类对象通过工厂赋给接口类对象，然后将这个接口类对象赋给代理类里面的定义的 接口类对象 此时 代理类对象中的 接口属性指向堆区实现类对象，则可以在代理类中操作实现类的方法。 总结一点，要实现一个类操控另一个类，想方设法实现关联（上面是间接关联） 直接在A类中的构造函数传入B类的对象并赋给类的B对象属性 则是直接关联。 思路：实现类 implement 接口 -&gt; 代理类 implement 同一个接口-&gt; 让代理类关联接口类（实现类也行 但工厂模式Factory.getInstance()返回的是接口类对象 一般通过接口对象调用实现类方法 ） 从而通过代理类的 实现类对象引用访问接口类并对实现类的方法进行限制。 思考：在工厂中把实现类对象赋给接口对象的好处？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class StudentDaoProxy implements IStudentDao &#123; private IStudentDao sd; public StudentDaoProxy(IStudentDao sd) &#123; super(); this.sd = sd; &#125; @Override public Student getStudentById(int id) &#123; // TODO Auto-generated method stub //sd.getAllStudentOrderByAge(id); return null; &#125; @Override public void addStudent(Student s) &#123; // TODO Auto-generated method stub System.out.println("你在调用方法之前就可以判断你要的规则"); User u=Application.getUser(); if(u==null||!u.getRole().equals("admin")) throw new RuntimeException("权限不够"); //if(1!=1) return; sd.addStudent(s); System.out.println("你在调用方法之后就可以判断你要的规则"); &#125; @Override public void delStudentById(Student s) &#123; // TODO Auto-generated method stub &#125; @Override public void updateStudent(Student s) &#123; // TODO Auto-generated method stub &#125; @Override public List&lt;Student&gt; findStudentBySurname(String surname) &#123; // TODO Auto-generated method stub return null; &#125; @Override public List&lt;Student&gt; findStudentByAges(int start, int end) &#123; // TODO Auto-generated method stub return null; &#125; @Override public List&lt;Student&gt; getALLStudents() &#123; // TODO Auto-generated method stub return null; &#125; @Override public List&lt;Student&gt; getAllStudentOrderByAge() &#123; // TODO Auto-generated method stub return null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class StudentDao implements IStudentDao &#123; private static List&lt;Student&gt; list=new ArrayList&lt;Student&gt;(); //静态块模拟数据库 static &#123; list.add(new Student(1,"lisi",24)); list.add(new Student(2,"lisi",22)); list.add(new Student(3,"lisi",25)); &#125; @Override public Student getStudentById(int id) &#123; // TODO Auto-generated method stub return null; &#125; @Override public void addStudent(Student s) &#123; // TODO Auto-generated method stub list.add(s); &#125; @Override public void delStudentById(Student s) &#123; // TODO Auto-generated method stub &#125; @Override public void updateStudent(Student s) &#123; // TODO Auto-generated method stub &#125; @Override public List&lt;Student&gt; findStudentBySurname(String surname) &#123; // TODO Auto-generated method stub return null; &#125; public List&lt;Student&gt; findStudentByAges(int start,int end)&#123; List&lt;Student&gt; list=new ArrayList&lt;Student&gt;(); //list.su return list; &#125; @Override public List&lt;Student&gt; getALLStudents() &#123; // TODO Auto-generated method stub return list; &#125; @Override public List&lt;Student&gt; getAllStudentOrderByAge() &#123; // TODO Auto-generated method stub List&lt;Student&gt; list_age=new ArrayList&lt;Student&gt;(); list_age.addAll(list); Collections.sort(list_age, new StudentComprator()); return list_age; &#125;&#125; 1234567891011121314public class Factory &#123; public static IStudentDao getStudentDaoInstance() &#123; return new StudentDao(); &#125; public static IStudentDao getStudentDaoProxyInstance() &#123; return new StudentDaoProxy(Factory.getStudentDaoInstance()); &#125;&#125;/*值得注意的是 在Factory类中return StudentDao 返回类型是接口- 且 new StudentDaoProxy(Factory.getStudentDaoInstance()); 方法传入的对象是接口类对象 - Factory返回的都是接口类对象(父类对象) 结合 继承+工厂模式理解。*/ 12345678public static IStudentDao getStudentDaoInstance() &#123; return new StudentDao();&#125; public static IStudentDao getStudentDaoProxyInstance() &#123; return new StudentDaoProxy(Factory.getStudentDaoInstance()); &#125; 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //StudentDao sd=new StudentDao(); IStudentDao id=Factory.getStudentDaoProxyInstance(); id.addStudent(new Student(5,"liuer",60)); //List&lt;Student&gt; list=id.findStudentByAges(10, 15); Scanner scan=new Scanner(System.in); //scan. //id. /*output: 你在调用方法之前就可以判断你要的规则 你在调用方法之后就可以判断你要的规则*/ &#125; 设计Usr类 实现登录 存储对象到Aplication 调用Student类的方法 设置相应权限 能调用方法的限制 eg:Usr.role=”admin” 则可以调用addStudent() 实现增加对象。 代码太多就不全贴啦：总之，记住：1.用工厂生产子类对象 2.静态方法可以这样电泳Application.setUser();/Factory.getInstance() 代理类通过关联实现类（这是目的，实际关联的是接口类） 从而对其方法进行限制 关联是间接关联(因为代理类实际关联的是接口类 ) 完整项目放在 github 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package whgc.test;import java.util.ArrayList;import java.util.List;import java.util.Scanner;import whgc.DAO.StudentDao;import whgc.Factory.Factory;import whgc.IDAO.IStudentDao;import whgc.IServiceDao.IRegisterDao;import whgc.model.Student;import whgc.model.User;import whgc.util.Application;public class Test &#123; public static void main(String[] args) &#123; //输出原来学生信息 System.out.println("输出原来所有学生信息"); IStudentDao iso=Factory.getStudentDaoInstance(); List&lt;Student&gt;list=iso.getAllStudentOrderByAge(); for(Student s:list)&#123; System.out.println("学生的年龄"+s.getAge()+" "+"学生的姓名"+s.getName()+" "+"学生id"+s.getId()); &#125; System.out.println(); System.out.println("请输入用户名和密码以及具有的权限"); User u=new User(); Scanner scan=new Scanner(System.in); String role=scan.next(); String password=scan.next(); String permision=scan.next(); u.setRole(role); u.setPassword(password); u.setPremision(permision); //相当于把输入数据存在数据库(这里是放在一个类的属性user里面的) Application a=new Application(); a.setUser(u); System.out.println("输出Application里的user"+Application.getUser()); //获取登录接口实例，调用实现类方法 IRegisterDao ir=Factory.getRegisterInstance(); if(ir.Register())&#123; Student s=new Student(4,"fangjun",21); IStudentDao iso1=Factory.getStudentDaoProxyInstance(); iso1.addStudent(s); IStudentDao ios2=Factory.getStudentDaoInstance(); List&lt;Student&gt;list2= ios2.getList(); for(Student student:list2)&#123; System.out.println("学生的年龄"+student.getAge()+" "+"学生的姓名"+student.getName()+" "+"学生id"+student.getId()); &#125; &#125;else &#123; System.out.println("登录失败"); &#125; &#125;&#125;/*output：输出原来所有学生信息学生的年龄22 学生的姓名lisi 学生id2学生的年龄24 学生的姓名lisi 学生id1学生的年龄25 学生的姓名lisi 学生id3请输入用户名和密码以及具有的权限admin123456add输出Application里的userwhgc.model.User@1d44bcfa输出Application的user的所有信息: admin 123456 add登录成功你拥有的权限是add你可以对Student对象进行的操作add学生的年龄24 学生的姓名lisi 学生id1学生的年龄22 学生的姓名lisi 学生id2学生的年龄25 学生的姓名lisi 学生id3学生的年龄21 学生的姓名fangjun 学生id4Process finished with exit code 0 */]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day3]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day3%2F</url>
    <content type="text"><![CDATA[大致内容 属性私有，方法公有好处体现在：方法中set get方法中可以加判断 static块里面没new就行。 类和类关系：依赖与天生关联 依赖关联 单向关联 双向关联 单例模式：限制构造方法private 此时还是可以通过类的内部方法调用从而新建对象，怎么办？ 定义一个static 类对象 设为null 为空时允许构造函数实例化对象，不为null 不可实例化。即可达到目的。if(single==null) single=new singleInstance() 继承与工厂模式：注意super() 简单工厂：根据指令 用子类构造函数新建对象赋给 父类对象 （工厂全部都是父类对象 构造函数是子类的） 继承的几个难点： 12341.数据是如何通过子类和父类的构造方法完成数据封装2.子类和父类从硬盘加载到静态方法区的顺序和构造方法调用的顺序3.父类和子类都有共同的属性和方法的时候 如何进行 调用4.父类类型指向子类对象的对方法的调用的影响 老师总结的注意事项 12345678910子类继承父类 就自动拥有了父类的公有方法和公有属性（protected ）父类先加载 然后子类再加载构造方法的调用顺序 子类的构造方法的第一行 不写的话 super();super(参数) 实现数据的传递先调用子类的构造方法 但是子类的构造方法的第一行调用父类的构造方法如果子类对象在调用方法的时候，先找父类有没有 如果父类有的话 再找子类 如果找到了 运行如果找不到 就运行父类的方法如果父类和子类都有相同的方法 称之为 重写如果想显式的调用 父类的方法 super.f(); 属性私有，方法公有好处体现在：方法中set get方法中可以加判断123456class A&#123; private int age; public int setAge(int age)&#123; if(age&gt;0) this.age=age; &#125;&#125; 依赖(方法需要传入其他类对象)举例1234567891011121314151617181920212223242526272829public class Zidan &#123; private int bleed; private boolean live; public int damage=50; public Zidan(int bleed,boolean live)&#123; this.bleed=bleed; this.live=live; &#125; public void zi2Tanke(Tanke t)&#123; this.bleed-=damage; t.decreseBleed(damage); &#125; public int getBleed()&#123; return this.bleed; &#125; public boolean getLive()&#123; if(this.bleed&lt;=0) this.live=false; else this.live=true; return this.live; &#125;&#125; 123456789101112131415161718192021222324252627public class Tanke &#123; private int bleed; private boolean live; public Tanke(int bleed,boolean live)&#123; this.bleed=bleed; this.live=live; &#125; public int getBleed()&#123; return this.bleed; &#125; public void decreseBleed(int damage)&#123; this.bleed-=damage; &#125; public boolean getLive()&#123; if(this.bleed&lt;=0) this.live=false; else this.live=true; return this.live; &#125;&#125; 12345678910111213141516171819202122232425262728293031package test;public class test &#123; public static void main(String args[])&#123; Zidan z=new Zidan(100,true); Tanke t=new Tanke(500,true); System.out.println(z.getBleed()); System.out.println(z.getLive()); System.out.println(t.getBleed()); System.out.println(t.getLive()); z.zi2Tanke(t); System.out.println(); System.out.println(z.getBleed()); System.out.println(z.getLive()); System.out.println(t.getBleed()); System.out.println(t.getLive()); &#125;&#125;/* output 100 true 500 true 50 true 450 true*/ 为什么要关联？ 可以通过一个类的对象用其中其他类的引用（这个也在堆区）去访问其堆区的对象天生关联：类中的属性有其他类对象的引用（eg：private Demo demo=new Demo(int id ,int age)；），已实例化。 此时，新建外部类对象会 在 堆区:1. 外部类 会第一步初始化（属性值为null）2.Demo类 第一次初始化并向堆中的对象赋值(第二次初始化) 再执行 外部类的赋值(第二次初始化) 此时，栈区只有一个外部类对象(暂且用a代替) a指向堆区的外部类对象 问题：谁指向堆区的Demo类对象？ 堆区的外部类中的属性demo1234567class A&#123; private int num; private Demo demo=new Demo(int id ,int age); public A(int num)&#123; this.num=num; &#125; &#125; 12345678class Demo&#123; private int age; private int id; public Demo(int id,int age)&#123; this.age=age; this.id=id; &#125;&#125; 12345class test&#123; public static void main(String args[])&#123; A a=new A(); &#125;&#125; 依赖关联：依赖总是和方法同时存在 在新建外部类A对象的时候 A类对象在堆区第一次初始化(属性值为空) 完成赋值后 将demo（也在堆区）指向在堆区初始化的Demo对象 并给堆区的对象赋值 此时，栈区只有一个外部类对象(暂且用a代替) a指向堆区的外部类对象 问题：谁指向堆区的Demo类对象？ 堆区的外部类中的属性demo12345678class A&#123; private int num; private Demo demo; public A(int name)&#123; this.num=num; this.demo=new Demo(int id,int age);//依赖关联 &#125; &#125; 123456789class Demo&#123; private int age; private int id; public Demo(int id,int age)&#123; this.age=age; this.id=id; &#125;&#125; 12345class test&#123; public static void main(String args[])&#123; A a=new A(666); &#125;&#125; 双向关联：基于单向关联的扩展 注意：构造函数 和 this 简单实现：把天生关联做两次 一般实现：把依赖关联做两次 此时，内存结构图为：栈区有demo a两个对象 堆区有包含demo的A类对象和包含a的Demo类对象 栈区demo指向堆区Demo类 栈区a指向堆区的A类对象 12345678class A&#123; private int num; private Demo demo; public A(int num)&#123; this.num=num; this.demo=new Demo(int id,int age); &#125; &#125; 1234567891011class Demo&#123; private int age; private int id; private A a; public Demo(int id,int age)&#123; this.age=age; this.id=id; this.a=A(int num) &#125;&#125; 123456class test&#123; public static void main(String args[])&#123; A a=new A(666); Demo demo=new Demo(1,10); &#125;&#125; 继承的几个难点的解答 1.数据是如何通过子类和父类的构造方法完成数据封装 super()方法 往上传 可以调用父类无参构造函数 （父类没有会报错） 但没有创建对象 2.子类和父类从硬盘加载到静态方法区的顺序和构造方法调用的顺序 先加载父类再加载子类 构造方法调用的顺序 先父类后子类 3.父类和子类都有共同的属性和方法的时候 如何进行 调用 先找父类 再找子类 如果子类方法存在则调用子类 不存在则调用父类 4.父类类型指向子类对象的对方法的调用的影响 Father father=new Son(1,”father”,2,”son”); 多态、动态链接，向上转型 结合工厂模式理解 会屏蔽子类的非重写方法 此时,father instanceof Son=true 即 father 也是 son 对象 屏蔽子类的非重写方法 解决方法：Son(father) 转换 工厂模式(根据指令eg:id=1 来创建子类对象并赋给父类对象)来理解继承123456789101112package org.whgc;public class Cricle extends SShape &#123; private int r=10; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println("this is r="+this.r+"Բ"); &#125;&#125; 1234567891011package org.whgc;public class Rectangle extends SShape &#123; private int a=10; private int b=20; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println("a="+a+"b="+b+"的矩形" );; &#125;&#125; 12345678910package org.whgc;public class SShape &#123; public void draw() &#123; System.out.println("this is shape"); &#125;&#125; 1234567891011121314package org.whgc;public class Factory &#123; public static SShape getInstance(int id) &#123; SShape shape=null; if(id==1) shape=new Cricle(); if(id==2) shape=new Rectangle(); return shape; &#125;&#125;]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day2]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day2%2F</url>
    <content type="text"><![CDATA[大致内容 java 基础:运算符 循环语句等-&gt;注意&amp;&amp;与&amp;的区别（遇x则停和不停） 注意不同类型赋值的精度问题：结合位数记-&gt;byte 1 short 2 int 4 double 8 float 要加f 方法封装代码注意事项：exchange方法-&gt;注意局部变量 细讲ifloop loop 循环的讲解 细讲 关联 与 依赖 的区别：依赖需要对象传入 关联是属性或方法有联系：比如A类方法有B类的属性 细讲static continue break 内存模型图（Student s=new Student(30,40)）的执行内部细节 类和对象 ：分析和创建类，public 类 构造函数 private 属性 以及 方法名 书写规范 寄居蟹方法：不会对类造成影响，可以随便移动。eg:math里面的部分运算方法 static可以有局部变量，静态变量 不能有成员变量：成员变量在对象创建之前， 什么时候用static-&gt;eg:寄居蟹方法/模拟数据库 this 的两种用法：无参构造函数调用有参构造函数，this.age=age赋值 重点：内存模型图：了解程序运行数据在 静态方法区 栈区 堆区 的 存储情况 （方法都是压栈） 已程序为例 main(){Student s=new Student(10,30,40);} 1.main()方法入栈 碰到Student在硬盘当前目录找到Student 类并加载到 静态方法区 同时在堆区第一次初始化 2.静态方法区(目前有类的基本信息）碰到构造函数-&gt;压栈-&gt;取到参数-&gt;对堆中的属性赋值（第二次初始化） 然后方法弹出 3.最后在栈区保存一个s对象指向堆区的数据 static在创建对象（new）时，就运行啦。（题外话） 类基本属性：变量 构造函数 方法关于this的两种用法 有无参构造函数调用有参构造函数1234567891011class demo&#123; int a; int b; demo()&#123; this(100,100) &#125; demo(int a,int b)&#123; this.a=a; this.b=b; &#125; &#125; static ：占啦生命周期的1/3 里面运行寄居蟹方法最为合适 static块不能有new之后才产生的变量 eg:r 将变量 方法定义为static 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class StaticDemo&#123; private int r; public static double pi=3.1415926; public static String ip;// 什么样的方法前面可以加static static&#123; // 读取配置文件 ip="10.142.14.4"; System.out.println("class is loading...."); //r=20; &#125; public StaticDemo(int r)&#123; this.r=r; //this.pi=pi; &#125; public int getR()&#123; return r; &#125; public static double add(int a,int b)&#123; return a+b+pi; &#125; public static int ad(int a,int b)&#123; return a+b; &#125; public static void main(String args[])&#123; //int a; System.out.println(StaticDemo.pi); //StaticDemo s=new StaticDemo(10); //s.pi++; // StaticDemo s1=new StaticDemo(20); //System.out.println(s1.pi); &#125;&#125; 关于for循环的练习：乘法口诀表123456789101112131415161718192021222324252627282930313233343536public class DaoShanJiao &#123; public static void main(String args[]) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + "*" + i + "=" + j * i + "\t"); &#125; System.out.println(); &#125; System.out.println(); for(int i=1;i&lt;10;i++)&#123; for(int k=1;k&lt;i;k++)&#123; System.out.print("\t"); &#125; for(int j=i;j&lt;10;j++)&#123; System.out.print(i+"*"+j+"="+i*j+"\t"); &#125; System.out.println(); &#125; &#125;&#125;``` ![](http://oyj1fkfcr.bkt.clouddn.com/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_20180704212418.png) ### 关于递归的练习 ：斐波拉西数列```javaint[] a=new int[20]; a[0]=1; for(int i=0;i&lt;a.length-2;i++)&#123; a[i+2]=a[i+1]+a[i]; &#125; for(int i=0;i&lt;a.length;i++)&#123; System.out.print(a[i]+" "); &#125; 25匹马选3 一次赛5个（不可测速度，只能测快慢）-&gt;7次 1，分5组 5次 得到5个第一-&gt;再测-&gt;淘汰最后两组 2.存在top1所在的组的第二名&gt;top2 存在top2所在的组的第二名&gt;top3 3.再测一次，决定2,3名 一个不错的例子：数组类构造函数与内部类构造函数的执行先后顺序12345678910111213141516171819202122232425262728293031323334353637class Book&#123; public Book(String msg) &#123; System.out.println(msg); &#125;&#125;public class Person &#123; Book book1 = new Book("book1成员变量初始化"); static Book book2 = new Book("static成员book2成员变量初始化"); public Person(String msg) &#123; System.out.println(msg); &#125; Book book3 = new Book("book3成员变量初始化"); static Book book4 = new Book("static成员book4成员变量初始化"); public static void funStatic() &#123; System.out.println("static修饰的funStatic方法"); &#125; public static void main(String[] args) &#123; Person.funStatic(); System.out.println("****************"); Person p1 = new Person("p1初始化"); &#125; /**Output * static成员book2成员变量初始化 * static成员book4成员变量初始化 * static修饰的funStatic方法 * *************** * book1成员变量初始化 * book3成员变量初始化 * p1初始化 *///~&#125;]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训java_day1]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADjava_day1%2F</url>
    <content type="text"><![CDATA[大致内容 发展方向 java环境搭建 java基础（容易忽视的） .java-&gt;.class-&gt;运行 发展方向 cs模式 bs模式客户端技术：html、css javascript : java设计模式-jQuery（侧重元素）vue.js(侧重数据) 移动端：android+java xml json ios object-c服务器端技术：web服务 邮件服务 组建服务 jsp/servlet -（mvc）struct1.x struct2.x jsf 数据库支持技术： hibernate（冬眠：持久层）ibates 以依赖注入技术：Spring （反射层） 数据库：oracle mysql SqlServer （对表的创建 分页统计数据库的编程 存储过程 触发器 游标） 具体实例 Demo.java 12345678910111213141516171819202122232425262728293031//java程序都是1个或者N个class组成的//程序都有一个入口函数// 程序调用的规律：遵循栈的调用顺序//一个JAVA文件 里面可以有 N个非public class//只能有一个和文件名一样的public class//一个类对应一个文件class Demo1&#123; public static void method()&#123; System.out.println("this is method1"); &#125; public static void main(String args[])&#123; method(); System.out.println("this is my first java"); &#125;&#125;class Demo2&#123; public static void main(String args[])&#123; System.out.println("this is my second java"); &#125;&#125; Demo4.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Demo4&#123; public static void main(String args[])&#123; // 静态的语言 //整型 byte short int long byte month=1; int a=10; //多位的数据 是不能保存到 低位的变量里 //month=a; //两个short类型相乘不是short 而是int // 浮点型 float double float pi=3.14f; double pi1=3.1415926; // char char c='c'; char d='陈'; int n=(int)d; char k='\''; boolean flag=true; boolean flag1=false;//&amp;&amp; ||boolean up=false;boolean left=false;boolean right=false;boolean down =false;if(up&amp;&amp;!left&amp;&amp;!right&amp;&amp;!down) System.out.println("up");if(up&amp;&amp;left&amp;&amp;!right&amp;&amp;!down) System.out.println("up");if(up&amp;&amp;left&amp;&amp;right&amp;&amp;!down) System.out.println("up");if(up&amp;&amp;left&amp;&amp;right&amp;&amp;down) System.out.println("up");if(!up&amp;&amp;!left&amp;&amp;!right&amp;&amp;!down) System.out.println("up");if(!up&amp;&amp;!left&amp;&amp;!right&amp;&amp;down) System.out.println("up");if(!up&amp;&amp;!left&amp;&amp;right&amp;&amp;down) System.out.println("up");if(!up&amp;&amp;left&amp;&amp;right&amp;&amp;down) System.out.println("up");//游戏中8个方向的控制 System.out.println(n); &#125;&#125; 练习 ：输入一个整数 输出 2的次幂 的表示 思路：转换成二进制 再判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.Arrays;//把十进制转换为二进制的位public class ToBinBit&#123; public static void main(String[] args) &#123; //1.假设现在有一个int为20，需要转换为二进制输出 int number = 20; //2.需要一个长度为32的int数组来存储结果二进制 int[] bit = new int[32]; //3.循环，把原始数除以2取得余数，这个余数就是二进制数，原始的数等于商。 //商如果不能再除以二，结束循环。 int sum=0; for(int i = 0; number &gt; 1; i++) &#123; //取得除以2的余数 int b = number % 2; //数字赋值为除以2的商 number = number / 2; bit[i] = b; if( number &lt; 2 ) &#123; //已经不能再把数除以2，就把上直接放到数组的下一位 bit[i + 1] = number; &#125; &#125; //4.翻转数组 for(int i = 0; i &lt; bit.length / 2;i++) &#123; int temp = bit[i]; //第一个数的值设置为最后一个数的值 //第二次的时候，i是1，把第二个数的值，赋值为倒数第二个 bit[i] = bit[ bit.length - 1 - i ]; bit[ bit.lenimport java.util.Arrays;//把十进制转换为二进制的位public class ToBinBit&#123; public static void main(String[] args) &#123; //1.假设现在有一个int为20，需要转换为二进制输出 int number = 20; //2.需要一个长度为32的int数组来存储结果二进制 int[] bit = new int[32]; //3.循环，把原始数除以2取得余数，这个余数就是二进制数，原始的数等于商。 //商如果不能再除以二，结束循环。 for(int i = 0; number &gt; 1; i++) &#123; //取得除以2的余数 int b = number % 2; //数字赋值为除以2的商 number = number / 2; bit[i] = b; if( number &lt; 2 ) &#123; //已经不能再把数除以2，就把上直接放到数组的下一位 bit[i + 1] = number; &#125; &#125; //4.翻转数组 for(int i = 0; i &lt; bit.length / 2;i++) &#123; int temp = bit[i]; //第一个数的值设置为最后一个数的值 //第二次的时候，i是1，把第二个数的值，赋值为倒数第二个 bit[i] = bit[ bit.length - 1 - i ]; bit[ bit.length - 1 - i ] = temp; &#125; System.out.println( Arrays.toString(bit) ); //判断 &#125;&#125;gth - 1 - i ] = temp; &#125; System.out.println( Arrays.toString(bit) ); for(int i=0;i&lt;bit.length;i++)&#123; if(bit[i]==1)&#123; System.out.print(32-i); &#125; &#125; System.out.println(sum); &#125;&#125;]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无锡实训python.md]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%97%A0%E9%94%A1%E5%AE%9E%E8%AE%ADpython%2F</url>
    <content type="text"><![CDATA[这是根据python班同学发我的资料写的笔记，学过廖雪峰的python教程，感觉这些文件没啥东西，不过还是挑一些东西学一下1.python运行过程 没有什么.class文件 2.raw.input()获取键盘输入123# -*- coding:utf-8 -*-password=raw_input("请输入密码")print '密码是',password 3.input() 必须输入表达式123# -*- coding:utf-8 -*-sum=input("请输入表达式")print '密码是',sum 4.大小驼峰命名法：叫得很吊，其实就是单词首个字母大不大写的问题，垃圾 LaJi-&gt;大驼峰 laJi-&gt;小驼峰5.下标12345name="asdfghjk"print (name[0])print (name[1])print (name[2])print (name[2]) 6.python_while循环-乘法口诀表12345678i = 1while i &lt;= 9: j = 1 while j &lt;= i: print("%d*%d=%-2d " % (j, i, i * j)) j += 1 print() i += 1 7.python_for循环-乘法口诀表123456for i in range(1,9): for j in range(1,9): print("%d*%d=%d"%(j,i,i*j)) j+=1 print() i+=1 8.python对文件的操作 写数据/读数据(read) 12345678910111213# -*- coding:utf-8 -*-f = open('test.txt', 'w')f.write('hello world, i am here!')f.close()f = open('test.txt', 'r')content = f.read(5)#单位字节print(content)# /usr/bin/python2.7 /home/fangjun/PycharmProjects/untitled/text.py# hello## Process finished with exit code 0 获取当前读写的位置 f.tell() 练习：复制文件123456789101112131415161718oldFileName = input("请输入要拷贝的文件名字:")oldFile = open(oldFileName, 'r')# 如果打开文件if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind('.') if fileFlagNum &gt; 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + '-副本' + fileFlag # 创建新文件 newFile = open(newFileName, 'w') # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) # 关闭文件 oldFile.close() newFile.close()]]></content>
      <categories>
        <category>无锡实训python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql数据库存取图片的几种方式]]></title>
    <url>%2F2018%2F07%2F01%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%8F%96%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[二进制存取 确认可行的教程 blod 二进制格式 存储图片 imageUtil 提供 图片 二进制 数据转换方法 springboot 数据存储显示 （ssm 也做过 但配置文件实在记不住 springboot 配置文件少 一目了然 真正意义上的自己写出来的） 图片路径存取把图片存在项目中 how2j springboot上传文件]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[diy显示器]]></title>
    <url>%2F2018%2F06%2F14%2Fdiy%E6%98%BE%E7%A4%BA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[显示器=面板+对应驱动板。。。。 购买裸屏（推荐lg 4k 屏） 找对应驱动板（把型号一发，卖家自动帮你刷好） 接线 垃圾三星屏做波试验]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot 学习]]></title>
    <url>%2F2018%2F06%2F10%2Fspringboot%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 springboot 本质是maven项目 第一次生成springboot 耗时 15分钟 遇到问题 没找到jdk（由于目录名改啦） 重新指定 rebuilt 运行java类 成功 截图 （找到项目工程目录）生成jar 报错 无法将“mvn”项识别为 cmdlet。。。 未解决 配置maven环境变量 教程\ 截图 mvn install 成功生成jar 截图 运行jar java -jar target/springboot-0.0.1-SNAPSHOT.jar （在target里面） 截图 启动失败 端口8080被占用 截图 成功 通过这种方式，把此jar上传到服务器并运行，就可达到部署的效果了。 皮 springboot 使用 jsp 自动调试 power save model 代码不会自动提示、 运行报错 （配置文件问题） 控制台没报错 (idea没有自动生成webapp 怀疑是这个问题) 截图 隔一天 再运行 成功 截图、 热部署 控制台 运行springboot时 修改 hellocontrol 控制台自动更新 （只需在pom.xml 配置一下） eclipse创建springboot项目 安装插件 Spring Tool Suite 联外网耗时20分钟 file- new maven project导入 file- import- maven project- run Application.java thymeleaf: 与jsp不同-thymeleaf 不需要 服务端的支持，就能够被以 html 的方式打开 CURD+thymeleaf -]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro安全框架学习]]></title>
    <url>%2F2018%2F06%2F10%2Fshiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6-%20%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[完整教程how2j备忘1.权限系统设计基础RBAC : Role-Based Access Control，基于角色的访问控制/Resource-Based Access Control，基于资源的访问控制2.表的设计 基于 ORAC 概念， 就会存在3 张基础表： 用户，角色，权限， 以及 2 张中间表来建立 用户与角色的多对多关系，角色与权限的多对多关系12345678910111213141516171819202122232425262728293031323334353637383940DROP DATABASE IF EXISTS shiro;CREATE DATABASE shiro DEFAULT CHARACTER SET utf8;USE shiro;drop table if exists user;drop table if exists role;drop table if exists permission;drop table if exists user_role;drop table if exists role_permission;create table user ( id bigint auto_increment, name varchar(100), password varchar(100), constraint pk_users primary key(id)) charset=utf8 ENGINE=InnoDB;create table role ( id bigint auto_increment, name varchar(100), constraint pk_roles primary key(id)) charset=utf8 ENGINE=InnoDB;create table permission ( id bigint auto_increment, name varchar(100), constraint pk_permissions primary key(id)) charset=utf8 ENGINE=InnoDB;create table user_role ( uid bigint, rid bigint, constraint pk_users_roles primary key(uid, rid)) charset=utf8 ENGINE=InnoDB;create table role_permission ( rid bigint, pid bigint, constraint pk_roles_permissions primary key(rid, pid)) charset=utf8 ENGINE=InnoDB; 实操1.md5加密 123变成202CB962AC59075B964B07152D234B701String encodePassword=new Md5Hash(password).oString(); 2.加盐后= 多次md5（password+随机数（盐））123变成。。。。。。。。。。。。12345String password = "123";String salt = new SecureRandomNumberGenerator().nextBytes().toString();//生成随机数int times = 2;String algorithmName = "md5";String encodedPassword = new SimpleHash(algorithmName,password,salt,times).toString();//算法名 密码 盐 运算次数 3.简单的登录验证 建表 用户 角色 权限 角色-权限 用户-角色 DAO列出用户 列出该用户所有角色 列出该用户所用权限 得到外界输入的用户名 密码 传入Realm 验证并授权 Realm通过配置文件定位 方法类 该方法类通过dao操作 在权限表 insert添加数据 权限名 （数据库用户授权表面上不同） 4.验证登录+盐 idea导入eclipse项目 若导入后 发现源文件目录没有。回到工程目录通过生成的pom.xml导入项目就行 在用户表添加属性 alter table user add (salt varchar(100) ) 我们肯定是对 注册填入的密码加盐，将加盐后的密码存入usr表属性password中，看运算的结果是否相等。 这样一来，数据没有明文密码。提高啦安全性。 5.网页端6.权限管理一套]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea 搭建ssm框架 vs springboot框架]]></title>
    <url>%2F2018%2F05%2F22%2Fidea%20%E6%90%AD%E5%BB%BAssm%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[完整教程 最终结果 备忘 idea报错 GBK 不知为何， 自己新建maven项目 搭建ssm总是报错 目的是搞起天猫整站 目的达到就行 jdk 与 tomcat 不兼容 jdk 与 maven 版本不匹配 gbk 编码格式错误 （我从成功的项目文件一个个复制，可以运行成功 但web页面报错 3天啦 在搞就浪费时间啦） spring 无法注入某个类 。。。。 还有由此衍生无数新错误，为了有学下去的信心，直奔目的，建站。ssm框架先用现成的 springboot 简单100倍好不好。。。最终结果 思路图 直接dao注解方式 间接dao注解方式 配置文件详解1 application.properties123456spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jspspring.datasource.url=jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=adminspring.datasource.driver-class-name=com.mysql.jdbc.Driver 配置文件详解2 pom.xml12345678910111213141516171819202122232425262728293031323334353637&lt;project 一堆规范&gt; 项目基本信息 &lt;groupId&gt;com.how2java&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot&lt;/name&gt; &lt;description&gt;springboot&lt;/description&gt; &lt;packaging&gt;war&lt;/packaging&gt; 项目唯一标识 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; 依赖集合 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; ... ... &lt;/dependencies&gt; 项目构建 不太懂 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 实操 新建springboot没有webapp 自己新建 然后指定改文件夹为web根目录 教程]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm项目学习_1]]></title>
    <url>%2F2018%2F05%2F22%2Ftmall_ssm%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0_1%2F</url>
    <content type="text"><![CDATA[3.7 第五个配置文件 springMVC.xml 1,3,4,5 都记不住 可以直接复制 1.解释在第一篇 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd"&gt; 2.指定controller 注解识别 applicationContext.xml指定啦service的注解识别 有所不同12345678&lt;context:annotation-config/&gt; &lt;context:component-scan base-package="com.how2java.tmall.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven /&gt; 3.开通静态资源的访问 &lt;mvc:default-servlet-handler /&gt; 视图定位1234567&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt; 对上传文件的解析 3.8 第六个配置文件 web.xml 1.第一篇有解释 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt; 2.spring的配置文件 和applicatinContext.xml 有联系contextConfigLocationclasspath:applicationContext.xmlorg.springframework.web.context.ContextLoaderListener 3.中文过滤器–&gt; 可以直接复制 CharacterEncodingFilter org.springframework.web.filter.CharacterEncodingFilter &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; CharacterEncodingFilter /* 4.spring mvc核心：分发servlet –&gt; mvc-dispatcher org.springframework.web.servlet.DispatcherServlet 5.spring mvc的配置文件 –&gt; 和自己连接 有点 &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; 1 mvc-dispatcher / 第七个配置文件 CategoryMapper.xml 规范之类的东西 直接复制 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; 2.namespace指明类 id 为什么是list resultType 返回类型是category对象？？？ 应该是与categoryMapperImpl.java 文件有关 12345&lt;mapper namespace="com.how2java.tmall.mapper.CategoryMapper"&gt; &lt;select id="list" resultType="Category"&gt; select * from category order by id desc &lt;/select&gt;&lt;/mapper&gt; 其他文件简单不说 阶段性截图 org.springframework.beans.factory.BeanCreationException 好像缺包 凌晨3点进度截图 tomcat 部署正常 网页404.。。。]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm项目学习]]></title>
    <url>%2F2018%2F05%2F21%2Ftmall_ssm%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘配置运行 坑1 tomcat的配置 用how2j提供的jdk （我用官网最新的报错） tmall_ssm 坑2 后台配置运行 jre路径改为jdk路径 tmall_ssm admin 前台配置运行 tmall_ssm forehome 8080端口占用 unable to ping server 1099 -&gt; jdk版本与tomacat所需jdk版本不一致 tomcat的配置错误姐姐方法 maven项目构建不成功，除以上问题还有各种各样的花式错误，这次我idea，jdk，tomcat全部下载安装最新版 并配置环境变量。demo一次成功 新建maven项目 无resource java文件夹解决方法 autowired 报错等级 解决方法 实操1.数据库设计： 一共9张表 一进后台 商品得分类分类表 如吃穿住行 然后看属性属性表 如颜色 价格 再看具体产品产品表 下单时 一类产品对应一个订单项订单项表 多个订单项组成订单订单表 属性值表（有点困惑 ，放在一起没问题啊） 有买卖就有哦名家评价表 产品图片表（有点困惑 应该属于产品信息一类，而产品详情是属性和属性值） 最后一个就是用用户表啦。。。 表之间的关系 （用来设置主键 外键 注意 多对多绝对能拆成多对一对多之类的，不要有多对多出现） 盗张图 表的属性项 通常建表的注意事项：id属性必有 id int(11) not null auto_increment / 初始属性值default null / 主键约束 primary key（id） 外键约束 constraint 约束名 foreign key（cid）reference 外键坐在的表 （id）/ 结尾设置字符格式 engine=innodb default charset=utf8;12345678910111213141516171819202122user categroy表对别的属性只有一对多create table user( id int(11) not null auto_increment, name varchar2(255) default null, password varchar2(255) default null, primary key (id) )engine=innodb default charset=utf8;create table category( id int(11) not nul auto_increment, name varchar2(225) default null, prinary key(id) )engine=innodb default charset=utf8;create table proprety( id int(11) not null auto_increment, cid int(11) default null, name varchar2(225) default null, constraint fuck_property_categroy foreign key(cid) reference category(id) ) engine=innodb default charset=utf8;以管窥豹。。。 2.导入数据库文件3.写后台 CURD +分页 数据渲染到界面显示基本原理3.1 遇到直接问题 那些配置文件 知道作用 但不知道整个怎么写 无法新建自己写配置文件 自己写的 报错搞死人3.2 慢慢来 第一个配置文件 log4j.properties 需要懂的基本点 log4j.rootLogger=ERROR, stdout //error 意思是低于error级别不log stdout 是输出到控制台 R则是滚动输出到文件 log4j.logger.com.how2java.tmall=TRACE // com.how2java是唯一标示名 不知道啥意思 结果是控制台每条信息 第一个就是trace 下面是控制台输出设置 log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n //文件格式 下面是文件基本信息如：文件名是example.log,文件最大100k, 最多滚动5个文件 输出设置 log4j.appender.R=org.apache.log4j.RollingFileAppender log4j.appender.R.File=example.log //文件在项目根目录文件夹下 log4j.appender.R.MaxFileSize=100KB log4j.appender.R.MaxBackupIndex=5 下面是文件输出设置 （与控制台大同小异） log4j.appender.R.layout=org.apache.log4j.PatternLayout log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n how2j的完整教程 自己学的时候写的 3.3 第二个配置文件 jdbc.properties jdbc 主要信息 肯定为了使用方便才这样搞 root //账号 admin //密码 jdbc.driver=com.mysql.jdbc.Driver //依赖包 jdbc.url=jdbc:mysql://localhost:3306/tmall_ssm?useUnicode=true&amp;characterEncoding=utf8 //记不住 tmall_ssm数据库名 3.4 第三个配置文件 applicationContext.xml 1.文件头123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; 1、xmlns=”http://www.springframework.org/schema/beans&quot;声明xml文件默认的命名空间，表示未使用其他命名空间的所有标签的默认命名空间。 2、xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot;声明XML Schema 实例，声明后就可以使用 schemaLocation 属性了 3、xmlns:aop=”http://www.springframework.org/schema/aop&quot;声明前缀为aop的命名空间，后面的URL用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。 4、xsi:schemaLocation=”http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd这个从命名可以看出个大概，指定Schema的位置这个属性必须结合命名空间使用。这个属性有两个值，第一个值表示需要使用的命名空间。第二个值表示供命名空间使用的 XML schema 的位置 2.启动注解识别 12&lt;context:annotation-config /&gt; &lt;context:component-scan base-package="com.how2java.tmall.service" /&gt; 3.导入数据库配置文件 1&lt;context:property——placeholder location="classpath:jdbc.properties"/&gt; 配置数据库连接池 //记不住+1123456789101112131415161718192021222324252627282930&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT 1&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt;&lt;/bean&gt; 5.Mybatis的SessionFactory配置 // 现在的目的是自己另外新建也能搞出来，想自己打配置文件现在不能 1234567891011121314151617&lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="typeAliasesPackage" value="com.how2java.tmall.pojo" /&gt; //包名换成自己的 &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt; &lt;!--分页插件，目前先注释，后面重构的时候才会使用 &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; --&gt;&lt;/bean&gt; 6. 123456 &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.how2java.tmall.mapper"/&gt; //包名换 &lt;/bean&gt;#### 3.5 第四个配置文件 pom.xml 配置相关jar包 自己看着改 &lt;groupId&gt;com.how2java.tmall&lt;/groupId&gt; &lt;artifactId&gt;tmall_ssm&lt;/artifactId&gt; `---]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用fluxion插件实现wifi钓鱼]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%94%A8fluxion%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0wifi%E9%92%93%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[完整教程备忘需要注意的是，教程中推荐的选项 没有成功 不推荐的反而成功啦。。。。。1.安装遇到compatty missing的错误 谷歌一下 自己安2.放图算啦 打字太麻烦]]></content>
  </entry>
  <entry>
    <title><![CDATA[deepin(linux) 翻墙教程]]></title>
    <url>%2F2018%2F05%2F10%2Flinux%20FQ%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[软件 windows android mac FQ 见v2ss。]]></content>
      <categories>
        <category>无锡实训java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日文学习]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%97%A5%E6%96%87%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[50音读 在线发音 unit 1、 おはようこさいます 早上好 いいえ 不是 はい 是、 がくぜい 学生 せんせい 老师 おたし 我 あなた 你 そうらこそ 是这样]]></content>
  </entry>
  <entry>
    <title><![CDATA[intellij junit 测试练习]]></title>
    <url>%2F2018%2F03%2F29%2Fintellij%20%20%20junit%20%E6%B5%8B%E8%AF%95%E8%81%94%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[intellij junit 测试练习 步骤和eclipse 一样 配置 运行设置注意一下]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse junit 测试练习]]></title>
    <url>%2F2018%2F03%2F29%2Feclipse%20junit%20test%20%2F</url>
    <content type="text"><![CDATA[eclipse junit 测试练习 简单测试 （一个方法 一个测试用例） 写一个类定义add sub div 。。。 直接写测试类 @before 双击 import junit 就行 （官网最新eclipse可行） 截图 多个测试用例 一个方法 (参数化测试) 套装测试]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4500装机指南]]></title>
    <url>%2F2018%2F03%2F29%2F4500%E8%A3%85%E6%9C%BA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[我的配置单机箱 甲壳虫 99 显卡 影驰 战将1050Ti 1499 主板 影驰b50 459 cpu i5-7500 1399 内存 影驰ddr4 8g 678 固态 （机械随意） 金泰克 240g 441 电源 巡洋舰 112 花费 4687 =99+1499+459+1399+678+441+112 （网上报价 ）实际花费 4420 （维修店老板在电脑城帮我买的配件并帮我装的）显示器 dell u2417H 1500 皮一下 总结：别去网上买配件，去电脑城买，但别在电脑城找别人装机，水很深。有事找老板，老板人挺好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[酷欧天气app 实操]]></title>
    <url>%2F2018%2F03%2F29%2F%E9%85%B7%E6%AC%A7%E5%A4%A9%E6%B0%94app%20%E5%8A%A8%E6%89%8B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[显示省市县列表 显示天气信息 引入必应背景图 实现自动更新]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word list 13]]></title>
    <url>%2F2018%2F03%2F27%2FWORD%20LIST13%2F</url>
    <content type="text"><![CDATA[WORD LIST13 sub- subdue v 征服 im impulse 推动 a- 无 abolish vibr- 摇摆 vibrate 颤动 ac- 酸的 acid 酸 van 空 vanish 消逝 -ward 向 backward 向后的 capt 抓 capture 俘虏 in- 进 inflate 使充气 al- 加强 allege v 断言 sol 单独的 ioslate v 孤立 press oppress v 压迫 voc 声音 advocate v 拥护 page 242 harry v 烦扰 diffuse v 扩散 page 243 subdue v 征服 kidnap v 诱拐 grease n 脂肪 bestow v 把。。赠与 impulse n 推动 accident n 意外 simplify v 简化 page 244 patriot n 爱国者 disorder n 杂乱 confine v 监禁 mislead v 引入歧途 page 245 allege v 断言 disregard v 不理会 notify v 告知 indicate v 指出 restore v 重建 page 246 damn adj 咒骂 adj 该死的 petition n 请愿书 thesis n 学位论文 discord n （意见）不和 profit n 利润 holy n 神圣的东西 deplete v 大量消耗 page 247 uodo v 解开 vacant adj 空的 abolish n 废除 smear v 涂抹 engage v 吸引 page 248 sink n 污水池 isolate v 远离 blast n 喇叭声 policy n 政策 startle v 使吃惊 vibrate v 使颤动 page 249 cruel adj 残忍的 acid n 酸的 sway v 摇摆 oppress v 压迫 loss n 失败 亏损 disclaim v 否认 scan v 审视 vanish v 突然消失 disappear page 250 envisage v 想象 common adj 普通的 buckle v 让步 blend v 混合 furnish v 供应 backward adj 向后的 possess v 拥有 page 251 capture v 捕获 focus n /v 焦点 consientious adj 本着良心的 conscious 尽责 recognizable adj 可识别的 page 252 insult v 凌辱 link n 联系 menace v 威胁 arid 爱打架干燥的 economy adj 经济的 remind v 提醒 transplant v 移植 page 253 facinate v 迷住 perpetual adj 永远的 disposal v 清除 crisis n 危机 转折点 compensate v 补偿 page 254 reproach v 前者 elevate v 提高 creed n 教条 considerate adj 关切的 swing v 使 摆动的 page 255 mistaken adj 错误的 absolve v 免除 disable v 残疾的 disconcert v 使张皇失措的 bridle v 控制 约束 slide v 滑行 experience n 经验 page 256 threat n 恐吓 sue v 控告 occupy v 占用 fractional adj 微不足道的 damp adj 潮湿的 page 257 deficient adj有缺陷的 advocate v 拥护 boycott v 抵制 mourn v 哀悼 habitual adj 通常的 page 258 subsidize v 资助 inflate v 使充气 suspect v 猜想 flap v 拍打 behalf v 代表 利益 page 259 label n 标签 addiction n 上瘾的 survey v 调查 trick n 诡计 bland v 无刺激的 和蔼的 subtract v 减去]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 12]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list12%2F</url>
    <content type="text"><![CDATA[WORD LIST12 orig 开始 de- 减少 trans 越过 -able 。。。的 dis 分离 tri- 三倍 celer 速度 sym 共同的 init 开始 arti 技巧 merg submerge 沉没 page 223 household n 家庭 adj 家庭的 pendent adj 下垂的 withhold v不给 retain keep page 224 repel v 驱逐 fatal adj 致命的 crash v 碰撞 portray v 描绘 veto n 否决权 interpret v 解释 page 225 calmour n 吵闹 cunning adj 狡猾的 piece v 刺穿 rebuke v 谴责 lunber n 木材 v 缓慢而笨拙的移动 aboriginal adj 土生的 express v 表达 page 226 bubble n 水泡 deficit n 亏损 comply v 同意 obey transparent adj 透明的 grace n 优美 page 227 annul v 宣告 furious adj 狂怒的 leak n 漏洞 thrive v 兴盛 sensitive adj 敏感的 considerable adj 值得考虑的 expend v 扩展 page 228 default n 违约 n （电脑的）预设 displace v 替代 nevertheless conj 然而 disinterested adj 无私的 triple adj 三倍的 treat v 对待 page 229 infinite adj 无限的 neglect v 忽视 chill v/n 寒冷 accelerate v 加速 bound n 边界 v 跳回 page 230 steer v 驾驶 definite adj 清楚地 noticeable adj 显而易见的 mess 脏乱的 optimal adj 适宜的 enable v 使能够 page 231 vaccinate v 注射疫苗 consent v 同意 classic adj n 经典 adj 一流的 regime n 政权 confuse v 拒绝 page 232 grateful adj 感激的 rank n 排 presumably adj 假定的 dodge v 躲开 decline v 衰退 page 233 fleece n 羊毛 weep v 流泪 suppose v 假定 推测 support 支持 sympathize n 同情 page 234 mount n 山峰 aloof adj 冷淡的 initiate v 开始实施 provisional adj 暂时的 artificial adj 人造的 advise v 劝告 page 235 bind v 捆绑 coarse adj 粗糙的 skim v 滑过 skip 跳过 reveal v 展现 underneath adv 在什么下面 beneath page 236 request v 请求 complacency n 自满的 dweller n 居民 barren adj 贫穷的 不孕的 fatigue n 疲劳 attitude n 态度 blessed adj 神圣的 page 237 galaxy n 星系 submerge v 沉入 advance v 前进 junior n 年幼者 drowsy adj 半睡半醒的 oblige v 逼迫 page 238 inert adj 无活动能力的 ceremony n 仪式 astonish v 使吃惊 stride v 大步行走 stiff adj 僵硬的 page 239 constant adj 鉴定的 refute v 反驳 persuade v 说服 convice ford n 浅滩 anxious adj 忧虑的 page 240 await v 等待 exterior adj 外部的 complian v 抱怨 irritate v 激怒 precise adj 精确的 page 241 abound v 大量存在 explosion n 爆炸]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 15]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list15%2F</url>
    <content type="text"><![CDATA[WORD LIST15 veng 惩罚 avenge 复仇 un- 解开 unveil 除去。。面纱 lect 选择 selection n 选择 trin 拿住 sustain v 承受 culti cultivate v 栽培 hal 呼吸 exhale 呼出 auct 提高 auction拍卖 radic 根 radical adj 根本的 be- bewilder v 迷惑 spect 看 inspect v 检查 grep 群 congregate v 集合 du- duplicate adj 完全一样的 lapse 滑到 collapse 崩溃 equ 平等 equal adj 相等的 page 279 avenge v 复仇 unveil v 除去。。面纱 promising adj 有希望的 page 280 dazzle v 耀眼的 crafty adj 狡猾的 exhilarate v 使高兴 enact v 制定 hollow adj 空心的 clasp v 扣住 selection n 选择 page 281 delicacy adj 精致的 reform v 改造 charter n 宪章 sustain v 支撑 amend v 修改 brood v 同窝幼鸟 v 孵化 page 282 swerve v 突然转向 diplomacy n 外交 smudge n 污点 uncover v 移去 opaque adj 不透明的 incompetent adj 不称职的 surmount v 克服 superstition n 迷信 page 283 collide v 猛撞 distribute v 分配 enthusiastic adj 热情的 grip n 紧握 page 284 essence n 本质 cultivate v 耕作 tan v 晒黑 痛打 auction v 提高 content adj 满足 page 285 radical adj 根本的 reinforce v 加强 ponder v 仔细考虑 沉思 thereby adv 因此 restain v 克制 page 286 barbaric adj 残暴的 input staff n 输入信息 全体工作人员 knock v 敲门 quality n 质量 bewilder v 迷惑 page 287 warrant v 授权 length inspect v 检查 angular adj 尖锐的 kindle v 点燃 adore v 羡慕 submit v 服从 page 288 privacy v 独处 lick n 少量 congregate v 集合 attack v 攻击 detach v 拆卸 efficient adj 有效率的 page 289 interim adj 暂时的 specify v 具体指定 exhale v 呼出 duplicate adj 完全一样 distinguish v 区分 page 290 expel v 驱逐 amiss adv adj 错误的 allow scare toss v 投 cast page 291 depart v 启程 strive v 抗争 flourish v/n 茂盛 litter auxiliary adj 辅助的 clumsy adj 笨拙的 page 292 consolidate v 巩固 distil v 蒸馏 locate glimmer v 珊珊发光 partial adj 部分的 reject v 拒绝 page 293 correspond v 符合 equal adj 相等的 collapse v 崩溃 page 294 transform v 改变 crush v 压碎 revenue n 税务局 收入总额 event frosty adj 霜冻的 deliver v 投递 page 295 somehow adj 以某种方法 annex v 添加 unconditional adj 无条件的 hamper v 阻碍 navigate v 航行 page 296 demolish v 拆毁 noble adj 高尚的 feeble adj 虚弱的 deny v 否认 haunt n 常去之处 assignment n 任务 分配]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 18]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list%2018%2F</url>
    <content type="text"><![CDATA[WORD LIST18 -ize 使。。化 idealize 将。。理想化 optim 最好的 optimistic adj 乐观的 starct 拉 abstract 提取 stict 拉紧 restrict 限定 sat 足够 saturate v 使 饱和 nov 新 innovate 革新 vert 反转 invert tort 扭 retort 反驳 dox 观点 paradox adj 自相矛盾的 sist 站 insist 坚持 vict 征服 liev 变轻 relieve 释放 sert 插入 assert 宣称 ert 能量 exert v 运用 pend 悬挂 suspend v 悬挂 page 334 yamn v 打哈切 ensure page 335 idealize v 使 理想化 valid adj 正确的 scrub v 用力擦洗 disqualify v 使不能 bother page 336 harsh adj 刺耳的 optimistic adj 乐观的 disgust n/v 是讨厌 intercept v 中途拦截 effusive adj 过分热情 abstract adj 抽象的 restrict v 限制 page 337 bollow v 吼叫 regular n 规则 sovereign adj 至高无上的 saturate v 浸透 sweep v 打扫 retort v 反驳 page 338 specialize v 专攻 ；mischief n 恶作剧 paralyze v 使麻痹 accord v 符合 transit n 通过 indifferent adj 不感兴趣的 page 339 stick n 小树枝 foundation n 创立 somewhat adv 有点 associate v 联系 page 340 enroll v 登记 claim v 要求 actual adj 实际的 gleam n 微光 calm adj 镇静 paradox n 自相矛盾的事物 enlighten v 启发 page 341 grumble v 发牢骚 interior adj 内部的 cucious adj luxury n 奢侈 affix v 使 固定 upset v 不适 搅乱 endow v 授予 summarize n 摘要 page 342 recollect v 回忆 omit v 省略 unplug v 拔出 modify v 变更 exhibit v 展出 page 343 poverty n 贫困 insist v 坚持 coinclude v 同时发生 finance n 资金 v 提供资金 page 344 convict v 证明 expense n 花费 exist gamble v 赌博 page 345 relieve v 减轻 despair v /n绝望 overhear v 无意中听到 absent adj 缺席的 page 346 butt v 以头顶撞 assert v 宣称 discard v 丢掉 innovate v 革新 strip v 夺去 page 347 bargain v exert v 运用 invert apparent adj 明显的 courteous adj 有礼貌的 shame page 348 brilliant adj 光辉的 shorten v 变短 affirm v 坚称 wander originate v 发源 page 349 limit n 界限 badly adv 恶劣的 regulate v 管理 lay v 放 subscribe v 捐赠 page 350 remain v 停留 bloom v 开花 promoye v 提升 suspend v 悬挂 page 351 scotch v 粉碎 consequent adv 结果 insight n 洞察力 boast v 自夸 夸 witness n /v目击证人 目击 consistent adj 一致的 page 352 design n 设计 monitor n 显示屏 circumstance n 情况 despite perp 不管 catalog n 、v 目录 分类 satirize v 讽刺 community n 社区]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 17]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list%2020%2F</url>
    <content type="text"><![CDATA[WORD LIST17 view 看 review rupt 断 tach 钉子 attach 缚 gress 行走 aggressive 有侵略性的 term 界限 determine 确定 cert 搞清 certain adj 确信 com- 共同 comprise 包括 card 心心脏 her hes 粘附 adhere 粘附 ident 相同 identity n 想听 -ize 使 capitalize v 投资于 mulit- 多 multiple 多重的 ment 头脑 mental adj 思想的 proxim 接近 approximate adj 大约的 bi- 双 bilateral 双边的 tact tang contact 接触 page 371 interval n 间隔 review leisure n 空闲 page 372 abrupt 突然的 scrape v 擦伤 bleak adj 荒凉的 delinquent adj 犯法的 discharge v 发射 开除 page 373 reason penetrate v 刺入 superb adj 上乘的 attach v 缚 integrity adj 完整的 page 374 emotional grunt v 发哼声 表不满 amaze v 使 惊叹 steamline v 使 精简 prospect n 前途 景色 page 375 struggle exhaust v 用完 effect n 效果 page 376 compete v 竞争 insert 插入 aggressive adj 有侵略性的 stretch v 伸展 page 377 nominate v 提名 任命 apt adj 恰当 standpoint n 立场 handicap n 不利因素 inconsistent adj 不和谐的 determine v 下决心 page 378 affect v 影响 soat v 高飞 certain sketch n v 速写 素描 tortuous adj 弯弯曲曲的 page 379 switch pose comprise mind frustrate v 挫败 使灰心 takeover arrogant adj 傲慢无礼的 page 380 advance cardinal adj 主要的 grab v 抓取 murmur n 沙沙声 page 381 naive adj 幼稚的 dignify v 使 有尊严 query v 质问 accumulate v 积累 affection n 爱 影响 page 382 creep v 爬行 adhere v 粘附 fuss n 大惊小怪 frown v 皱眉 identify n 身份 page 383 haggard adj 憔悴的 capitalize v 大写字母写的 投资于 considering prep 就什么二轮 mask retain v 保留 gossip v 闲聊 prolong v 拖延 page 384 multiple n 倍数 adj 多重的 mental adj 心智的 ineffective adj 无效果的 positive adj 确定的 extreme adj 末端 page 385 patent n 专利 integrate v 使完整 approximate adj 大约的 bilateral adj 双方的 expend gentle convenient apge 386 resort v n 凭借 dilute v 稀释 indignant adj 愤愤不平的 gruff adj 粗鲁的 diverge v 分叉 outrage n 暴行 page 387 impenetrable adj 不能通过的 exquisite adj 精美的 upbringing v 养育 subtle adj 微妙的 absolute adj 绝对的 contact adj 相反的 page 388 pile 堆积 heap 堆 suspicious adj 怀疑的 array n 排列 frenzy n 狂暴的 compel v 强迫 frighten v 使惊恐 page 389 unreasonable instinct n 本能 tramp n 流浪汉 keen adj 激烈的 锋利的 敏感的 structure n 结构]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 19]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list%2019%2F</url>
    <content type="text"><![CDATA[WORD LIST19 merg 沉 merge 并入 quer 寻求 conquer 征服 liter 文字illiterate 文盲 momo- 单个 monotonous adj 单调的 vey 道路 convey 运输 duct 引导 conduct 引导 empt 获得 exempt 被赦免的 dol 悲伤 condolence n 追悼 tempt 尝试 attempt posit v 放 deposit 放 norm 规则 enormous 巨大的 cis cid 切掉 concise 简洁的 ple 满 complet 完成 per- 至始至终 permanent 永久的 page 353 rehabilitate v 使恢复原状 merge v 合并 stare v 凝视 respect v 尊重 page 354 overrule v 驳回 overlap v 重叠 aftermath n 事件的余波 temper n 脾气 fanatic n 狂热者 add page 355 thrill n v 激动 conquer v 征服 divide v 分割 lovable adj 可爱的 heap n 堆 page 356 chaos n 混乱状态 condolence v 吊唁 persistence adj 坚持的 trust n v 信任 thwart v 阻扰 illiterate n 文盲 page 357 epidemic adj 流行的 grit n 砂砾 v 不畏困难 hemisphere n 半球 suck v 澄清 plausible adj 能说会道的 视乎正确的 faint adj 虚弱的 page 358 stroll n/v 漫步 wander torture v 拷问 monotonous adj 单调的 deserve adj 应受的 convey v 运送 sanction n v 批准 delay n v 耽搁 page 359 conduct n 行为 品行 v 引导 attend v 出席 absent 缺席 went n 通风孔 page 360 sprout v 发芽 hitch n 暂时的困难 institute n 协会 v 设定 制定 exempt adj 被赦免的 bright hesitate adj 】犹豫的 page 361 emit v 发出 vacate v 让出 credulous adj 轻信的 empirical adj 实践主义的 campaign n 有组织的活动 page 362 sample commune n 公社 v 交换思想 partition n v 分开 tickle v 使满足 attempt v 尝试 deposit v 放下 page 363 hug educate enormous adj 巨大的 trap n 陷入困境 concise adj 简洁的 dwell v 居住 page 364 distress v n 使 痛苦 revise v 修订 index characterize v 以。。为特征 commission n v 委托 page 365 detect satisfy assume v 假定 appalling adj 恐怖的 page 366 persist v 坚持 component v n 组成 prestige n 威望 proof n 证据 exceptional adj 异常的 page 367 knit v 编制 hieous adj 丑陋的 alien graphic adj 生动的 medium n 媒介 imitate v 模仿 page 368 deliemma n 进退两难 grin n v 露齿笑 herald n 先驱 v 宣布 pluck v 拔 ease n 舒适 complete page 369 permanent adj 永久的 via perp 通过 slippery adj 光滑de etemal adj 永恒的 routine n 常规 adj 例行的 鼓噪的 page 370 preside v 主持 batter v 打烂 depose v 罢免 sling v 投掷 lobby n 大堂 entitle v 定标题 draft n 草稿]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 17]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list%2017%2F</url>
    <content type="text"><![CDATA[WORD LIST17 vis 看 visual 视觉的 pict 画 depict 描会 counter 相反的 counterpart 相对应的 viv vig vit 生命 survive v 比。。长寿 liber 考虑 deliberate 谨慎的 spers 散开 disperse 疏散 -fold 。。重 manifold adj 多种的 nounc 说 denounce 指责 judic 判断 judicial 司法的 cur 跑 occur 发生 cord 心脏 cordial 热诚的 oxi oxy 含氧的 oxidize 使氧化 volv 卷 involve 涉及 hypo- 在下 hypocrisy 伪善 magin- 大 maginficent 宏伟的 page 316 emancipate v 解放 visual adj 视觉的 cheer v 鼓励 page 317 quest n 探求 hook n /v 钩住 confiscate v 没收 budget n 预算 consequence n 结果 page 318 dipict v 描述 sift v 过滤 rate n 比率 mock v 嘲笑 jam n 果酱 influence n 影响 counterpart n 相对应的 page 319 survive v 幸存 deliberate adj 故意的 gain v 获得 recess n 工间休息 denounce v 指责 page 320 judicial adj 司法的 persecute v 迫害 legal adj 合法的 occur v 发生 出现 interface v 干涉 page 321 condial adj 热情的 charity n 慈善事业 diversify adj 多样化 desolate adj 孤独凄凉的 page 322 control v list obvious adj 明显的 oxidize v 使氧化 involve hypocrisy n 伪善 page 323 amenable adj 顺从的 bless v 祝福 swift adj 快捷的 supply v 供给 backwards adv 向后走 page 324 fell v 寄到 feel feedback n 反馈 supplement n /v 增补 spy n 间谍 according magnificent adj 富丽堂皇的 sever v 切断 service 服务 page 325 cease n 结束 bruise n （碰撞 切割）伤痕 青肿 flame n 火焰 apart adv 相隔 swathe v 把什么裹在 flash v 闪光 page 326 reluctant adj 勉强的 reconcile v 和解 sence n 感觉 shock decode disperse v 分散 page 327 ample adj 足够的 manifold adj 多种的 erect adj 直立的 adventure n 冒险 sniff v 嗅 beware v 小心 page 328 clutch v 紧抓 scribble v 乱写 offend v 冒犯 dreary adj 令人沮丧的 imperative adj 急需的 page 329 quality v 使合适 tumble v 滚动 melt v 融化 allot v 分配 exagerate v 夸张 page 330 sterile adj 不能生殖 demonstrative adj 易流露感情的 preoccupation n 全神贯注 preach v 讲道 brain n 脑子 converse adj 相反的 page 331 prescribe v 命令 lip n 唇 conscious adj 有意识的 supreme adj 最高的 obstruct v 阻碍 outbreak v 爆发 perform v 表演 page 332 impractical adj 不现实的 solicit v 设法获得 hinge n 转折点 calculate compose v 组成 irresistible adj 不可坑距的 page 333 prominent adj 著名的 nourish v 滋养 fulfil v 完成]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 16]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list%2016%2F</url>
    <content type="text"><![CDATA[WORD LIST16 tox 毒 toxic adj 有毒的 contra- 相反的 contrary adj 相反的 ploy 用 deploy 施展 fund 基础 fundamental 基础的 ad- 相反 abuse adj 相反的 hum 的，人 humble 谦卑的 faes feasible 可行的 fect fit 做 oper 工作 cooperate 合作 vert 转 divert 转向 corpor 团体 incorporate 并入 pos impose 把。。强加于 melan 黑色 melancholy 忧郁的 crit 判断 criterion 标准 ceiv 拿住 perceive 察觉 page 297 toxic adj 有毒的 illigible adj 难以辨认的 contrary adj 相反的 page 298 lest conj 以免 testify v 作证 deplore v 哀叹 resume v 重新开始 deploy v 部署 competence n 能力 page 299 emphasize v 强调 fundamental adj 基础的 analyze v 分析 engulf v 吞没 neutral adj 中立的 page 300 coordinate v 调节 reflect v 反射 undertake v 着手 承担 charitable adj 慈善的 brief adj 简明的 page 301 commit v 提交 abuse v 辱骂 splinter n 碎片 afford v 有足够时间做某事 inevitable adj 不可避免 quota n 定量 operate v 操作 page 302 sock v 浸泡 commence v 开始 expert n 专家 divert v 改道 incorporate v 合并 page 303 indict v 控告 eclipse n 日食 slacken v 放松 impose v 征税 whip v 鞭子 hustle n 忙绿 facilitate v 促进 page 304 unload v 卸下 melancholy adj 忧郁的 spontaneous adj 自发的 essential adj 必不可少的 spot n 斑点 page 305 criterion n 标准 cynical adj 愤世嫉俗的 regardless adj 忽视的 digest v 消化 lame adj 残废的 chief adj 主要的 page 306 slap v 捆 pratical adj 实际的 humble adj 谦卑的 memorize v 记住 dispatch v 发送 affordable adj 买得起的 prevent v 阻止 page 307 adjacent adj 临近的 appload v 喝彩 stimulate v 激励 alienate v 使疏远 feasible adj 可行的 page 308 perceive v 察觉 durable adj 持久的 futile adj 徒劳的 assure v 保证 appeal n 感染力 v 吸引 page 309 conspicuous adj 显著的 prompt adj 果断的 civil adj 城市的 apologize v 道歉 page 310 lauge n 笑声 diminish v 减少 mourfor adj 令人伤心 ratio n 比率 episode n 插曲 apge 311 humiliate v 羞辱 categorize n 分类 relate v 叙述 immense adj 广大的 justify v 证明 amplify v 详述 page 312 reverse v 反转 scold v 斥责 destine v 注定 conceive v 摄设想 page 313 lift n 电梯 prosecute v 对。。起诉 immediate adj 立即的 cope v 对付 weave v 编织 preliminary adj 预备的 interdependent adj 相互依赖的 page 314 render v 致使 glisten v 闪耀 flatte v 奉承 challenging adj 激发干劲的 dispose v 排列 page 315 cooperate v 合作 lunatic n 疯子 carve v 切]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 14]]></title>
    <url>%2F2018%2F03%2F27%2Fword%20list14%2F</url>
    <content type="text"><![CDATA[WORD LIST14 radi- 光线 radiate 发光的 migr 迁移 migrate 移居外国 dict dic 说 dictate 口述 gen 产生 engender 造成 rupt 破的 disrupt 破坏 leg 法律 legitimate v 使合法 flect v 弯曲 pil 堆 compile v 汇编 in- 进入 inward 再内的 tens 伸展 intensify v 加强 vis 看 subvice 监督 clus exclus v 排除 ordin 顺序 sobuordinate adj 下级的 sum 取 consume 消费 page 260 climax n 顶点 lean v 倾斜 harmony n 和谐 aware v 知晓的 page 261 drain v 把。。弄干 radiate adj 发光的 emigrate v 移居国外 gasp v 喘气 hoist v 提升 page 262 dictate v 口述 support v 支持 fabulous adj 寓言的 encounetr v 偶遇 page 263 engender v 造成 match v 匹配 fault n 缺点 topple v 倒下 discontent adj 不满 expose v 揭露 disrupt v 破坏 page 264 selective adj 选择性的 unite v 统一 flare v 闪光 last v 持续 legitimate v 使合法 page 265 inward adj 里面的 kneel v 跪下 choke v 使 窒息 leap v 跳跃 starve adj 使 饿 stumble v 蹒跚而行 page 266 consume v 消耗 abandon v 抛弃 lodge n 小屋 lounge n 休息室 intersify v 加强 supervise v 监督 page 267 conclude v 推断 tangle v 乱作一团 grand adj 壮大的 economical adj 节俭的 economy 经济 page 268 compress v 压紧 persevere adj 坚持不懈的 ingenious adj 心灵手巧的 limp adj 柔软的 sceptical adj 多疑的 grim adj 严肃的 establish v 建立 page 269 exclusion n 排除在外 giggle v 傻笑 appoint v 任命 undersirable adj 令人不开的 inadequate adj 不充分的 complie v 编辑 page 270 charismatic adj 有号召力的 complement adj 补充物 bear v 承担 depress v 使消沉 page 271 forecast v 预测 custody n 监护权 kid n 小孩 cast v 投 扔 subordinate adj 下级的 burst v 爆裂 page 272 compulsory adj 强迫的 evaporate v 蒸发 cater v 供应伙食 impeach v 弹劾 doom v 注定 n 命运 厄运 覆灭 page 273 attract v 引起注意 avoid v 避免 innocent adj 清白的 delight v 喜欢 n 乐趣 page 274 grope v 暗中探索 awe v 敬畏 doclie adj 驯服 master n 主人 apply v 申请 fluctuate v 波动 page 275 sneak v 潜行 betray v 背叛 infer v 推断 feat n 功绩 manifest v 表明 refine v 净化 page 276 replace v 代替 target n 目标 economize v 节省 mechanism n 机械装置 haggle v 争论 讨价还价 apge 277 inventory n 目录 清单 dubious adj 怀疑的 flaw n 缺点 fault chronological adj 按年代顺序排列的 eloquent adj 雄辩的 conscience n 良心 apge 278 refreach v 使 神清气爽 eccentric adj 古怪的 pageage v 打包 application n 应用]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android&how2j的学习方法]]></title>
    <url>%2F2018%2F03%2F19%2FAndroid%20%26how2j%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学一个东西，不断踩坑，总结避坑经验 problem1：配置文件直接pass掉 换新项目无非换工程明]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器学习]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[阿里云服务器购买配置教程 变更系统 用SecureCRT连接云服务器 成功截图 常用命令 (:wq 保存退出 ：q! 直接退出 ctrl c 返回命令行) vi 使用 （vi 文件名 输入a/i进入编辑模式 编辑 按下esc退出编辑模式 输入：进入命令模式 wq 保存退出） ftp就是用来我们把本地的文件传输到服务器上，或者从服务器上下载文件用的。 lunix安装java超简单 教程 lunix安装mysql 教程 linux安装tomcat 教程 linux安装python 教程 vim那步不管 服务器GUI非how2j教程 好像可以直接远程]]></content>
  </entry>
  <entry>
    <title><![CDATA[后台-查询[tmall ssm idea]]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%90%8E%E5%8F%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 后台查询大致思路 实操 配置文件根本记不住 复制粘贴就行 然后把配置文件的项目名 group id 唯一标识符arifict 等 换成自己的 build success 才算没问题。 命名最好先安站长的套路来 不然很被动]]></content>
      <categories>
        <category>tmall ssm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word list 8]]></title>
    <url>%2F2018%2F03%2F13%2FWordlist8%2F</url>
    <content type="text"><![CDATA[词根 pen 惩罚 crimin 罪行 mit 送 valu 价值 tim 害怕 don 给予 -al 。。的 plic 重叠 gener gen 丰富的 neg 否认 page 146 shadowy adj 多阴影的 split v 裂开 sp li t sp 离 t -&gt;离开-&gt;裂开 overlook v 远眺 bankrupt v 破产 bank rupt -》银行 rupt -》破产 page 147 penalty v 惩罚 -》喷 那 你提 -》朝着你提东西的方向吐口水 baptize v 给。。洗礼 -》爸不踢子 -》踢子是一种洗礼方式 ambiguity n 模棱两可 -》按b guity——》按b还是不安-》模棱两可 snicker v 窃笑 s ni cker -&gt;是尼克在窃笑 discriminate v 区别的 -》把犯罪和未犯罪的区别开来 transmit v 传播 -》进过长远的路途mit you -》传播爱情的种子 page 148 convention v 代表大会 习惯 con ven tion -》come 温 tion -》来到温暖的大会堂-》代表大会 evaluate v 评估 eva lu ate -》爱娃 驴 ate -》爱娃使驴 -》评估这头驴的性能 fade v 褪色 fate 命运 frugal adj 节俭的 f ru gal-》few god -》很少的上帝是节俭的 remark v 讨论 re mark -》重新标记这个点，并讨论 page 149 provoke v 激怒 -》pro voke -》铺入work -》增加工作-》激怒 squeeze v 挤压 squee ze -》是筷子-》筷子夹 -》挤压 intimate v 透露 in ti mate -&gt;in 踢 美特——》在里面踢美特-》因为美特泄露啦机密 surrender v 投降 surren der -》surround 环绕 -》环绕投降 spur v 激励 s pu r -》是 怕儿-》怕儿子不争气-》激励 loaf v 闲逛 loa f -》落福-》闲逛被福砸中啦 page 150 transfer v 移动 -》trans fer -》trans 发儿-》让发哥移动 shrink v 收缩 shine 闪耀 sh rin k-》 fashion 时尚 blessing v 祈祷 poke v 刺 泼 克-》泼 以克服-&gt;泼 草 你就当成刺 page 151 donate v 捐赠 -》当 内特-》当内部的特务-》捐赠情报 phase n 阶段 -》p ha se -》泼孩 死-》泼向孩子 死的阶段 clinical adj 诊所的 c lin ni cal-》克林你call -》克林打电话给悟空-》说17号在医院 allocate v 分配 allo cate -》a lot cate-》很多蛋糕等待被分配 follow page 152 implicate v 牵涉其中 im pli cate-》因泼梨cate-》泼梨蛋糕-》泼梨牵涉到蛋糕中 present lap n 膝部 来普-》普京来啦-》俄罗斯士兵屈膝敬礼 sacred adj 神圣的 sa cred -&gt;是create-》创造是神圣的、 bitter adj 有苦味的 -》比 她儿-》谈别人的孩子，自己的孩子有苦味 surpass page 153 diligent adj 勤勉的 di li gent -》D梨 gent -》 D梨agent 很勤勉-》D梨特工很勤勉 squander adj 浪费 s quan der -&gt;死 宽 的儿 -》死宽的儿是个败家子-》浪费 summon v 召唤 sum mon -&gt; 召唤神兽监控数字 rely v 信任 re ly real -》真实 信任 narrate v 叙述 na rrate -》那 rate -》那种比率叙述着要崩盘啦 page 154 redeem v 赎回 re deem -&gt;re deem -》重新认为那东西很重要-》赎回 pledge n 誓言 -》ple dge -》铺雷 鸡 -》铺雷鸡发誓守卫中国 block n 块 react v 反应-》re act -》重新 动作-》应激反应 achieve v 成功 obedient adj 顺从的 -》o be di ent-》o 逼的ent-》o、逼的结束-&gt;过程很顺从 page 155 kick v 踢 -》ki 克-》kike device v 计划 发明 -》de vice -》的 围死 -》计划将的士围死 rage n 圣怒-》ra ge -》ra 鸡-》公鸡愤怒的叫着 ascend v 登高 -》as cend -》as sent -》登高作为发送信号以求救 raid n 袭击 -&gt;rai d -》red -》袭击流血事件 红色警报 page 156、 fling v 投 f ling -&gt;敷鳞-》给鱼敷上鳞片 投放回海里 blank suffocate v 使窒息而死 suffo cate -》输佛 cate -》输佛一块蛋糕-》老板窒息而死 outline n 轮廓 margin n 边缘 mingle v 使混合 min gle -》名 gril -》 混血 女明星 dose v 给什么服药 -》do se -》打死 再给他服药 unfold v 打开 -》un fold -》fold 覆盖 page 157 defiant adj 违抗 -》defi ant -》的 非 end -》非法的士违抗交警指示永无止境 wink v 眨眼 -》 awkward adj 笨拙的 aw k ward-》 explore v 开拓 argue v 辩论 ar gue lease n 租赁 leave -》租赁 离开 page 158、 proceed v 前进 -.pro ceed-&gt;success -》continue catastrophe n 大灾祸 -》 devil n 恶魔-&gt;evil 邪恶的 track n 小径 page 159 invaluable adj 无价的 -》in valu able generous adj 通常的 -&gt;ge ne rous fertile adj 肥沃的 fer tile -》佛 tired -》肥沃的土地 佛吃累啦 malice n 恶意 -》妈 离 死-》恶意诅咒 妈 离开 死亡 reckon v 计算 -.rec kon-》record 记录 -》reckon -》re 啃-》重复的啃那个计算方法 page 160 superior adj 优良的 -》su pe rior-》苏 皮 肉哦-》优良的苏皮肉 negative adj 消极的-》ne ga tive vulnerable adj 敏感的-》vul ne ra ble-》窝 那 ra 吧-》对周围环境变化很铭感 窝在哪里叫 capability n 能力-》capa bility-》开 泼 bility-》只看bility underline n 下划线 page 161 tariff n 关税 -&gt;ta riff -》他 越 富 -》他考收关税变得越来越富 revenge v 复仇 -》re ven ge flavor n 味道 -》flower-》花朵的味道 tease v 取笑 -》tea 死-》泡个茶都泡死啦-》取笑 vaporize v 使气化 -》va po rize -》娃 泼 睿智-》娃泼睿智硫酸 -》使睿智气化 变成白痴 plot n 情节 plot-》铺 lot -》这个情节铺垫太多啦 beat v 敲打 打败 page 162 correct adj 正确的 co rrect-》create correct-》 withdraw v 回收 drow 拉-》 dwindle v 逐渐减少 -》d win 的儿-》使用win 旧版的人逐渐减少 gone with the wind、 page 163、 clash v 发生冲撞 -》c lash -》c 拉稀 -》拉稀 肚子的屎发生冲撞 gorgeous adj 异常漂亮的-.gor ge our -&gt; accustom v 使习惯 general adj 通常 -》gena ral soluble adj 可溶解的-》so lu ble -》solution -》金属能被解决-》溶解 page 164、 describe v 描述 des cri be overthrow v 推到 over throw priority n 首要任务-》prio rity -》泼儿 re 提 -》靠]]></content>
  </entry>
  <entry>
    <title><![CDATA[python 学习 1]]></title>
    <url>%2F2018%2F03%2F13%2Fpython%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[完整教程：廖雪峰 用cmd 进行pip安装 和 运行python]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android kali]]></title>
    <url>%2F2018%2F03%2F13%2Fandroid%20kali%2F</url>
    <content type="text"><![CDATA[基本步骤 root 解锁 驱动 手机usb确认 usb的MTP模式 传输文件 刷入第三方recovery 安装nethunter完整包 安装内核包 重启 遇到的问题 1.氢os刷入第三方recovery 卡在fastboot界面 （不论干啥recovery就是不出现） 问题原因：之前解锁后 刷入第三方recovery 又上锁啦 解决方法：线刷回cm12 成功出现原版recovery！！！！！没用 解决方法：刷coloros全量包 2.cm12 开机一直在logo界面 换cm 注意： 1.拔掉充电线 才能进入fastboot模式-]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[救砖]]></title>
    <url>%2F2018%2F03%2F13%2F%E4%B8%80%E5%8A%A0%E6%95%91%E7%A0%96%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[只能进入recovery 无法进入 fastboot 使用 adb sideload （文件夹已收藏）（刷时尽量不要做多余操作 程序可能崩溃 1.无法连接 重启电脑 重装驱动 插拔 ） 帖子给啦rom 别用自己的 能进入fastboot 直接暴力线刷]]></content>
  </entry>
  <entry>
    <title><![CDATA[tmall_ssm 后端学习]]></title>
    <url>%2F2018%2F03%2F13%2Ftmall_ssm%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 maven]]></content>
      <categories>
        <category>tmall_ssm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境搭建]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[python 环境配置 廖雪峰python教程 记住add to path （不用手动去系统变量配置） java 环境配置 自己总结的 现在path都不用手动配的吗？ 很强啊！ android 开发环境搭建 android中文官网教程- 正宗官网 （官网已内置sdk）- 中文官网软件有问题 别用- sdk 别放c盘- 官网的Android studio 不一定是正确的 吃过亏的- 教程的AS需要搭梯子才能下载(已证明有错) 去正宗官网下载(已证明没错)- 开始需要配名为JDK的环境变量 网上教程 （已证明是扯淡）- 找不到jdk的处理方法 （正宗官网教程）- 报错图片+解决方法+成功截图- 第一次下载组件成功 （付费稳定梯子 别用无线网要连网线 用正宗官网软件 =不报错 ）- 碰到小问题（sdk部分组件未安装），搭梯子下，已解决 ，搭建成功- 总结：有一个好的梯子很重要！！！- 真机调试 教程- 遇到问题：no target devic （确定是外国 官网的软件 确定 手机开启usb调试 并 running 时授权）- 无线调试未成功 不装逼。。hexo博客搭建 idea+maven ssm 开发环境搭建 坑1 2 maven 创建报错 用how2j给的jdk 切记。jre路径=jdk]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next+网易云音乐]]></title>
    <url>%2F2018%2F02%2F13%2Fnext%2B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[就放图 字就算。（遇到的坑：网易云版权问题）]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git学习]]></title>
    <url>%2F2018%2F02%2F03%2Fgit%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[当你在一台没有建立连接的电脑 git add . -&gt;git commit -m-&gt;git push时 git版本回溯 mkdir 文件 cd 文件 pwd git init git commit git log git status /git status 文件名 git diff /git diff 文件名 git reset –hard 序列号 git本地与github建立连接 完整教程 成功截图 git push 报错（出现这种情况的原因是因为git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。第一种解决方法是强推即利用强覆盖方式用你本地的代码替代git仓库内的内容git push -f）]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kali报错及解决方法]]></title>
    <url>%2F2018%2F02%2F03%2Fkali%E6%8A%A5%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下列签名无效 GPG错误 1apt-key adv --key hkp://keys.gnupg.net --recv-keys 7D8D0BF6 hash效验和不符 1一条命令搞定它：sudo rm /var/lib/apt/lists/* -vf 然后你就可以继续：sudo apt-get update了。]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kali搞事情]]></title>
    <url>%2F2018%2F02%2F03%2Fkali%E6%90%9E%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[kali 官方源 (什么中科大 阿里云的源 一直报错：无releace 无法安全使用该源 ) 1deb http://http.kali.org/kali kali-rolling main contrib non-free 中文输入法(谷歌拼音输入法可以 其他不知道什么问题 一直报错) 1apt-get install fcitx fcitx-pinyin fcitx-module-cloudpinyin fcitx-googlepinyin 不会用vim编辑器 用自带的文本编辑器操作 wifi钓鱼 wifite2插件网卡再学校 回学校再更新 写啦备忘。 wifi干扰 与esp8266教程效果一样 获取别人游览器的图片 或让目标的游览器显示你写的html (遇到的坑：下列签名错误 GPG错误/hash效验和不符)]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VM安装kali系统]]></title>
    <url>%2F2018%2F01%2F30%2FVM%E5%AE%89%E8%A3%85kali%2F</url>
    <content type="text"><![CDATA[下镜像 安装5次没成功 靠！！！ 总结下遇到的坑，网络镜像选是（应该选否）卡死啦 提示安装成功 登录界面都出来啦 一登录进去黑屏30多分钟没反应。网上找的原因：继续等还没启动/硬盘有问题/电脑太渣。。。。。 官方提供kali虚拟机镜像（无需安装 下载即可用VM打开用的那种 上面是那种下下来还要装才能用的那种） 官网 下载链接 过程截图 完结撒花 官方提供的kali虚拟机 坑得一批（源需要vpn才能访问） 推荐极客之眼团队官方kali虚拟机密码：63u9 （解压到c盘 其他盘解压失败） 用户名：root 密码：geekeyes]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2018%2F01%2F30%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[不用vim 用gedit文本编辑器】 vim编辑器操作 esc 四个模式（普通模式 插入模式 可视模式 命令行模式）切换 ：reg 查看缓存器的复制内容（复制粘贴真TM麻烦） %（复制内容前面的代号）再按p即可粘贴 100dd 普瑞模式全删除]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简易购物车]]></title>
    <url>%2F2018%2F01%2F30%2F%E7%AE%80%E6%98%93%E8%B4%AD%E7%89%A9%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 产品模块]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Adobe After Effects]]></title>
    <url>%2F2018%2F01%2F30%2FAdobe%20After%20Effects%2F</url>
    <content type="text"><![CDATA[如何使用AE模板做视频 AE下载地址 Adobe全套下载地址 AE模板网站1 AE基友c4d AE模板网站3 AE界面简介 AE模板导入后的各部分介绍 AE模板修改 渲染及导出格式选择 1.AE模板资源AE模板有收费的和免费的，其中免费做的最好的是newcger，其他收费网站参差不齐。AE的基友c4d(负责AE里面的模型处理)，所以c4d网站也是需要的。 2.AE界面简介 3.AE模板介绍导入模板后。。。。。接下来要做的：]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tmall_我的订单页面]]></title>
    <url>%2F2018%2F01%2F29%2F%E6%88%91%E7%9A%84%E8%AE%A2%E5%8D%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 标题部分 产品列表部分 交互]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>天猫前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_首页]]></title>
    <url>%2F2018%2F01%2F29%2Ftmall_%E9%A6%96%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 产品列表 导航与轮播 分类和推荐 交互1猫耳朵 交互2分类菜单]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>天猫前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_其他页面]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%85%B6%E4%BB%96%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 支付页面 支付成功页面 确认收货页面上 确认收货页面下 收货成功页面 评价页面上 评价页面下 登录页面 注册页面]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>天猫前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_产品页面]]></title>
    <url>%2F2018%2F01%2F29%2F%E4%BA%A7%E5%93%81%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 产品图片 基本信息 产品详情 累计评价 交互]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分类列表]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%88%86%E7%B1%BB%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 排序和价格 产品列表 交互]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tmall_结算页面]]></title>
    <url>%2F2018%2F01%2F29%2F%E7%BB%93%E7%AE%97%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 头部和收货地址 确认订单信息 交互]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>天猫前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmall_购物车页面]]></title>
    <url>%2F2018%2F01%2F29%2F%E8%B4%AD%E7%89%A9%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 结算按钮 订单项内容 交互]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Struts]]></title>
    <url>%2F2018%2F01%2F20%2FStruts%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 Struts：基于MVC的WEB框架 Hello struts 把Model的数据显示在视图JSP上 jsp提交product的name到action 然后action又跳转回showProduct.jsp把提交上来的name显示出来]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2018%2F01%2F20%2Fspring%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 IOC 反转控制 是Spring的基础，Inversion Of Control .简单说就是创建对象由以前的程序员自己new 构造方法来调用，变成了交由Spring创建对象 Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。 DI 依赖注入 Dependency Inject. 简单地说就是拿到的对象的属性，已经被注入好相关值了，直接使用即可。 Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。 spring给对象注入属性 spring给对象注入其他对象 spring给对象注入其他对象 注解方式 对Bean全部用注解表示 AOP 即 Aspect Oriented Program 面向切面编程 。 面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 核心业务，比如登陆，增加数据，删除数据都叫核心业务 周边功能，比如性能统计，日志，事务管理等等 周边功能在Spring的面向切面编程AOP思想里，即被定义为切面 面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发 ，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP。]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用esp8266黑掉别人的wifi]]></title>
    <url>%2F2018%2F01%2F19%2F%E7%94%A8esp8266%E9%BB%91%E6%8E%89%E5%88%AB%E4%BA%BA%E7%9A%84wifi%2F</url>
    <content type="text"><![CDATA[1.准备工作 esp8266开发板 脚本烧录工具 脚本 2.具体步骤 用usb将esp8266链接到电脑 正常情况下会显示如下： 配置中遇到问题：设备管理器无端口选项 解决方法： 烧录软件设置 3. 烧录完成后的使用（烧录后板子的灯不亮，刚开始以为没烧好。。。。。） 连接无线网pwned 密码为deauther 下载DeautherAPP 先scan查找再选择wifi进行攻击 选择攻击方式 beacon 生成多个wifi 游览器登陆192.168.4.1]]></content>
      <categories>
        <category>skills</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java 日期类Date]]></title>
    <url>%2F2018%2F01%2F13%2FJAVA%E7%9A%84%E6%97%A5%E6%9C%9F%E7%B1%BBDATE%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 时间原点：1970.1.1 8:00 Date对象 getTime() 得到一个long型的整数 这个整数代表 从1970.1.1 08:00:00:000 开始 每经历一毫秒，增加1 SimpleDateFormat 日期格式化类 日期转字符串 format 字符串转日期 parse 翻日历]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一本糊涂账]]></title>
    <url>%2F2018%2F01%2F13%2F%E4%B8%80%E6%9C%AC%E7%B3%8A%E6%B6%82%E8%B4%A6%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 ###学习目标 ###项目理解 ###1.表结构设计1.1配置信息表config表12345create table config&#123; id int, key_ varchar(225), value varchar(225) &#125;ENGINE=InnoDB DEFAULT CHARSET=UTF8; 1.2消费分类表category表1234create table category&#123; id int, name varchar(225) &#125;ENGINE=InnoDB DEFAULT CHARSET=UTF8' 1.3消费记录表record表123456789101112131415create table record&#123; id int, spend int, cid int, comment varchar(225), date Date &#125;ENGINE InnoDB DEFAULT CHARSET=UTF8;``` ###2.约束2.1 主键约束add config```sqlalter table category add constraint pk_category_id primary key (id);alter table record add constraint pk_record_id primary key (id);alter table config add constraint pk_config_id primary key (id); 2.2设置id自增长change id id int anto_increment123alter table category change id id int anto_increment;alter table record change id id int anto_increment;alter table config change id id int anto_increment; 2.3外键约束1alter table record add constranit fk_record_category foreign key(cid) reference category(id); 3.放在一起 create table config{ id int anto_increment, key_ varchar(225), value int, primary key(id) }DEFAULT CHARSET=UTF8; create table category{ id int anto_increment, name varchar(225), primary key(id) }DEFAULT CHARSET=UTF8; create table record{ id int anto_increment; spend int, cid int, comment varchar(225), date Date, primary key(id), constranit foreign key(cid) reference category(id) }DEFAULT CHARSET=UTF8; ###2.原型设计2.1粗陋的JFrame 2.2界面规划 2.3util类 居中面板类 centerPanel 3.界面上的工具类 GUIutil]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2018%2F01%2F13%2FJQuery%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 JQuery是一个javascript的框架，是对javascript的一种封装。 通过JQuery可以非常方便的操作html的元素 。 简单例子1 常用方法 取值 JQuery对象的val()方法 通过html() 获取元素内容,如果有子元素，保留标签 通过text() 获取元素内容,如果有子元素，不包含标签 json字符串转换成json对象123456789101112131415&lt;script src="http://how2j.cn/study/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;var s1 = "&#123;\"name\":\"盖伦\"";var s2 = ",\"hp\":616&#125;";var s3 = s1+s2;document.write("这是一个JSON格式的字符串:" + s3);document.write("&lt;br&gt;");var gareen = $.parseJSON(s3);document.write("这是一个JSON对象: " + gareen);&lt;/script&gt;]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON JavaScript 对象表示法]]></title>
    <url>%2F2018%2F01%2F13%2FJSON%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 JavaScript 对象表示法（JavaScript Object Notation） 是一种存储数据的方式。 创建JSON对象 1var gareen = &#123;"name":"盖伦","hp":616&#125;; 这样就创建了一个JSON 对象JSON对象由 名称/值对组成 名称和值之间用冒号:隔开名称必须用双引号” 包含起来值可以是任意javascript数据类型，字符串，布尔，数字 ，数组甚至是对象不同的名称/值对之间用 逗号 , 隔开 访问JSON对象 12document.write(gareen.name);document.write(gareen.hp); JSON数组 123456789var heros=[ &#123;"name":"盖伦","hp":616&#125;, &#123;"name":"提莫","hp":313&#125;, &#123;"name":"死哥","hp":432&#125;, &#123;"name":"火女","hp":389&#125;]document.write( "第4个英雄是:" + heros[3].name); SON对象与JavaScript对象:JavaScript对象 分内置对象(Number,String,Array,Date,Math)和自定义对象 JSON就是自定义对象，只不过是以JSON这样的数据组织方式表达出来 所以不存在JSON对象与JavaScript对象的转换问题 字符串转为JSON对象`jsvar s1 = “{\”name\”:\”盖伦\””;var s2 = “,\”hp\”:616}”;var s3 = s1+s2; document.write(“这是一个JSON格式的字符串:” + s3);document.write(““);var gareen = eval(“(“+s3+”)”); document.write(“这是一个JSON对象: “ + gareen);`]]></content>
      <categories>
        <category>how2j</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word list 5]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list5%2F</url>
    <content type="text"><![CDATA[WORD LIST5 memor 记忆 tern term 界限 plod 爆裂 liqu 液体 demn 伤害 host 敌人 sper 希望 turb 搅动 trans 交换 hibit 拿住 sembl 类似 e- 去除 quaint 知道 mal- 坏 page 88 worm n 虫 寄生虫 worm elegant adj 优雅的 e le gant legacy n 遗产 le ga cy trigger n 触发器 v 激发起 trid ger page 89 sober adj 未醉的 清醒的 严肃的 慎重的 range n 系列 距离 v 排列 安置 extinguish v 熄灭 award v 授予 a ward coward 胆小鬼 co ward reward slur v 诋毁 s lu r reward v/n 报答 page 90 click v 点击 咔哒声 substitute n 代理人 sub s ti tu te hint v 暗示 hin t memory n 记忆力 me mory page 91 assault v 殴打 强将 pound 连续猛击 derive v 追溯 衍生 de rive exchange v 交换 pour v 灌 倒 po ur external adj 外部的 ex ter nal page 92 explode n 爆炸 explore 探索 ex plo de flick n/v 轻打 fiction friction 摩擦 冲突 hush v/n 沉默 hu sh premise n 前提 基地 liquid n 液体 li qui d indispensable adj 绝对需要的 in dis pen sa ble page 93 ambition n 野心 am bi tion disguise n/v 伪装 pretent 假装 flutter v 振翅 摆动 n 紧张 兴奋 glut ter condemn v 谴责 定罪 con de mn page 94 controversial adj 引起争论的 con tro ver sial hostile adj 敌方的 hos tile halt v 中止 停止 barr hal t impact 阻止 bust n 半身雕塑像 bu st desperate adj 绝望的 des pe rate compact adj 紧密的 com pact impact 阻止 page 95 element n 要素 e le ment 自然环境 基础 luxurious adj 豪华的 lu xu rious hike v 远足 hi ke refer v 提及 谈到 re fer reference disinfect v 杀菌 infect 感染 page 96 destitute adj 贫困的 des ti tu te handy adj 便于使用的 hearty 健康的 drizzle n 下毛毛雨 driz zle sake n 缘故 fake 假货 wake 唤醒 hike 远足 sa ke 缘故 individual n 个体 adj 单独的 in di vi dual disturb v 打扰 dis turb perturb 干扰 turb 搅动 page 97 reserve v 保存 serve 保持 服务 service arouse v 唤醒 wake a rou se analysis v 分析 a naly sis substantial adj 牢固的 sub stan tial compassion n 同情 pathetic 怜悯 groan v/n 呻吟 g roan page 98 earnest adj 认真的 ear nest tuck v 塞入 tu ck fluff n 松软的绒毛 flu ff transaction n 业务 办理 trans 交换 ation outlaw n 歹徒 v 使。。非法 page 99 standard n 标准 stan drad prohibit v 禁止 inhibit 控制 hibit tain 拿住 assemble v 聚集 装配 as sem ble strength v 加强 strengh th receive v 接受 re cei ve page 100 everlasting adj 持续的 e ver la sting dissent v 不同意 dis sent splendor n 华丽 luxurious 豪华的 sp len dor underestimate v 低估 under esti mate enclose v 围住 disclose 揭发 en close dispense v 分配 dis pen se page 101 eliminate v 消除 e li mi nate believe v 相信 be lie ve harm v 伤害 daze v/n 茫然 da ze gaze 凝视 rough adj 表面粗糙的 rou gh obscure adj 模糊不清的 v 使模糊 obs cure page 102 eradicate v 根除 e ra di cate spite n 恶意 s pi te confidence assess v 评估 as sess page 103 frank adj 直白的 f rank acquaint v 使认识 ac qua int synthsize v 合成 synth size blink v 闪烁 twinkle sparkle 闪耀 maltreat v 虐待 malt reat trot v 疾走 t ro t hike 远足 page 104 imminent adj 临近的 im mi nent inverse adj 相反 whirl v 使旋转 spiral 螺旋 whi ri blind adj/n 瞎的 b lind worthy adj 值得的 wor thy waken v 唤醒 wake hound n 猎犬 纠缠 found 喜爱的 profound 深厚的 pound 连续猛击 assault 强奸 殴打 as saul maintain v 维修 main 手 tain 拿 page 105 elect v 选举 e le ct weight n 重量 wei ght execute v 执行 exe cute volunteer n 志愿者 vo lun teer page 106 dramatic adj 戏剧性的 dra ma tic astound v 使震惊 as tound conflict n/v 斗争 com fli ct detriment n 损害 spoil damage harm de tri ment digital adj 数字的 di gi tal]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 9]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list%209%2F</url>
    <content type="text"><![CDATA[WORD LIST2 词根（同时也是单词） chron 时间 not 标记 dom 房屋 arbitr 判断 re- 回 vit 生命 util 用 corpor 身体 bene- 善 好 toler 容忍 port 运 ann 年 Ven 来 physic 自然 page 165 yield v 给予 一儿的-》给予一儿吃的 -》给予 chronicle n 编年史 chro nicle -》掐 尼克-》编年史掐得尼克快疯啦-》编年史 gather v 聚集 page 166 denote v 指示 donate 捐赠 -》交警指示的士司机做笔记 drown v 溺死 bluff v 虚张声势 -》不撸罚-》不撸就要惩罚的法令是虚张声势 combat n 战斗 come to beat -》战斗 dominate v 支配 -》do mi nate-》打米 内特-》完全支配米国中的特务-》支配 page 167 basis n 基础 bas is、 domestic adj 家用的 -》打 么 是 题刻-》打 么么鱼的是家用的题目刻印-》家用的 arbitrary adj 随意的 -》ar bi trary-》儿 b tree-》儿子那个b 崽子随意变成啦一棵树 conducive adj 有助于 -》con du cive-》come do theif-》做贼有助于拉动内需 page 168 revolve v 使旋转 involve 涉及 volve 卷 recede v 后退 re 回 ced 走 statifactory adj 令人满意的 lessen v 使减少 adopt v 采用 a do pt -》a 打 铺-》采用一种打地铺的方式 inaugurate v 开创 in au gu rate-》aug 使产生 page 169 flock n 羊群 f lock -》f lock 羊群-》f 把羊群锁住啦 compromise v 妥协 com pro mise -》come promiss-》妥协 extravagant adj 浪费 extra 超过 vagant漫游-》浪费 bare adj 赤裸的 v 暴露-》ba re prevail v 战胜 pre vail -》prepare well -》准备充分 战无不胜 page 170 refrain v 抑制 -》re frain-》 compare v 比较 agony n 痛苦的 annoy glitter v 发光 g litter -&gt;鸡儿 litter 大小 闪闪发光 alert v 警告 alert弹窗 page 171 complicate v 复杂的 com pli cate investigate v 调查 in ves ti gate-&gt;in 我 死 踢 get-》在我拼死踢 获得成就后 被系统调查 vital adj 生命的 vi tal -》v 特二-》v字仇杀特二-》主角不是生命是master utilize v 利用 u ti lize-》util 利用 page 172 intense adj 强烈的 in tents 伸展e-》in 藤死]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[词根]]></title>
    <url>%2F2018%2F01%2F03%2F%E8%AF%8D%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[word list 1 crep 破裂 discrepancy n 差异 矛盾 / celebr 荣誉 celebrate v 庆祝 / sorb 吸收 absorb v 吸收 / cret 区别 discretion n 谨慎 / val 价值 value 价值 /manu 手 mani 手 manual adj 手工的/ inter 在什么之间 interact v 相互作用/ ethn 民族 ethic adj 民族的/ epic 史诗/ mot 动 motivate v 激发 触动/ ex- 出 extent // vinc 征服 convice 征服/ fore- 预先 foretell 预言 / flex 弯曲 flexible adj 易弯曲的/ fess 说 confess v 忏悔/word list 2 leas 松 release 释放 /dur 持续 duration n 持续 / mit 送 admit v 允许进入/ mand 命令 command 命令/ acu 尖 acute adj 尖锐的 / liber 自由 liberate adj 自由的 / frag 破碎 fragile adj 易碎的/ tract 拉 distract 使分心/ memor 记忆 commemorate v 纪念/ de- 去掉 deduct v 减去/ en- 使 enrich/word list 3 cit 引用 cite v 引用/ able 可使用的 / cess 行走 process n 进程 / contra- 相反 contradict n 矛盾/ mini 小的 /simil 相似 similar 相似的/ in- 不 insufficient adj 不充分的/ de- 否定 defy v 违抗 / vert 转 convert v 改变 / mens 测量 dimension n 长度/ cred 相信 credible adj 可信的 // tang 接触 tangible adj 可触知的 /word list 4 nutri- 滋养 mutrition n 滋养/ vid 看见 evident adj 明显的/ clin 弯曲 incline v 倾向/ n 斜坡 -ic 表人 mechanic n 机械师 / chron 时间 chronic adj 慢性的 / laps 滑 elapse v 消逝/ clud 关闭 exclude v 排除 / cruc 十字形 crucial adj 关键性的 / gen（u） 出生 genius /scend 爬 descend v 下降 / path 感情 phthetic adj 引起怜悯的 /grav 重 gravity n 重力/word list 5 memor 记忆 memory 记忆 / tern term 界限 extend adj 外部的 / plod 爆裂 explode v 爆炸/ liqu 液体 liquid adj 液体的/ demn 伤害 condemn v 定罪 / host 敌人 hostile adj 敌方的/ sper 希望 desperate adj 绝望的 / turb 搅动 disturb v 扰乱/ trans 交换 transaction n 办理/ hibit 拿住 prohibit v 禁止 / sembl 类似 assemble v 聚集 / e- 去除 eradicate v 根除/ quaint 知道 acquaint v 使认识/ mal- 坏 maltreat 虐待/word list 6 vis 看 visible adj 可见的 / cap 拿 capacity n 容量 vig 生命 vigour n 精力 Greg 群体 gregarious adj 群居的 rod 咬 erode v 腐蚀 an- 无 anonymous adj 无名的/ in- 进入 intrude v 侵入 sist 站 resist v 抵抗 /spect spic 看 spectacular adj 壮观的 /circ 环 circle n 园/ prehens 抓 comprehensive adj 理解的 / ed 吃 edible adj 可以吃的/word list 7 pel 推 dispel v 驱散 /mut 交换 mutual adj 相互的 / sens 感觉 sensible adj 感觉得到的 / -ate 做 designate v 指明 /spir 呼吸 inspare v 鼓励// glor 光荣、glorify v 赞美/ par 相等 separate v 分离/ volunt 意愿 volunteer 自愿者 / vad 走 invade v 入侵/ matern 母亲 maternal adj 母亲的/word list 8 pen 惩罚 penalty n 惩罚/ crimin 罪行 discriminate v 歧视/ mit 送 transmit v 播放/ valu 价值 evaluate v 评价/ tim 害怕 imtimate adj 亲密的/ don 给予 donate v 捐赠/ -al 。。的 clinical adj 诊所的 /plic 重叠 implicate v 涉嫌/ gener gen 丰富的 generous adj 丰富的 / neg 否认 negative adj 否认的 solu 松开 soluble adj 可溶的/word list 9 chron 时间 chronic n 编年史/ not 标记 denote v 指示/ dom 房屋 domestic adj 家庭的/ arbitr 判断 arbitrary adj 霸道的 / re- 回 recede v 后退 vit 生命 vital n 生命 util 用 utilize v 利用/ corpor 身体 corpor adj 身体的/ bene- 善 benefit n 利益/ toler 容忍 tolerate v 忍受 /port 运 transport / ann 年 annual adj 每年的 /Ven 来 intervece v 介入 /physic 自然 physical adj 自然的/word list 10 nomin 名称 nominal adj 名义上的/ ced ，ceed 走 precede v 先于 /viv 生命 vivid adj 有生气的 / cret 产生 concret adj 具体的 / cent 唱 inventive n 鼓励 / center 中心 concentrate v 集中精神/ lustr 照亮 光 illustrator v 说明 / her 粘附 inherent adj 固有 /cren 区别 discern v 看 识别/ prim 第一 primitive adj 原始的 / duc ，duct 引导 deduce v 推论 / tain 拿住 attain v 获得/word list 11 pre 预先 prejudice n 偏见 /stitut 建立 constitut v 建立 / monster 显示 demonster v 示范/ rer terr 恐吓 deterr v 威慑住 / sequ 跟随 subsquence adj 随后的 / -ify 使 magnify v 放大 / ex- exclaim v 呼喊/ over- 在。。之上 overtake v 超过 / para- 在。。旁边 paraphrase 释义/ suf- sup- 下 suppress v 镇压/ inter- 在。。之间 internal adj 内部的 /ante- 先 antecedent adj 先前的 / dis- 除去 disillusion v 使醒悟 / define v 确定word list 12 orig 开始 de- 减少 trans 越过 -able 。。。的 dis 分离 tri- 三倍 celer 速度 sym 共同的 init 开始 arti 技巧 merg submerge 沉没word list 13 sub- subdue v 征服/ im impulse 推动/ a- 无 abolish/ vibr- 摇摆 vibrate 颤动 /ac- 酸的 acid 酸/ van 空 vanish 消逝/ -ward 向 backward 向后的/ capt 抓 capture 俘虏/ in- 进 inflate 使充气 /al- 加强 allege v 断言/ sol 单独的 ioslate v 孤立/ press oppress v 压迫/ voc 声音 advocate v 拥护/word list 14 radi- 光线 radiate 发光的/ migr 迁移 migrate 移居外国/ dict dic 说 dictate 口述/ gen 产生 engender 造成/ rupt 破的 disrupt 破坏/ leg 法律 legitimate v 使合法 //flect v 弯曲/ pil 堆 compile v 汇编/ in- 进入 inward 再内的/ tens 伸展 intensify v 加强/ vis 看 subvice 监督 /clus exclus v 排除 /ordin 顺序 sobuordinate adj 下级的 /sum 取 consume 消费/word list 15 veng 惩罚 avenge 复仇/ un- 解开 unveil 除去。。面纱 / lect 选择 selection n 选择/ trin 拿住 sustain v 承受 / culti cultivate v 栽培/ hal 呼吸 exhale 呼出 / auct 提高 auction拍卖 radic 根 radical adj 根本的 / be- bewilder v 迷惑 / spect 看 inspect v 检查 / grep 群 congregate v 集合 / du- duplicate adj 完全一样的 / lapse 滑到 collapse 崩溃/ equ 平等 equal adj 相等的/word list 16 tox 毒 toxic adj 有毒的/ contra- 相反的 contrary adj 相反的/ ploy 用 deploy 施展 / fund 基础 fundamental 基础的/ ad- 相反 abuse adj 相反的 /hum 的，人 humble 谦卑的/ faes feasible 可行的 fect fit 做/ oper 工作 cooperate 合作/ vert 转 divert 转向 / corpor 团体 incorporate 并入 / pos impose 把。。强加于 / melan 黑色 melancholy 忧郁的 / crit 判断 criterion 标准 / ceiv 拿住 perceive 察觉/word list 17 vis 看 visual 视觉的 / pict 画 depict 描会 /counter 相反的 counterpart 相对应的 / viv vig vit 生命 / survive v 比。。长寿 / liber 考虑 deliberate 谨慎的 / spers 散开 disperse 疏散 / -fold 。。重 manifold adj 多种的 / nounc 说 denounce 指责/ judic 判断 judicial 司法的/ cur 跑 occur 发生 cord 心脏 cordial 热诚的 / oxi oxy 含氧的 oxidize 使氧化/ volv 卷 involve 涉及 / hypo- 在下 hypocrisy 伪善 / magin- 大 maginficent 宏伟的/word list 18 -ize 使。。化 idealize 将。。理想化 / optim 最好的 optimistic adj 乐观的/ starct 拉 abstract 提取 stict 拉紧 restrict 限定 sat 足够 saturate v 使 饱和/ nov 新 innovate 革新/ vert 反转 invert / tort 扭 retort 反驳/ dox 观点 paradox adj 自相矛盾的 / sist 站 insist 坚持 vict 征服/ liev 变轻 relieve 释放 / sert 插入 assert 宣称 / ert 能量 exert v 运用 pend 悬挂/ suspend v 悬挂/word list 19 merg 沉 merge 并入/ quer 寻求 conquer 征服 / liter 文字illiterate 文盲 / momo- 单个 monotonous adj 单调的 / vey 道路 convey 运输 / duct 引导 conduct 引导 / empt 获得 exempt 被赦免的/ dol 悲伤 condolence n 追悼 / tempt 尝试 attempt / posit v 放 deposit 放 / norm 规则 enormous 巨大的 /cis cid 切掉 concise 简洁的/ ple 满 complet 完成 / per- 至始至终 permanent 永久的/word list 20 view 看 review / rupt 断 / tach 钉子 attach 缚/gress 行走 aggressive 有侵略性的/ term 界限 determine 确定/ cert 搞清 certain adj 确信 / com- 共同 comprise 包括// card 心心脏 her hes 粘附 adhere 粘附 ident 相同 identity n 想听/ -ize 使 capitalize v 投资于/ mulit- 多 multiple 多重的/ ment 头脑 mental adj 思想的// proxim 接近 approximate adj 大约的 / bi- 双 bilateral 双边的/ tact tang contact 接触]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 1]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list%201%2F</url>
    <content type="text"><![CDATA[WORD LIST1 词根（同时也是单词） crep 破裂 celebr 荣誉 sorb 吸收 cret 区别 搞清 val 价值 manu 手 mani 手 inter 再什么之间 ethn 民族 mot 动 ex- 出 vinc 征服 fore- 预先 flex 弯曲 fess 说 page 9 discrepancy n 差异 不和 crep 破裂 discount v 怀疑 漠视 page 10 celebrate v 庆祝 celebr 荣耀 subject n 主题 v 使服从/遭受。。。 adj 隶属的 absorb v 吸收 be absorb in 专心于某事 absorbing adj 引人入胜的 absorbption n 专注 interchang v 交换 page 11 discretion n 谨慎 cret 搞清 dis cret ion charm v 迷住 n 魅力 enchant v 使被迷住的人喜欢 smuggle v 走私 m-&gt;tr struggle v 斗争 orient v 使适应 n 东方 adj 东方的 ori v 升起 hospitality n 好客 hospital n 医院 医院好客 page 12 inform v 通知 information n 信息 通知信息 cruise v 漫游 cruiser n 巡洋舰 c rui se concept n 概念 思想 genius n 天才 gen牛s 天才 跟牛死 linger v 逗留 徘徊 ling er 灵儿逗留 invalid n 残废 病人 adj 无效的 in va lid 歪理的 page 13 trail n 足迹 v 尾随 拖 植物蔓生 rear v 饲养 n 背面 real 真的 fake n 假货 adj fake 假冒的 mask 面具 marvel n 令人惊奇的事 v 惊奇 crude adj 天然的 n 原油 rude adj 狂野的（很大自然） 克鲁 神偷奶爸 hysteric adj 歇斯底里的 费尽全力的 page 14 interact v 相互作用 inter 相互 act 作用 ethnic adj 种族的 ethn 民族 hammer n 锤 v 敲打 up to hammer 一流的 harm v伤害 blaze n 光辉 v 燃烧 spoil v 损坏 宠坏 n 脏物 join n 连接点 page 15 provided conj 以什么为条件 Provided you have a gf ,you are the up to hammer in geek. waste adj 荒废 hearty adj 兴高采烈的 heart 表示心情 motivate v 促动 mot 动 heave v 举起 投掷 heaven 天堂 heavy 重 frail adj 脆弱的 frail n 脆弱 spoil v 宠坏 page 16 wipe v 擦 embarras v 使尴尬 embarrassment n 尴尬 em barr 阻挡 ass 傻瓜 阻挡你个傻X很尴尬 wake v 唤醒 n 航迹 守夜 sufficient adj 足够的 suf 下 fic 做 satisfied adj 满意 adequate adj 足够的（书面语） page 17 twist v 拧 n 转折点 twice 第二次 disclose v 显露 disclosu 揭发 公开 curb n 勒马的绳子 控制 v 装绳子 控制 cute 可爱 restrain v 控制 inhibit 控制 page 18 ventilate v 是通风 vent 风 ate 使 base n 基层 adj 卑鄙的 extent n 范围 广度 to some extent 某种程度上 initiative n 进取心 v 初始化 init 初始化 ative active 行动 blame v 责备xx n 责备 page 19 straight adj 笔直的 读音和拼写有半毛钱关系吗 靠 convince v 使确信 major adj 重要 adj 主要的 graduate v 毕业 n 毕业生 adj 毕啦业的 grad 级 ate 使 suspicion n 怀疑 spic 看 su spic ion page 20 logic n 逻辑 logical adj 逻辑性的 log log4j 说 foretell v 预言 fore 预先 fore see fore case predict 预言 notorious adj 臭名昭著的 hysteric adj 歇斯底里的 费尽全力的 strangle v 扼杀 prudent adj 谨慎的 discretion adj 谨慎的 commute v 减轻 改变（付款）的方式 mut 改变 com mut e page 21 sane adj 心智健全 san 健康 san e cancel v 取消 account n 账户 count 计数 ac count flexible adj 灵活的 flex 弯曲 ible 可 flex ible sigh v 叹息 n 叹息声 sign 风景 n 变h 风景不在 叹息 fantasy n 幻想 想象 fantastic adj 异想天开的/美妙的 fantas y tic page 22 offset n 分支 v 补偿 抵消 set off 抵消 dim adj （清晰度）暗淡的 obscure adj （想法）不清的 confess v 供认 忏悔 fess 说 log logic hover v 盘旋 （人）徘徊 page 23 feast n 宴会 feas 做 feas t twinkle v 闪耀 t win kle 一闪一闪亮晶晶 untie v 松绑 tie 绑 surge v 急剧上升 n 急剧上升的动作 sugar 糖 su gar surg 上升 surg e candy 糖果 skip v 轻快的跳 跳过 spark n 火星 diagnose v 诊断 dia 穿过 gno 知道 dia gno se page 24 fluent adj 流畅的 fluency n 流畅 glide v 滑行 slide n 滑动 glider n 滑翔机 cruiser n 巡洋舰 g s lide slip v 意外的滑动 approve v 支持 ap prov ve prov 好的 sanction n 批准 认可 san ction san 健康 sane 心智健全 measure v 测量 n 测量 page 25 absurd adj 不合理的 foolish silly ridiculous adj 不合理的 ab surd stab v 刺 n 刺痛 string n 细绳 字符串 predict v 预测 page 26 enquire v 调查 en 使 quir 寻求 en quire multiply v 使相乘 mulit 多 ply 重叠 muliti ply infect v 传染 in fect 做 quantity n 数量 quant 数量 ity quant ity unanimous adj 一致的 anim 生命 animal anim al 动物 un anim ous torment v 使痛苦 n 痛苦 tor 洋葱 tor ment page 27 venture v 冒险 n （有风险的）商业项目 ven ture contract n 契约 con 共同 tract 拉 interrupt v 打断 inter 在。。。之间 rupt 破裂 inter rupt bother distrub interfere 打扰 page 28 stoop v 俯身 屈服 s toop shallow adj 浅的 肤浅的 rid v 使摆脱 frequency adj 频繁的 fantasy adj 美妙的 enchant v 使入迷 en 使 chant 唱歌 comment n v 评论]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 3]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list3%2F</url>
    <content type="text"><![CDATA[WORD LIST3 词根（同时也是单词） cit 引用 able 可使用的 cess 行走 contra- 相反 mini 小的 simil 相似 in- 不 de- 否定 vert 转 mens 测量 cred 相信 tang 接触 page 49 manner n 想法 resourse 方法 solution 办法 swallow n 燕子 v 吞 swal low shallow 肤浅的 pave v 铺（路） pa ve cite v 引用 cit e page 50 recall v 忆起 n 回忆 create v 创造 cre ate cre 生产 productive 多产的 scream v 尖叫 s crea m shout cry sh rie k 尖叫 ruin n v 毁灭 ru in run i毁灭啦所以run page 51 peculiar adj 奇怪的 pe cu liar peculiarity n 特色 steal v 偷 s teal availble adj 可用 a vail ble vail 价值 process n 步骤 v 加工 progress 进展 kowtow v 磕头 kow tow disloyal adj 不忠诚 loyal lo yal glow v 发白热光 n 激情 兴高采烈 blaze v 发光 dread v 畏惧 d read d看恐怖小说 畏惧 page 52 bail n v 保释 保释金 bail 慈母多bail 所以要保释 sophisticate n 老于世故的人 使复杂 老司机 so phi sti cate accompany v 伴随 ac com pany contradict v 否定 反驳 contra dict page 53 besiege v 围攻 be siege siege 围攻 squat v 蹲坐 crouch c rou ch 蹲坐 s quat muffler v 抑制 muf fler mininum n 最低限度 install signify v 表明 sign 信号 ify savage adj 野蛮的 n 野人 sa va ge slave 奴隶 abridge v 缩短 a bright page 54 parcel v 打包 par cel idle v 虚度 adj 闲置的 i dle grant v 授予 g rant grudge v 妒忌 g ru age abridge a bri dge page 55 doctrine n 教条 doct 教 rine arise v 升 exile v 放逐 ex 出去 ile glimpse n 一瞥 隐约的闪现 g lim pse page 56 foresee v 预知 similar adj 相似的 doubt v 怀疑 suspicion 怀疑 doub t no doubt insufficient adj 不充分的 in suf fi cient page 57 defy v 违抗 de fy default 反抗 de fa ult struggle smuggle 走私 amuse v 逗。。乐 amusement n 兴趣 a mu se ment unlock repent v 悔悟 confess 忏悔 foregoing adj 前面的 levy v 征税 le vy de fy filth adj 肮脏的 fil th fil 线条 wreck n 失事的船只 v 摧毁 destroy des troy w re ck page 58 interject v 突然插入 inject 注射 chase v 追逐 cha se convert v 改变 con vert ornament n 装饰品 v 装饰 rescue v/n 解救 page 59 horrify v 使恐怖 horror ho rror ho rrify dimension n 尺寸 面积 di men sion mens 测量 measure dissident adj 持有异议的 alone combine v jiehe n 联合企业 page 60 anticipate v 预料 先于。。做 an ti ci pa te situate v 使位于 si tu ate envy v 妒忌 grudge 妒忌 levy 征税 unearth v 发掘 un earth credible adj 可信的 cre di ble cred 相信 tangible adj 真实的 tan gi ble page 61 thaw v 解冻 n 解冻期 locomotive n 火车头 v 移动的 lo co mo tive ；loco 地方 mot 移动的 prey n 猎物 p rey moderate v 减轻 和缓 mode rate dignity n 尊严 dig nity dign 有价值的 respond v 回答 page 62 jerk v/n 猛地摇晃 jer k disgrace n 丢脸 v 使丢脸 progress pro gress dis grace pro cess 步骤 classify v 把。。分类 class ify categorize cate go rize recognize re cog nize distinguish dis tin gui sh page 63 consecutive adj 连续的 con secu tive secut 跟随 mechanics n 力学 me cha nics significant adj 重要的 sign ifi cant disappoint adj 失望的 dis appoint antique adj 古代的 an ti que uproot v 将。。连根拔起 up root page 64 peril n 严重的危险 pe ril ill pe加强 encircle v 环绕 en cir cle cherish v 珍爱 che rish accommodate v 容纳 使适应 ac com mo date page 65 immaterial adj 不重要的 im ma te rial material 物质 format n 样式 for mat form 形式 allowance n 补贴 allow ance leave n 假期 sparkle v 闪闪发光 twinkle twin kle twice spark le 火星 发光 thereof adv 由此 page 67 pursue v 追捕 pur sue seek instruct v 教育 education in stru ct congestion v 阻塞 con ge s tion friction n 摩擦 冲突 fiction f ri ction fi ction 摩擦掉r变小说 crumble v 弄碎 spoil 损坏 宠坏 receptive adj （对于新思想）易于接受的 re sep tive cerp 拿 page 67 indulgent adj 纵容的 宽容的 indul gent dismiss v 解雇。。 dis miss discharge dis charge breed n 品种 bread 面包 b reed incredible adj 难以置信的 in cre di ble series n 一连串的 serious 严肃的 e 变ou se ri e s se ri ou s collaborate v 合作 col la bo rate page 68 hitherto adv 至今的 hit her to merit n 优点 me rit advantage depression adj 沮丧的 de pre s sion stability adj 稳固的 s ta bi lity stab 稳固]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 2]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list2%2F</url>
    <content type="text"><![CDATA[WORD LIST2 词根（同时也是单词） leas 松 dur 持续 mit 送 mand 命令 acu 尖 liber 自由 frag 破碎 tract 拉 memor 记忆 de- 去掉 en- 使 page 29 outstanding adj 杰出的 release v 释放 n 免除 wretched adj 可伶的 wret ched stifle v 使窒息 扑灭 sti fle page 30 solve 解决 reckless adj 轻率的 reck 顾忌 reck less hoarse adj （声音）沙哑的 hoar se duration adj 持续 dur 持续 dur ation moan n 呻吟 摸 嗯 mo an responsible adj 有责任的 res pon si ble page 31 yearm v 想念 fantasy n 幻想 想象 year m m 个year 不回家 想念 hail v 向。。欢呼 n 冰雹 欢呼 hai 嗨 l esteem v 尊重 把。。看作 n 尊敬 es teem chuckle v 窃笑 chu c kle gi g gle 傻笑 hardy adj 能吃苦的 hard 艰难 y adequate adj 足够的 a de qua te resourceful adj 机敏的 resource 办法 page 32 coward n 胆小鬼 co 加强 ward 朝向 sword 剑 s word approach v 接近 approve 支持 appro ach ve admin v 允许。。进入 dedicate v 把。。用于 de di cate command v 指挥 comment 评论 page 33 cripple n 残废 v 使。。残废 disable 残废 symptom n 征兆 症状 symp tom protest v n 抗议 pro test oppose op pose object ob ject stern adj 严厉的 n 末端 s tern contribute v 捐助 con 加强 tribute 给予 page 34 rare adj 稀有的 rarely adv 少见的 scarce s car ce ra re fragile adj 易碎的 frag 破碎 fra gi le decent adj 体面的 de 离开 cent 分币 page 35 profound adj 深厚的 深奥的 pro found 创立 acute adj 尖锐的 acu 尖 a cute proportion n 比例 pro por tion perspective n 看法 洞察力 per s pe c tive particular adj 特别的 par ti cu lar special s pe cial specific s pe ci fic page 36 parade n 阅兵 行列 v 列队行进 pa ra de buoy n 浮漂 v 支持 approve buo y fume v熏 n （有毒 难闻）气体 fu me liberal adj 宽容大度的 li be ral handle v 处理 manipulate 操控 mani pu late page 37 enlist v 入伍 en list productive product 产品 tive defeat v 击败 de 离开 feat 功绩 page 38 contrast n 对比 v 使。。对比 con trace contra 相反 embrace v 环抱 n 拥抱 em brace 臂膀 em barr ass intermediate adj 居中的 inter media te bump v n 撞击 bu mp teem v 充满 esteem 尊重 page 39 existence n 存在 exist ence highlight adj 高亮的 v 强调突出 generalize v 概括 ge ne ra lize sacrifice n 供奉 v 供奉 sac ri fice critical adj 批评 cri ti cal lead v n 领导 page 40 distract v 转移（注意力） contrace 对比 trivial adj 不重要的 tri vial upgrade v 提高。。级别 graduater 毕业生 colloquial adj 口语的 col 加强 loq 说 靠 。。。。 fond adj 喜爱的 不太可能实现的 found 掉啦u fond 喜爱的 page 41 pretent v 假装 pre tent clout n v 敲 c lout commemorate v 纪念 庆祝 com memo rate milestone n 里程碑 mile stone prove v 证明 desert v 放弃 n 沙漠 de sert 加入 detain v 拘留 de tain 拿住 delay 进程放慢 hinder v 阻止 impede 妨碍 page 42 scandal n 丑事 s can dal trace 跟踪 coax v 哄 co ax proclaim v 宣布 pro claim 声称 dissatisfy adj 不满意 dis satisfy page 43 scorn n 嘲笑的对象 v 嘲笑 corn 玉米 s corn purchase v 购买 pur chase principle adj 主要的 prin ci ple sincere adj 真实的 since re dull adj 不鲜明的 deduct v 扣除 duct 引导 de duct page 44 stir v 搅拌 n 搅拌 s ti r risk n 风险 v 使冒险 venture 冒险 ventilate v 使通风 enrich v 使富足 en rich scrutiny n 细查 详审 scrut 检查 iny scu ti ny liberty n 自由 解放 liber 自由 ty page 45 extend v 延伸 extent 范围 tend 伸展 faculty n （大学的）系 院 天赋 （院系的）全体教师 overdue adj 过期的 due 期限 appreciate v ganxie ap pre ci ate preci 价值 consist v 由什么组成 con sist page 46 dishonor n 耻辱 v 使受辱 honor 荣耀 undermine v 削弱 under mine erupt v （火山 喷泉） 喷发 事情突然发生 crisp adj 脆的 明确的 爽快的 commend v 赞扬 comment v 评论 crouch n 蹲伏 屈膝 低头 crou ch grasp v 抓紧 gra sp page 47 weight v 权衡 progress n 进展 pro gress disadvantage n v 不力局面 ad van tage page 48 annoy v 使生气 an noy loose adj 松的 v 释放 release gaze v 凝视 spic 看 suspicion 怀疑 ga ze laptop n 便携式电脑 explosive n 炸药 adj 易爆炸的 explo sive]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 4]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list4%2F</url>
    <content type="text"><![CDATA[WORD LIST4 词根（同时也是单词） nutri- 滋养 vid 看见 -ic 表人 chron 时间 laps 滑 clud 关闭 cruc 十字形 gen（u） 出生 genius scend 爬 path 感情 grav 重 page 69 dawn n 拂晓 黎明daw n display v 陈列 展示 nutrition n 营养 nu tri tion page 70 stammer v 结巴 n 口吃 s tam mer scatter v 使分散 s cat ter s tam mer hinder v 阻止 barr em barr ass hin der remove v 移去 impact n 效果 冲击 im pact evident adj 明显的 vid 看见 page 71 pound v 连续猛击 proud po un d p rou d incline v 倾向 赞同 n 斜坡 in c line explore v 探究 ex plo re repeal v 废止 re peal acknowledge v 承认 表示感谢 knowledge 知识 ac know ledge jail n 监狱 v 把。。关进监狱 ja il bail 保释金 lash v 鞭打 la sh page 72 peer v 凝视 gaze 凝视 spic 看 suspicion 怀疑 spin v 纺纱 快速旋转 vice n 罪恶 缺点 vi ce confess repent 悔悟 re pent criticize v 批评 c ri ti cize crit 判断 blame condemn 强烈的谴责 con de mn eager adj 热切的 ea ger page 73 mechanic n 机械师 me chan ic mechan 机械 ic 表人 liable adj 有法律责任的 lia ble feature n 脸的一部分 特色 v 以。。为特色 fea ture participate v 参与 part ti ci pate chronic adj 慢性的 长期未愈的 chro nic corrupt adj 腐败的 cor rupt page 74 dwarf n 矮子 d war f elapse v/n 过去 消逝 e lap se lock exclude v 排除 ex clude overcome v 战胜 克服 page 75 formidable adj 令人畏惧的 dread for mi da ble respective adj 各自的 res pe ctive haste n 急速 仓促 has te crucial adj 极其重要的 trivial 不重要的 significant 重要的 immaterial 不重要的 cru cial scratch v 抓 scrat ch page 76 genuine adh 真正的 ge nui ne genius ge niu s notion n 观念 concept 概念 wit n 才智 机智 slack adj 松弛的 loose 松的 s lack descend v 下降 des cend decrease 减少 de crea se page 77 pathetic adj 引起怜悯的 path 感情 etic blunt adj 钝的 迟钝的 b lun t gravity n 重力 gra vity tend v 倾向 趋势 incline 倾向 inc line bull n 公牛 bu ll rash adj 鲁莽的 ra sh own v 归功于 page 78 alter v 变动 al ter leading adj 领导的 turnover n 营业额 turn over despise v 蔑视 des pise announce v 宣布 proclaim pro claim 宣称 bleash v 漂白 b lea sh export v 输出 explore 探索 ex plo re ex por t page 79 droop n/v 低垂 下垂 d roop fertilizer v 使多产 fer ti lize productive entertain v 招待 enter tain 拿住 lag v 走得慢 log 逻辑 polish v 完善 n 上光剂 po lish punish 惩罚 pu nish affluent adj 富裕的 af fluent adequate satisfied page 80 collect v 收集 col lect lubricate v 使润滑 lu bri cate summit n 顶点 极点 sum mit peak 最高峰 page 81 load n 负荷 undercover v 暗中进行 under cover breach v/n 违反 b rea ch violent adj 暴力的 vio lent reciprocal adj 互惠的 contrace 相互作用 counterattack v 反击 counter attck counter 相反的 spiral adj 螺旋状的 n 螺旋状物体 s pi ral page 82 swear v 发誓 s wear bid v 命令 emphasis v 强调 em pha sis shudder v 抽动 shud der undergo v 经历 undercover v 暗中进行 under go span n 跨度 v 横跨s pan distinct adj 不同的 distinctive adj 特殊的 distinguish page 83 imply v 暗示 im ply foremost adj 最先的 foresee foreward status n 身份 s ta tu s civilize v 教化 civilization 文明 ci vi lize ci vi lii zation critical 批评 disdain v 鄙视 despise 蔑视 dis dain enforce v 实施 坚持 en force 力量 page 84 profile v 侧面 人物简转 pro file verify v 证实 ve rify comparable adj 类似的 com pa ra ble bounce v 弹起 boun ce assign v 分配 as sign assignment page 85 temperate adj 温和的 tem pe rate breakthrought n 重大发现 break throught embargo v 禁止 barr hinder 阻止 detain 拘留 em bar go economic adj 经济上的 e co no mic conserve v 节约使用 报存 con serve foster v 促进 motivate 促动 fos ter page 86 poise v 平衡 n 泰然自若 po i se security n 保证 抵押品 se cu rity]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 6]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list6%2F</url>
    <content type="text"><![CDATA[WORD LIST6 vis 看 cap 拿 vig 生命 Greg 群体 rod 咬 an- 无 in- 进入 sist 站 spect spic 看 circ 环 prehens 抓 ed 吃 page 107 continue v 继续 con ti nue glare v 怒视 g la re peer 凝视 gaze 凝视 page 108 excess adj/n 过分的 过多的 fastidious adj 鸡蛋挑骨头的 fas ti dious thrash v 打 （谷物） 鞭打 outdated adj 过期的 overdue 过期的 elaborate adj 精心制作的 e la bo rate falter v 动摇 犹豫 fal ter visible adj 可见的 vi si ble page 109 increase v 增加 in crea se enlarge augment multiply 增加 aspect n 方面 concept 层面 as pect resolve v/n 决心 resolution 分辨率 决心 bore v 钻孔 bo re boring let page 110 inquire v 咨询 in qui re mass adj 脏乱的 agreeable adj 惬意的 爽快的 crisp 脆的 惬意的 c ri sp faith n 信任 fail 公平 fai th spray n 水花 sp ray page 111 familiar adj 熟悉的 hereditary adj 遗传的 he ri di tary guarantee v/n 保证 gua ran tee stall picturesque adj 迷人的 生动的 pic ture s que page 112 hazard n 危险 ha zard hazardous adj 危险的 risk hazard 无法预测的危险 monopolize mo no po lize v 垄断 摸 no polize 摸 不要 请 -&gt; 垄断 capacity n 容量 ca pa city 开 啪 city -&gt;强奸 城市大的容量 vigour/vigor n 活力 vi gour/gor vi gor we go go go -&gt;诱惑力 inequality adj 不公平 in equa lity clear page 113 breath gregarious adj 群居的 共生的 gre ga rious -&gt;green 搞 肉丝 -&gt;一群人给肉丝带绿帽 -&gt;群居的 共生的 pardon v 宽恕 par don 啪 蛋 -&gt;帮你啪个蛋-&gt;说明她原谅你拉 whisper v 低语 whis per seal n 海豹 印记 v 盖章 sales销售 sell seal 傻傻分不清楚 海豹盖章 密封销售 page 114 worth erode v 腐蚀 e ro de -&gt;一 肉 得——&gt;一块一块肉的被毒药得到-&gt;腐蚀 intend quit magic page 115 desire v 渴望 de sire -&gt;de si re -&gt;的 士 儿 渴望 打飞机 dissolve evolve v 进化 e vol ve -&gt;一 窝 we -&gt;单人模式窝在一起进化成多人模式 assist v 协助 assist as sist page 116 uphold deport v 驱逐 de port -&gt; delete 端口 -&gt;驱逐 excite v ex ci te tug v 用力拉 bug t bug -&gt;用力拉bug page 117 ignore v 忽视 ig nore overlook capital accordance v 符合 accord 根据-&gt;根据啪找到啦符合的男优 dance 起来 anonymous adj 无名的 anony mous -&gt;annoy 摩斯-&gt;对摩斯发无名火 schedule n 时间表 s che dule page 118 conceal v 隐藏 con ceal seal 傻傻分不清楚 隐藏的海豹 销售并盖章 intrude v 入侵 int rude -&gt;进入得很粗鲁：）-&gt;入侵 complicity v 同谋 comp li city -&gt;糠屁离city-&gt;一个猪的糠和屁屁同时离开city -&gt;肯定是同谋 invest v 投资 耗费 in vest TM你以为vest是反转 那就这样搞呗-&gt;在反转里-&gt;股票不升反降-&gt;搞鸡毛，耗费name多钱 mature v 使成熟 ma ture-&gt;妈 真-&gt;少女变少妇-&gt;成熟 page 119 seize v 抓取 sei ze -&gt;see 子-&gt;看见熊孩子，直接抓起来打 -&gt;抓取 ability n 能力 authentic adj 真正的 authen tic -&gt;auther 提课-&gt;原作者提出的课程-&gt;肯定是真的啦 compute v 计算 adolescent adj 青少年的 adoles cent-&gt;a大死 sent 一个大就死啦 送啦 -&gt;典型青少年玩家 resist v 抵抗 re sist assist -&gt;read 抵抗协助 -&gt;阅读障碍 TM又抵抗帮助 page 120 comparison n 对比 renovate v 修复 re no vate-&gt;阅读无需等待 为啥呢？ bug被修复啦 gnaw v 咬 g na w -&gt;靠 怎么记 -&gt;g 儿 那玩意 变成W形状啦-&gt;被咬成那样的 shriek v 尖叫 sh riek-&gt;share 到 risk-&gt;分享风险，然后尖叫。鸡儿 fiddle n 欺诈 hide fid dle -&gt;明修栈道飞度陈仓 sneer v 嘲笑 s neer -&gt;是 你 儿-&gt;这是你儿子，靠。-&gt;嘲笑 spectacular adj 壮观的 s pec ta cular -&gt;死拍他q勒-&gt;死啦都啪q勒。靠 page 121 attention n 注意 circulate v 循环 activate v 使活动 symbolize v 象征 代表 clench v 握紧 clen ch -&gt;可能吃，狗比二哈护食-&gt;护食 integral adj 不可或缺 in te gral -&gt;intel 狗是不可缺的 page 122 edible adj 可以吃的 异地波 -&gt;异地狼一波-》可以放开吃 paste adj 糊装的 -》拍死特-&gt;往电线杆拍小广告，拍死啦一个特别帅点的苍蝇-糊装的 ravege v 毁坏 -ra 瓦 击-&gt;叫瓦片之间相互击打-&gt;破坏 fiery adj 火的 fire 火 靠 毫无规律 cost resign v 辞去 re sign -》发送辞去的信号 page 123 defend、 punctual adj 准时的 pun c tual -》胖 克 托儿 -》胖子克服托着儿子的负累准时的到来 gloom adj 黑暗的 g loom -》哥 撸 目 -》哥 睁着眼撸 comprehensive adj 综合的 全面的 page 124 prior adj 预先的 p rior -&gt;扑 弱儿 -》预先知道那货是个弱智-》扑向他 mechanize v 使机械化 terminal n 终端 linux 终端、 revive v 苏醒 re vive -》让他们wave-》让他们浪、毕竟刚醒 vomit v 呕吐 -》wo mit-》我们相遇啦-》所以想吐 private adj 私人的 pri vate—、page 125 facility n 设备 faci lity-&gt;fantasy -》found see 你 提 -》喜欢看你提那些设备 bias n 偏见 bi as -》b ass-》做一个傻瓜，你TM当然有意见啦-0》偏见 emerge v 出现 -》姨妈 机-》姨妈机出现 姨妈不是问题 congruent adj 一致的 con gru ent -》糠 哥入 end -》糠入啦哥的后面-》大家一致觉得很污 page 126 endure v 忍受 en dure 嗯 假ri -》嗯嗯嗯 在哪假叫-》忍受得啦 appropriate adj 适合的 appro pri ate -》private priate -》私人少v-》不是私人-》合适搞破坏 detail n 的 tell -&gt;向的士司机说自己要去地方的细节 crack v 使破裂 c rack -》risk -》克 right ke -》克服正常的可能=-》不正常-》只能破裂]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word list 7]]></title>
    <url>%2F2018%2F01%2F03%2Fword%20list7%2F</url>
    <content type="text"><![CDATA[WORD LIST7 pel 推 mut 交换 sens 感觉 -ate 做 spir 呼吸 glor 光荣、 par 相等 volunt 意愿 vad 走 matern 母亲 page 127-]]></content>
      <categories>
        <category>博客记单词</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JPanel与JFrame的区别]]></title>
    <url>%2F2017%2F12%2F03%2FJPanel%E4%B8%8EJFrame%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Jpanel不是顶级窗口，不能直接输出。它必须放在象JFrame这样的顶级窗口上才能输出。 JcontentPane实际上就是一个JPanel。Jframe中会默认new一个JPanel，塞入JFrame中。 JPanel可以放在JFrame中，但是反过来就是不行的！效果上没什么特大的区别~！ JFrame用来做主页面框架，JPanel只是普通页面 JPanel可以放在JFrame中，反之不行. JFrame 可以看成,最底级容器,可以包括其他上级容器包括JPanel JFrame只是一个界面，也就是个框架，要想把控件放在该界面中，必须把控件放在JPanel中，然后再把JPanel放在JFrame中，JPanel作为一个容器使用。]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2017%2F11%2F13%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[状态模式要达到的目的：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类 具体实例Application12345678910111213141516171819package zhuangtaimoshi;/** * Created by 15581 on 2017/11/8. */ // Application.javapublic class Application&#123; public static void main(String args[]) &#123; TemperatureState state=new LowState(-12); Thermometer thermometer=new Thermometer(); thermometer.setState(state); thermometer.showMessage(); state=new MiddleState(20); thermometer.setState(state); thermometer.showMessage(); state=new HeightState(39); thermometer.setState(state); thermometer.showMessage(); &#125;&#125; HeightState123456789101112131415package zhuangtaimoshi;/** * Created by 15581 on 2017/11/8. */ // HeightState.javapublic class HeightState implements TemperatureState&#123; double n=26; HeightState(int n)&#123; if(n&gt;26) this.n=n; &#125; public void showTemperature()&#123; System.out.println("现在温度是"+n+"属于高温度"); &#125;&#125; LowState123456789101112131415package zhuangtaimoshi;/** * Created by 15581 on 2017/11/8. */ // LowState.javapublic class LowState implements TemperatureState&#123; double n=0; LowState(double n)&#123; if(n&lt;=0) this.n=n; &#125; public void showTemperature()&#123; System.out.println("现在温度是"+n+"属于低温度"); &#125;&#125; MiddleState123456789101112131415package zhuangtaimoshi;/** * Created by 15581 on 2017/11/8. */ // MiddleState.javapublic class MiddleState implements TemperatureState&#123; double n=10; MiddleState(int n)&#123; if(n&gt;0&amp;&amp;n&lt;=26) this.n=n; &#125; public void showTemperature()&#123; System.out.println("现在温度是"+n+"属于正常温度"); &#125;&#125; TemperatureState12345678package zhuangtaimoshi;/** * Created by 15581 on 2017/11/8. */ // TemperatureState.javapublic interface TemperatureState&#123; public void showTemperature();&#125; Thermometer1234567891011121314package zhuangtaimoshi;// Thermometer.javapublic class Thermometer&#123; TemperatureState state; public void showMessage()&#123; System.out.println("***********"); state.showTemperature(); System.out.println("***********"); &#125; public void setState(TemperatureState state)&#123; this.state=state; &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式 Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟练网页]]></title>
    <url>%2F2017%2F11%2F13%2F%E5%8A%A8%E6%89%8B%E5%86%99%E7%BD%91%E9%A1%B51%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟练网页&lt;/title&gt;&lt;style media="screen"&gt;input[type=text] &#123; width: 130px; box-sizing: border-box; border: 2px solid #ccc; border-radius: 4px; font-size: 16px; background-color: white; background-image: url('searchicon.png'); background-position: 10px 10px; background-repeat: no-repeat; padding: 12px 20px 12px 40px; -webkit-transition: width 0.4s ease-in-out; transition: width 0.4s ease-in-out;&#125;input[type=text]:focus &#123; width: 100%;&#125;body&#123; background-image: url('http://p1.bqimg.com/567571/1487e5929ef40176.jpg');&#125;#myInput &#123; background-image: url('https://static.runoob.com/images/mix/searchicon.png'); /* 搜索按钮 */ background-position: 10px 12px; /* 定位搜索按钮 */ background-repeat: no-repeat; /* 不重复图片 */ width: 100%; font-size: 16px; padding: 12px 20px 12px 40px; border: 1px solid #ddd; margin-bottom: 12px;&#125;#myTable &#123; border-collapse: collapse; width: 100%; border: 1px solid #ddd; font-size: 18px;&#125;#myTable th, #myTable td &#123; text-align: left; padding: 12px;&#125;#myTable tr &#123; /* 表格添加边框 */ border-bottom: 1px solid #ddd;&#125;#myTable tr.header, #myTable tr:hover &#123; /* 表头及鼠标移动过 tr 时添加背景 */ background-color: #f1f1f1;&#125;&lt;/style&gt;&lt;body&gt; &lt;input type="text" id="myInput" onkeyup="myFunction()" placeholder="搜索..."&gt; &lt;form&gt; &lt;input type="text" name="search" placeholder="Search.."&gt; &lt;/form&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;function myFunction() &#123; // 声明变量 var input, filter, table, tr, td, i; input = document.getElementById("myInput"); filter = input.value.toUpperCase(); table = document.getElementById("myTable"); tr = table.getElementsByTagName("tr"); // 循环表格每一行，查找匹配项 for (i = 0; i &lt; tr.length; i++) &#123; td = tr[i].getElementsByTagName("td")[0]; if (td) &#123; if (td.innerHTML.toUpperCase().indexOf(filter) &gt; -1) &#123; tr[i].style.display = ""; &#125; else &#123; tr[i].style.display = "none"; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>web  Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2017%2F11%2F13%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[责任链模式要达到的目的：责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求 具体实例Application1234567891011121314151617181920212223package zherenlian;/** * Created by 15581 on 2017/11/8. */ // Application.javapublic class Application&#123; private Handler beijing,shanghai,tianjin; //责任链上的对象 public void createChain()&#123; //建立责任链 beijing=new Beijing(); shanghai=new Shanghai(); tianjin=new Tianjin(); beijing.setNextHandler(shanghai); shanghai.setNextHandler(tianjin); &#125; public void reponseClient(String number)&#123; //响应用户的请求 beijing.handleRequest(number); &#125; public static void main(String args[])&#123; Application application=new Application(); application.createChain(); application.reponseClient("77720810340930632");; &#125;&#125; Beijing12345678910111213141516171819202122232425262728293031package zherenlian;import java.util.ArrayList;/** * Created by 15581 on 2017/11/8. */public class Beijing implements Handler&#123; private Handler handler; //存放当前处理者后继的Hander接口变量 private ArrayList&lt;String&gt; numberList; //存放身份证号码的数组线性表 Beijing()&#123; numberList=new ArrayList&lt;String&gt;(); numberList.add("11129812340930034"); //这里使用模拟的身份证号码 numberList.add("10120810340930632"); numberList.add("22029812340930034"); numberList.add("32620810340930632"); &#125; public void handleRequest(String number)&#123; if(numberList.contains(number)) System.out.println("该人在北京居住"); else&#123; System.out.println("该人不在北京居住"); if(handler!=null) handler.handleRequest(number); //将请求传递给下一个处理者 &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler=handler; &#125;&#125; Handler1234567package zherenlian;// Handler.javapublic interface Handler&#123; public abstract void handleRequest(String number); public abstract void setNextHandler(Handler handler);&#125; Shanghai123456789101112131415161718192021222324252627282930package zherenlian;import java.util.ArrayList;/** * Created by 15581 on 2017/11/8. */public class Shanghai implements Handler&#123; private Handler handler; //存放当前处理者后继的Hander接口变量 private ArrayList&lt;String&gt; numberList; //存放身份证号码的数组线性表 Shanghai()&#123; numberList=new ArrayList&lt;String&gt;(); numberList.add("34529812340930034"); //这里使用模拟的身份证号码 numberList.add("98720810340430632"); numberList.add("36529812340930034"); numberList.add("77720810340930632"); &#125; public void handleRequest(String number)&#123; if(numberList.contains(number)) System.out.println("该人在上海居住"); else&#123; System.out.println("该人不在上海居住"); if(handler!=null) handler.handleRequest(number); //将请求传递给下一个处理者 &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler=handler; &#125;&#125; Tianjin123456789101112131415161718192021222324252627282930package zherenlian;import java.util.ArrayList;/** * Created by 15581 on 2017/11/8. */public class Tianjin implements Handler&#123; private Handler handler; //存放当前处理者后继的Hander接口变量 private ArrayList&lt;String&gt; numberList; //存放身份证号码的数组线性表 Tianjin()&#123; numberList=new ArrayList&lt;String&gt;(); numberList.add("10029812340930034"); //这里使用模拟的身份证号码 numberList.add("20020810340430632"); numberList.add("30029812340930034"); numberList.add("50020810340930632"); &#125; public void handleRequest(String number)&#123; if(numberList.contains(number)) System.out.println("该人在天津居住"); else&#123; System.out.println("该人不在天津居住"); if(handler!=null) handler.handleRequest(number); //将请求传递给下一个处理者 &#125; &#125; public void setNextHandler(Handler handler)&#123; this.handler=handler; &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式 Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设配器模式]]></title>
    <url>%2F2017%2F11%2F13%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式要达到的目的：在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。 1.类图 2.具体实例 Application12345678910111213141516171819package shepeiqi;/** * Created by 15581 on 2017/11/8. */ // Application.javapublic class Application&#123; public static void main(String args[])&#123; ThreeElectricOutlet outlet; //目标接口（三相插座） Wash wash=new Wash(); //洗衣机 outlet=wash; //洗衣机插在三相插座上 System.out.println("使用三相插座接通电流："); outlet.connectElectricCurrent(); //接通电流，开始洗衣服 TV tv=new TV(); //电视机 TreeElectricAdapter adapter=new TreeElectricAdapter(tv);//把电视插在适配器上 outlet=adapter; //适配器插在三相插座上 System.out.println("使用三相插座接通电流："); outlet.connectElectricCurrent(); //接通电流，开始播放电视节目 &#125;&#125; ThreeElectricOutlet123456package shepeiqi;// ThreeElectricOutlet.javapublic interface ThreeElectricOutlet&#123; public abstract void connectElectricCurrent();&#125; TreeElectricAdapter1234567891011121314package shepeiqi;/** * Created by 15581 on 2017/11/8. */ // TreeElectricAdapter.javapublic class TreeElectricAdapter implements ThreeElectricOutlet&#123; TwoElectricOutlet outlet; TreeElectricAdapter(TwoElectricOutlet outlet)&#123; this.outlet=outlet; &#125; public void connectElectricCurrent()&#123; outlet.connectElectricCurrent(); &#125;&#125; TV1234567891011121314151617181920package shepeiqi;/** * Created by 15581 on 2017/11/8. */class TV implements TwoElectricOutlet&#123; //电视机使用两相插座 String name; TV()&#123; name="长江电视机"; &#125; TV(String s)&#123; name=s; &#125; public void connectElectricCurrent()&#123; turnOn(); &#125; public void turnOn()&#123; System.out.println(name+"开始播放节目。"); &#125;&#125; TwoElectricOutlet12345678package shepeiqi;/** * Created by 15581 on 2017/11/8. */ // TwoElectricOutlet.javapublic interface TwoElectricOutlet&#123; public abstract void connectElectricCurrent();&#125; Wash&gt;1234567891011121314151617181920package shepeiqi;/** * Created by 15581 on 2017/11/8. */class Wash implements ThreeElectricOutlet&#123; //洗衣机使用三相插座 String name; Wash()&#123; name="黄河洗衣机"; &#125; Wash(String s)&#123; name=s; &#125; public void connectElectricCurrent()&#123; turnOn(); &#125; public void turnOn()&#123; System.out.println(name+"开始洗衣物。"); &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式 Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm使用]]></title>
    <url>%2F2017%2F11%2F11%2Fpycharm%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在pycharm中安装包http://oyhm15net.bkt.clouddn.com/2017-11-15_104859.png interpreterhttp://oyhm15net.bkt.clouddn.com/2017-11-15_105315.png]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python programing Hacker pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字与字符串]]></title>
    <url>%2F2017%2F11%2F11%2F%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 封装类：所有的基本类型，都有对应的类类型。比如int对应的类是Integer 这种类就叫做封装类 Number类：数字封装类有 Byte,Short,Integer,Long,Float,Double 这些类都是抽象类Number的子类 数字与字符串互转 Math类 常用方法 StringBuffer是可变长的字符串]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程 socket]]></title>
    <url>%2F2017%2F11%2F11%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 单线程聊天 多线程聊天 带界面的聊天程序]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射机制]]></title>
    <url>%2F2017%2F11%2F11%2F%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 类对象 与未实例化对象有区别 12345Hero c=null;//未实例化的类对象 Class c1=class.forname(className);//类对象Class c2=Hero.class;Class c3=new Hreo.getClass(); 创建对象：传统方法 new 1Hero h1 =new Hero(); 反射机制不同：会先拿到Hero的“类对象”,然后通过类对象获取“构造器对象” 再通过构造器对象创建一个对象 12345678//使用反射的方式创建对象 String className = "charactor.Hero"; //类对象Class pClass=Class.forName(className); //构造器Constructor c= pClass.getConstructor(); //通过构造器实例化 Hero h2= (Hero) c.newInstance(); 通过配置文件获取对象 访问属性并修改]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2017%2F11%2F11%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式要达到的目的：装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 1.类图 2.具体实例 2.1 Applicationpackage Decorator;12345678910111213141516171819/** * Created by 15581 on 2017/11/8. */ // Observer.Application.javapublic class Application&#123; public void needBird(Bird bird)&#123; int flyDistance=bird.fly(); System.out.println("这只鸟能飞行"+flyDistance+"米"); &#125; public static void main(String args[])&#123; Application client=new Application(); Sparrow sparrow=new Sparrow(); SparrowDecorator sparrowDecorator1= new SparrowDecorator(sparrow); SparrowDecorator sparrowDecorator2= new SparrowDecorator(sparrowDecorator1); client.needBird(sparrowDecorator1); client.needBird(sparrowDecorator2); &#125;&#125; 2.2 Bird123456package Decorator;// Bird.javapublic abstract class Bird&#123; public abstract int fly();&#125; 2.3 Decorator12345678910111213package Decorator;/** * Created by 15581 on 2017/11/8. */ // Decorator.javapublic abstract class Decorator extends Bird&#123; protected Bird bird; public Decorator()&#123; &#125; public Decorator(Bird bird)&#123; this.bird=bird; &#125;&#125; 2.4 Sparrow1234567891011package Decorator;/** * Created by 15581 on 2017/11/8. */ // Sparrow.javapublic class Sparrow extends Bird&#123; public final int DISTANCE=100; public int fly()&#123; return DISTANCE; &#125;&#125; 2.5 SparrowDecorator12345678910111213141516171819package Decorator;/** * Created by 15581 on 2017/11/8. */ // SparrowDecorator.javapublic class SparrowDecorator extends Decorator&#123; public final int DISTANCE=50; //eleFly方法能飞米 SparrowDecorator(Bird bird)&#123; super(bird); &#125; public int fly()&#123; int distance=0; distance=bird.fly()+eleFly(); //委托被装饰者bird调用fly()，然后再调用eleFly() return distance; &#125; private int eleFly()&#123; //装饰者新添加的方法 return DISTANCE; &#125;&#125; 2.6 SparrowDecoratorTwo12345678910111213141516171819package Decorator;/** * Created by 15581 on 2017/11/8. */ // SparrowDecoratorTwo.javapublic class SparrowDecoratorTwo extends Decorator&#123; public final int DISTANCE=20; SparrowDecoratorTwo(Bird bird)&#123; super(bird); &#125; public int fly()&#123; int distance=0; distance=bird.fly()+eleFly(); return distance; &#125; public int eleFly()&#123; return DISTANCE; &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2017%2F11%2F11%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 数组反转 选择排序 ：先找最小放在首端 冒泡排序：先找最大放在末端 最后一位在下次循环中不比较 用增强型for循环找出最大的那个数 复制数组 合并数组 数组的工具类Arrays]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[report]]></title>
    <url>%2F2017%2F10%2F30%2Freprot%2F</url>
    <content type="text"><![CDATA[National Day IntroductionThe aim of this report is to show people’s behavior in National Day.We call countries establish the anniversary of National Day on October 1, 1949, is the anniversary of the founding of new China.This report is based on the families of HuBei province. FindingsIt was found that people almost choose travel in this 7 days free,and resulting in serious traffic confusion in the whole city.The following points summarise our keys findings: travel crowed RecommendationsIn order to deal with traffic problem,we should avoid traveling in National Day.If you have to ,you should choose the places like countryside to travel in this 7 days.There are several factors which affect crowed.So the best choice is to company your family. ConclusionIt is clear that thousands of people are going to travel in this 7 days.]]></content>
  </entry>
  <entry>
    <title><![CDATA[notice]]></title>
    <url>%2F2017%2F10%2F30%2Fnotice%2F</url>
    <content type="text"><![CDATA[Sample Promissory NoteI, Jane Doe, residing at 111 Maple Dr., Los Angeles, CA 90435,hereby promise to pay back, in full, the borrowed amount of $1800plus interest to John Smith at 5432 Applewood St., Los Angeles,CA 90456. This money will be used for the purpose of buying anew computer for school. Sincerely Yours Jane Doe Match 22nd ,2008]]></content>
  </entry>
  <entry>
    <title><![CDATA[busines letter]]></title>
    <url>%2F2017%2F10%2F30%2Fbusines%20letter%2F</url>
    <content type="text"><![CDATA[Mr Wang Min Personnel Manager Viewtech Company Tiandi St Harbin January 24, 2002Mr Gao Junguang59 Liaoyuan StZhengzhouDear Mr Gao Your good office is hereby authorized to forward to our accounting office all the bills of (Name of guest), our honored guest of our company for his stay in your hotel. It has been informed to immediately approve and pay any invoices from your hotel. We have placed a credit account in the amount of————-. Should this account exceed this amount, please contact our office for approval in advance of any additional charges. Thank you for your special consideration of this matter. If there may be required any assistance to this matter, please contact our office as necessary. Yours sincerelyWang Min]]></content>
  </entry>
  <entry>
    <title><![CDATA[note and memo]]></title>
    <url>%2F2017%2F10%2F30%2Fnote%2F</url>
    <content type="text"><![CDATA[Henny Can’t find the name list i need for the security meeting.if you’ve kept a record,please give another copy to me ASAP. Thanks lvy To :Oggince ManagersFrom :JOESubject :Room change for the next meetingData: April 14th,2009 The meeting on Friday,April 17th,has been changed to Room 302.]]></content>
  </entry>
  <entry>
    <title><![CDATA[StringMatching]]></title>
    <url>%2F2017%2F10%2F29%2Fjava%E7%95%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[学习目的：有条理的血java界面程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package com.example;import java.awt.Color;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import javax.swing.JButton;import javax.swing.JComboBox;import javax.swing.JFileChooser;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;public class StringMatching extends JFrame&#123; private static final long serialVersionUID = 1L;//序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性 private JFrame jf=new JFrame("标题：charMatching"); //提醒字符 private JLabel l1=new JLabel("Pattern Strng:");//JLabel对象可显示文本，图片 private JLabel l2=new JLabel("Text resource"); private JLabel l4=new JLabel("resource"); private JLabel l3=new JLabel("choose pattren"); //定义菜单 private JComboBox&lt;String&gt; pattern=new JComboBox&lt;String&gt;();//下拉框 //资源与结果框 private JTextArea result=new JTextArea(); private JTextArea resource=new JTextArea(); //某种绑定 private JScrollPane jp2=new JScrollPane(result); private JScrollPane jp=new JScrollPane(resource);//JScrollPane 管理视口、可选的垂直和水平滚动条以及可选的行和列标题视口， //输入查询字符框 private JTextField patternInput=new JTextField();//JTextField 是一个轻量级组件，它允许编辑单行文本 //按钮 private JButton find=new JButton(); private JButton clear=new JButton(); private JFileChooser chooser=new JFileChooser(); //构造函数 Demo()&#123; setFrame(); setTextFields(); setMenu(); setButton(); &#125; //设置主界面 void setFrame()&#123; jf.setSize(600,600); jf.setResizable(false);//窗体是否自由变换大小 jf.setVisible(true);//窗口显示 jf.setLayout(null);//未设置layout 系统默认flowLayout布局 null清除布局管理器 jf.setDefaultCloseOperation(EXIT_ON_CLOSE);//设置用户在此窗体上发起 "close" 时默认执行的操做 &#125; //添加文本域 void setTextFields()&#123; l1.setBounds(20,90,100,30);//setBounds(x,y,width,height); x:组件在容器X轴上的起点 // y:组件在容器Y轴上的起点 width:组件的长度 height:组件的高度 jf.add(l1); patternInput.setBounds(120,30,200,25); jf.add(patternInput); patternInput.setCaretColor(Color.CYAN);//设置符号颜色 patternInput.setSelectedTextColor(Color.YELLOW);//设置搜索字符颜色 l2.setBounds(20,90,100,30); jf.add(l2); resource.setLineWrap(true);//设置文本区的换行策略(句子换行) resource.setWrapStyleWord(true);//单词换行true resource.setEditable(false); resource.setCaretColor(Color.YELLOW); resource.setSelectedTextColor(Color.BLUE);////设置文本框被选择颜色 //resource的异常处理 try&#123; @SuppressWarnings("resource")//有了suppresswarning这个批注，可以取消一些特定代码段中的警告，比如你看到警告，你查了一下，发现他不是问题， // 可是你为了好看又不想让他报警，就可以加这个批注。 BufferedReader br=new BufferedReader(new FileReader(new File("txtFile/cache.txt"))); resource.setText("\n\n\n\n\n");//正则表达式 while (br.readLine()!=null)&#123; resource.setText(resource.getText()+"\n"+br.readLine()+"\n"); &#125; &#125;catch(Exception e)&#123; e.printStackTrace();//在命令行打印异常信息在程序中出错的位置及原因 &#125; //jp对象传入的参数为resource jp.setBounds(20,120,300,400); jf.add(jp); l4.setBounds(370,95,100,25); jf.add(l4); //result result.setLineWrap(true);//设置文本区的换行策略(句子换行) result.setWrapStyleWord(true);//单词换行true result.setEditable(false); result.setSelectedTextColor(Color.getHSBColor(1,400,100));////设置文本框被选择颜色 //jp2对象传入的参数为result jp2.setBounds(20,90,100,30); jf.add(jp2); //完工 &#125; //设置下拉菜单 void setMenu()&#123; l3.setBounds(370,30,100,25); jf.add(l3); pattern.addItem("Choose File"); pattern.addItem("Chinese Demo"); pattern.addItem("English Demo"); pattern.addItem("Custom"); //给下拉框设置监听事件 pattern.addItemListener(new ItemListener() &#123; @Override public void itemStateChanged(ItemEvent itemEvent) &#123; if(pattern.getSelectedItem().toString()=="Chinese Demo")&#123; resource.setText("InPut your text"); resource.setText(null); result.setText(null); try&#123; @SuppressWarnings("resource")//有了suppresswarning这个批注，可以取消一些特定代码段中的警告，比如你看到警告，你查了一下，发现他不是问题， // 可是你为了好看又不想让他报警，就可以加这个批注。 BufferedReader br=new BufferedReader(new FileReader(new File("txtFile/cache.txt"))); int i=1; while (br.readLine()!=null)&#123; resource.setText(resource.getText()+"\n"+br.readLine()+"\n"); i++; &#125; &#125;catch(Exception e2)&#123; e2.printStackTrace();//在命令行打印异常信息在程序中出错的位置及原因 &#125; &#125; else if(pattern.getSelectedItem().toString()=="English Demo")&#123; resource.setText("InPut your text"); resource.setText(null); result.setText(null); try&#123; @SuppressWarnings("resource")//有了suppresswarning这个批注，可以取消一些特定代码段中的警告，比如你看到警告，你查了一下，发现他不是问题， // 可是你为了好看又不想让他报警，就可以加这个批注。 BufferedReader br=new BufferedReader(new FileReader(new File("txtFile/cache.txt"))); int i=1; while (br.readLine()!=null)&#123; resource.setText(resource.getText()+"\n"+br.readLine()+"\n"); i++; &#125; &#125;catch(Exception e2)&#123; e2.printStackTrace();//在命令行打印异常信息在程序中出错的位置及原因 &#125; &#125; else if(pattern.getSelectedItem().toString()=="Choose File")&#123;// resource.setText("Choose File"); resource.setText(null); result.setText(null); chooser.setFileSelectionMode(JFileChooser.FILES_ONLY); chooser.showOpenDialog(null); if(chooser.getSelectedFile().exists()&amp;&amp;chooser.getSelectedFile().canRead())&#123; try &#123; @SuppressWarnings("resource") BufferedReader br=new BufferedReader(new FileReader(chooser.getSelectedFile())); int i=1; while(br.readLine()!=null)&#123; resource.setText(resource.getText().trim()+"\n"+i+"—"+br.readLine()); i++; &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace();// TODO: handle exception &#125; &#125; &#125; else &#123; resource.setEditable(true); &#125; &#125; &#125;); //下拉框监听器在此结束 &#125; //设置按钮点击事件 void setButton()&#123; find.setBounds(370,65,90,25); jf.add(find); find.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; String sourceString=resource.getText(); String patternString=patternInput.getText(); String s[]=sourceString.split("\n");//分割字符串sourceString到s[] result.setText("teh text contains"+s.length+"lines"); result.setText(result.getText()+"\nThe following line(s) contain(s) "+"\""+patternString+"\":");//没理解 int no=0; for(int i=0;i&lt;s.length;i++)&#123; if(s[i].contains(patternString))&#123; result.setText(result.getText()+"\n"+(no+1)+":"+s[i]+"\n"); no++; &#125; result.setText(result.getText()+"\n\n"+"Total"+no+"item(s)contains"+"\""+patternString+"\".");//"\""这样才行 好奇怪 &#125; &#125; &#125;); clear.setBounds(480,65,90,25); jf.add(clear); clear.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent actionEvent) &#123; patternInput.setText(null); result.setText(null); resource.setText(null); &#125; &#125;); &#125; public static void main(String[] args)&#123; new Demo(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[多机调度]]></title>
    <url>%2F2017%2F10%2F28%2F%E5%A4%9A%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[调查报告]]></title>
    <url>%2F2017%2F10%2F22%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A%EF%BC%88%E8%8B%B1%E6%96%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[National Day IntroductionThe aim of this report is to show people’s behavior in National Day.We call countries establish the anniversary of National Day on October 1, 1949, is the anniversary of the founding of new China.This report is based on the families of HuBei province. FindingsIt was found that people almost choose travel in this 7 days free,and resulting in serious traffic confusion in the whole city.The following points summarise our keys findings: travel crowed RecommendationsIn order to deal with traffic problem,we should avoid traveling in National Day.If you have to ,you should choose the places like countryside to travel in this 7 days.There are several factors which affect crowed.So the best choice is to company your family. ConclusionIt is clear that thousands of people are going to travel in this 7 days.]]></content>
      <categories>
        <category>IT英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CV]]></title>
    <url>%2F2017%2F10%2F21%2Fcv%2F</url>
    <content type="text"><![CDATA[C.V Personal informationName: jackAddress: Wuhan Institute of Technology ,Hubei province ,ChinaContact Number: (mobile)15272205643Email:jackj2629@gmail.comCareer target: software engineerProfile：Graduated from wuhan engineering university.The major is English plus software.Good operational ability, including programming,getting new ideas and team working.Especially familiar with programming tools include Android studio(Android), visual studio(c++),eclipse(java).Education：Sep 2015-jul 2019 Bachelor’s degree in WITWork experience2016.9-2017.6:administering the 3D Print of bright green team2015.9-2016.6:operating the public WeChat of Foreign language collegeComputer skillsLanguages:android, java, c++,c,html5Operating System:windows 2017,UNIXSoftware:Visual studio,Android studio,eclipse Oct 20,2017 Dear SirWith reference to your job advertisement.I am interested in applying for the position of software engineer with your company.Your advertisement addresses my qualification perfectly.I can offer you the exact skills you are looking for in the applicants.I studied the major of English plus software that both you require.I have a great deal of experience about developing of android.I enclosed my C.V.Your company attracts me most is that you have a great prospect.Also i want a excellent working environment rather than bad one .Furthermore,i am available for the job interview at any time which is convenient for you.Thanks for your careful consideration to my application.I look forward to hearing form you. Yours faithfullyjack def main(): app = QApplication(sys.argv) mainWindow = MainWindow(app) print(“data path:”+mainWindow.DataPath) print(mainWindow.param.skin) if(mainWindow.param.skin == 1) :# light skin file = open(mainWindow.DataPath+’/assets/qss/style.qss’,”r”) else: #elif mainWindow.param == 2: # dark skin file = open(mainWindow.DataPath + ‘/assets/qss/style-dark.qss’, “r”) qss = file.read().replace(“$DataPath”,mainWindow.DataPath) app.setStyleSheet(qss) mainWindow.detectSerialPort() t = threading.Thread(target=mainWindow.autoUpdateDetect) t.setDaemon(True) t.start() sys.exit(app.exec_()) class ComboBox(QComboBox): clicked = pyqtSignal() def __init__(self): QComboBox.__init__(self) self.setView(QListView()) return def __del__(self): return def mouseReleaseEvent(self, QMouseEvent): self.clicked.emit() return]]></content>
      <categories>
        <category>IT英语</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[视频床与图床]]></title>
    <url>%2F2017%2F10%2F17%2F%E8%A7%86%E9%A2%91%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[手机游览器调成电脑板就可以看装逼视频 视频床：blibli123![](http://oxz3x2njl.bkt.clouddn.com/2017-10-17_233318.png)&lt;iframe src="//www.bilibili.com/blackboard/player.html?aid=15476533&amp;cid=25186214&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0"&gt;&lt;/iframe&gt; 图床+视频床：七牛云1234![](http://oxz3x2njl.bkt.clouddn.com/2017-10-17_233318.png)&lt;iframe src="http://oxz3x2njl.bkt.clouddn.com/%E6%96%B9%E4%BF%8A%E7%9A%84%E4%BA%AE%E7%9C%BC%E8%A1%A8%E7%8E%B0_17-08-04_09-17-46.mp4" scrolling="no" border="0" frameborder="no" framespacing="0"&gt;&lt;/iframe&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2017%2F10%2F13%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式要达到的目的：在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 1.类图 2.具体实例 A.txt1腾辉公司需要个java程序员。海景公司需要个动画设计师。仁海公司需要个电工。 Application1234567891011121314151617181920package Observer;/** * Created by 15581 on 2017/11/8. */ // Observer.Application.javapublic class Application&#123; public static void main(String args[])&#123; SeekJobCenter center=new SeekJobCenter(); UniverStudent zhangLin=new UniverStudent(center,"A.txt"); HaiGui wangHao=new HaiGui(center,"B.txt"); center.giveNewMess("腾辉公司需要个java程序员。"); center.notifyObservers(); center.giveNewMess("海景公司需要个动画设计师。"); center.notifyObservers(); center.giveNewMess("仁海公司需要个电工。"); center.notifyObservers(); center.giveNewMess("仁海公司需要个电工。"); center.notifyObservers(); &#125;&#125; B.txt1腾辉公司需要个java程序员。 HaiGui12345678910111213141516171819202122232425262728293031323334353637package Observer;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;/** * Created by 15581 on 2017/11/8. */public class HaiGui implements Observer&#123; Subject subject; File myFile; HaiGui(Subject subject,String fileName)&#123; this.subject=subject; subject.addObserver(this); myFile=new File(fileName); &#125; public void hearTelephone(String heardMess)&#123; try&#123; boolean boo=heardMess.contains("java程序员")||heardMess.contains("软件"); if(boo)&#123; RandomAccessFile out=new RandomAccessFile(myFile,"rw"); out.seek(out.length()); byte [] b=heardMess.getBytes(); out.write(b); System.out.print("我是一个海归,"); System.out.println("我向文件"+myFile.getName()+"写入如下内容:"); System.out.println(heardMess); &#125; else&#123; System.out.println("我是海归,这次的信息中没有我需要的信息"); &#125; &#125; catch(IOException exp)&#123; System.out.println(exp.toString()); &#125; &#125;&#125; Observer123456package Observer;// Observer.Observer.javapublic interface Observer&#123; public void hearTelephone(String heardMess);&#125; SeekJobCenter123456789101112131415161718192021222324252627282930313233343536373839404142package Observer;import java.util.ArrayList;/** * Created by 15581 on 2017/11/8. */public class SeekJobCenter implements Subject&#123; String mess; boolean changed; ArrayList&lt;Observer&gt; personList; SeekJobCenter()&#123; personList=new ArrayList&lt;Observer&gt;(); mess=""; changed=false; &#125; public void addObserver(Observer o)&#123; if(!(personList.contains(o))) personList.add(o); &#125; public void deleteObserver(Observer o)&#123; if(personList.contains(o)) personList.remove(o); &#125; public void notifyObservers()&#123; if(changed)&#123; for(int i=0;i&lt;personList.size();i++)&#123; Observer observer=personList.get(i); observer.hearTelephone(mess); &#125; changed=false; &#125; &#125; public void giveNewMess(String str)&#123; if(str.equals(mess)) changed=false; else&#123; mess=str; changed=true; &#125; &#125;&#125; Subject12345678910package Observer;/** * Created by 15581 on 2017/11/8. */ // Observer.Subject.javapublic interface Subject&#123; public void addObserver(Observer o); public void deleteObserver(Observer o); public void notifyObservers();&#125; UniverStudent12345678910111213141516171819202122232425262728293031package Observer;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;/** * Created by 15581 on 2017/11/8. */public class UniverStudent implements Observer&#123; Subject subject; File myFile; UniverStudent(Subject subject,String fileName)&#123; this.subject=subject; subject.addObserver(this); //使当前实例成为subject所引用的具体主题的观察者 myFile=new File(fileName); &#125; public void hearTelephone(String heardMess)&#123; try&#123; RandomAccessFile out=new RandomAccessFile(myFile,"rw"); out.seek(out.length()); byte [] b=heardMess.getBytes(); out.write(b); //更新文件中的内容 System.out.print("我是一个大学生,"); System.out.println("我向文件"+myFile.getName()+"写入如下内容:"); System.out.println(heardMess); &#125; catch(IOException exp)&#123; System.out.println(exp.toString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式 Programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看懂myqq项目]]></title>
    <url>%2F2017%2F10%2F13%2F%E7%9C%8B%E6%87%82myqq%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea创建maven项目]]></title>
    <url>%2F2017%2F10%2F13%2Fidea%E6%9E%84%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 1.下载与配置MAVEN 成功 2.idea创建maven项目 2.1配置(default setting(全局) 与 setting(单个项目) ) 2.2创建 成功 idea 注册码 Licence server http://idea.congm.in http://idea.lanyus.com/ jsp中引入jsp &lt;%@include file=”navigator.jsp”%&gt;]]></content>
      <categories>
        <category>实验项目</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2017%2F10%2F13%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[##1.接收者CompanyArmy12345public class CompanyArmy&#123; public void sneakAttack()&#123; System.out.printnln("我们知道如何偷袭敌人，保证完成任务")； &#125;&#125; ##2.命令接口Command123public interface Command&#123;public abstract void ececute();&#125; ##3具体命令ConcreteCommand1234567891011public class ConcreteCommand implements Command&#123; CompanyArmy army;//含有接收者的引用 ConcreteCommand(CompanyArmy army)&#123; this.army=army; &#125; public void execute()&#123;//封装这指挥官的请求 army.sneakAttack();//偷袭敌人 &#125;&#125; ##4.请求者ArmySuperior12345678910public class ArmySuperior&#123; Command command;//用来存放具体命令的引用 public void setCommand(Command command)&#123; this.command=command; &#125; public void startExecuteCommand()&#123;//让具体命令执行execute()方法 command.execute(); &#125;&#125; ##5.模式的使用Application123456789public class Application&#123; public staic void main(String args[])&#123; CompanyArmy 三连=new CompanyArmy();//创建接收者 Command command=new ConcreteCommand(三连);//创建具体命令并指定接收者 ArmySuperior 指挥官=new ArmySuperior();//创建请求者 指挥官.setCommand(command); 指挥官.startExecuteCommand(); &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一步之遥]]></title>
    <url>%2F2017%2F10%2F11%2F%E4%B8%80%E6%AD%A5%E4%B9%8B%E9%81%A5%2F</url>
    <content type="text"><![CDATA[从昏迷中醒来，小明发现自己被关在X星球的废矿车里。矿车停在平直的废弃的轨道上。他的面前是两个按钮，分别写着“F”和“B”。小明突然记起来，这两个按钮可以控制矿车在轨道上前进和后退。按F，会前进97米。按B会后退127米。透过昏暗的灯光，小明看到自己前方1米远正好有个监控探头。他必须设法使得矿车正好停在摄像头的下方，才有机会争取同伴的援助。或许，通过多次操作F和B可以办到。矿车上的动力已经不太足，黄色的警示灯在默默闪烁…每次进行 F 或 B 操作都会消耗一定的能量。小明飞快地计算，至少要多少次操作，才能把矿车准确地停在前方1米远的地方。请填写为了达成目标，最少需要操作的次数。 将满足条件的值存储到数组中。遍历数组得到其中的最小值即可。 c++代码123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int count[100]=0,m=0; for(int i=0;i&lt;101;i++) &#123; for(int j=0;j&lt;101;j++)&#123; if(97*i-127*j==1)&#123; count[m++]=i+j; &#125; &#125; &#125; min=count[0]; for(i=0;i&lt;100;i++)&#123; if(count[i]&amp;&amp;count[i]&lt;min)&#123; min=count[i]; &#125; &#125; printf("%4d\n",min);&#125; java代码1234567891011121314151617181920public class md &#123; public static void main(String[] args)&#123; int[] count=new int[100]; int m=0; for(int i=0;i&lt;100;i++)&#123; for(int j=0;j&lt;100;j++)&#123; if(i*97-j*127==1)&#123; count[m++]=i+j; &#125; &#125; &#125; int min=count[0]; for(int k=0;k&lt;100;k++)&#123; if(count[k]&gt;min)&#123; min=count[k]; &#125; &#125; System.out.print(min); &#125;&#125; 结果：97]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python programing c++ Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门]]></title>
    <url>%2F2017%2F10%2F11%2Fpython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142class Car:##类名 def __init__(self): ##方法名 self 为Car对象实例的引用 self.speed = 0 self.odometer = 0 self.time = 0 def say_state(self): print("I'm going &#123;&#125; kph!".format(self.speed)) def accelerate(self): self.speed += 5 def brake(self): self.speed -= 5 def step(self): self.odometer += self.speed self.time += 1 def average_speed(self): return self.odometer / self.timeif __name__ == '__main__': ##入口函数 my_car = Car()##获得对象实例 print("I'm a car!") while True: ##循环语句 action = input("What should I do? [A]ccelerate, [B]rake, " "show [O]dometer, or show average [S]peed?").upper()####字母字符（串）中大小写转换函数--upper() 和 lower() if action not in "ABOS" or len(action) != 1: print("I don't know how to do that") continue if action == 'A': my_car.accelerate() elif action == 'B': my_car.brake() elif action == 'O': print("The car has driven &#123;&#125; kilometers".format(my_car.odometer)) elif action == 'S': print("The car's average speed was &#123;&#125; kph".format(my_car.average_speed()))##&#123;&#125;的内容在format方法中 my_car.step() my_car.say_state() 输出12345678910111213&quot;C:\Program Files\Python36-32\python.exe&quot; C:/Users/15581/PycharmProjects/untitled6/Car.pyI&apos;m a car!What should I do? [A]ccelerate, [B]rake, show [O]dometer, or show average [S]peed?AI&apos;m going 5 kph!What should I do? [A]ccelerate, [B]rake, show [O]dometer, or show average [S]peed?BI&apos;m going 0 kph!What should I do? [A]ccelerate, [B]rake, show [O]dometer, or show average [S]peed?SThe car&apos;s average speed was 2.5 kphI&apos;m going 0 kph!What should I do? [A]ccelerate, [B]rake, show [O]dometer, or show average [S]peed?OThe car has driven 5 kilometersI&apos;m going 0 kph!What should I do? [A]ccelerate, [B]rake, show [O]dometer, or show average [S]peed?]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python programing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_2]]></title>
    <url>%2F2017%2F09%2F23%2F%E5%89%91%E6%8C%87offer_2%2F</url>
    <content type="text"><![CDATA[1.设计一个类，我们只能生成该类的一个实例（Singleton模式） 1.2.解法1：利用静态构造函数1234567891011public sealed class Singleton4 &#123; private Singleton4() &#123; &#125; private static Singleton4 instance = new Singleton4(); public static Singleton4 Instance&#123; get&#123; return instance;&#125; &#125;&#125; 1.3 解法2：实现按需创建实例1234567891011121314151617public sealed class Singleton5 &#123; Singleton5() &#123; &#125; public static Singleton5 Instance&#123; get&#123; return Nested.instance;&#125; &#125; class Nested &#123; static Nested() &#123; &#125; internal satic readonly Singleton5 instance = new Singleto5();&#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[剑指offer_1]]></title>
    <url>%2F2017%2F09%2F22%2F%E5%89%91%E6%8C%87offer_1%2F</url>
    <content type="text"><![CDATA[1.为CMyString添加赋值运算符函数123456789class CMyString&#123;public: CMyString(char* pData=NULL); CMyString(const CMyString&amp; str); ~CMyString(void);private: char* m_pData;&#125; 1.1 解题思路&lt;\h3&gt; 是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例的自身的引用（*this) 是否把传入的参数的类型声明为常量引用 是否释放实例自身已有的内存 是否判断传入的参数和当前实例（*this）是不是同一个实例 1.2经典揭发（初级）123456789CMyString&amp; CMyString::operator=(const CMyString &amp;str)&#123; if(this==&amp;str) return *this; delete []m_pData; m_pData=NULL; m_pData=new char[strlen(str.m_pData)+1]; strcpy(m_pData,str.m_pData); return *this; &#125; 1.3 考虑异常安全的方法（高级）123456789CMyString&amp; CMyString::operator=(const CMyString &amp;str) &#123; if (this!- &amp;str) &#123; CMyString strTemp(str); char* pTemp = strTemp.m_pData; m_pData = pTemp; &#125; return *this;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全排列的时间复杂度]]></title>
    <url>%2F2017%2F09%2F17%2Fn%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E9%9A%8Fn%E5%80%BC%E5%8F%98%E5%8C%96%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package com.example.a15581.myapplication;import java.util.ArrayList;import java.util.Arrays;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.util.Date;import java.util.List;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private Button start; private EditText T1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button start=(Button) findViewById(R.id.btn_start); start.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; int num=4; Date startDate = new Date(System.currentTimeMillis());//开始计时 String[] str = &#123;"1","2","3","4"&#125;; arrange(str, 0, str.length); Date endDate = new Date(System.currentTimeMillis());//结束计时 long diff = endDate.getTime() - startDate.getTime(); String sdiff=String.valueOf(diff); ((EditText) findViewById(R.id.btn_1)).setText("n="+num+"耗时"+sdiff+"ms"); int num2=5; Date startDate2 = new Date(System.currentTimeMillis());//开始计时 String[] str2 = &#123;"1","2","3","4","5"&#125;; arrange(str2, 0, str2.length); Date endDate2 = new Date(System.currentTimeMillis());//结束计时 long diff2 = endDate2.getTime() - startDate2.getTime(); String sdiff2=String.valueOf(diff2); ((EditText) findViewById(R.id.btn_2)).setText("n="+num2+"耗时"+sdiff2+"ms"); int num3=6; Date startDate3 = new Date(System.currentTimeMillis());//开始计时 String[] str3 = &#123;"1","2","3","4","5","6"&#125;; arrange(str3, 0, str3.length); Date endDate3 = new Date(System.currentTimeMillis());//结束计时 long diff3 = endDate3.getTime() - startDate3.getTime(); String sdiff3=String.valueOf(diff3); ((EditText) findViewById(R.id.btn_3)).setText("n="+num3+"耗时"+sdiff3+"ms"); int num4=7; Date startDate4 = new Date(System.currentTimeMillis());//开始计时 String[] str4 = &#123;"1","2","3","4","5","6","7"&#125;; arrange(str4, 0, str4.length); Date endDate4 = new Date(System.currentTimeMillis());//结束计时 long diff4 = endDate4.getTime() - startDate4.getTime(); String sdiff4=String.valueOf(diff4); ((EditText) findViewById(R.id.btn_4)).setText("n="+num4+"耗时"+sdiff4+"ms"); int num5=8; Date startDate5 = new Date(System.currentTimeMillis());//开始计时 String[] str5 = &#123;"1","2","3","4","5","6","7","8"&#125;; arrange(str5, 0, str5.length); Date endDate5 = new Date(System.currentTimeMillis());//结束计时 long diff5 = endDate5.getTime() - startDate5.getTime(); String sdiff5=String.valueOf(diff5); ((EditText) findViewById(R.id.btn_5)).setText("n="+num5+"耗时"+sdiff5+"ms"); int num6=9; Date startDate6 = new Date(System.currentTimeMillis());//开始计时 String[] str6 = &#123;"1","2","3","4","5","6","7","9"&#125;; arrange(str6, 0, str6.length); Date endDate6 = new Date(System.currentTimeMillis());//结束计时 long diff6 = endDate6.getTime() - startDate.getTime(); String sdiff6=String.valueOf(diff6); ((EditText) findViewById(R.id.btn_6)).setText("n="+num6+"耗时"+sdiff6+"ms"); int num7=10; Date startDate7 = new Date(System.currentTimeMillis());//开始计时 String[] str7 = &#123;"1","2","3","4","5","6","7","8","9","10"&#125;; arrange(str7, 0, str7.length); Date endDate7 = new Date(System.currentTimeMillis());//结束计时 long diff7 = endDate7.getTime() - startDate7.getTime(); String sdiff7=String.valueOf(diff7); ((EditText) findViewById(R.id.btn_7)).setText("n="+num7+"耗时"+sdiff7+"ms"); &#125; /** * 交换str数组的 i和 j。 * * @param str * @param i * @param j */ public static void swap(String[] str, int i, int j) &#123; String temp = new String(); temp = str[i]; str[i] = str[j]; str[j] = temp; &#125; /** * 对str数组，，从st到len进行全排列 * * @param str * @param st * @param len */ public static void arrange(String[] str, int st, int len) &#123; int total=0; if (st == len - 1) &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(str[i] + " "); &#125; System.out.println(); total++; &#125; else &#123; for (int i = st; i &lt; len; i++) &#123; swap(str, st, i); arrange(str, st + 1, len); swap(str, st, i); &#125; &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AS关键字]]></title>
    <url>%2F2017%2F09%2F16%2FAS%E5%B8%83%E5%B1%80%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[计算器思路：1.布局2.声明变量 找到控件地址 设置监听器 处理逻辑 match_parent 是指“填充满”父容器 wrap_content 根据容器内的东西决定组件的大小 android:gravity=”center” bottom|right orientation vertical Bottom android:gravity=”center_vertical” 这个的意思是指 限定它里面的内容要垂直居中显示。 android:layout_gravity=”center_vertical”，这个是指它的位置是相对于它父亲的垂直居中。 substring(a,b) 从一串字符中挑出第a个到第b个------ 布局··123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:gravity="center" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.example.a15581.myapplication.MainActivity"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="80sp" android:gravity="center"&gt; &lt;EditText android:layout_width="350dip" android:layout_height="100dip" android:gravity="bottom|right" android:text="0" android:textSize="20sp" android:maxLength="25" android:editable="false" android:id="@+id/showview" /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="500sp" android:gravity="center_vertical" android:orientation="vertical" android:layout_alignParentTop="true" android:layout_alignParentLeft="true" android:layout_alignParentStart="true"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_clean" android:text="C" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_delet" android:text="DEL" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_div" android:text="/" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_mulitiply" android:text="*" android:textSize="30sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="0dp" android:orientation="horizontal"&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_7" android:text="7" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_8" android:text="8" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_9" android:text="9" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_minus" android:text="-" android:textSize="30sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="0dp" android:orientation="horizontal"&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_4" android:text="4" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_5" android:text="5" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_6" android:text="6" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_add" android:text="+" android:textSize="30sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="0dp" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_1" android:text="1" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_2" android:text="2" android:textSize="30sp"/&gt; &lt;Button android:layout_width="80dp" android:layout_height="80dp" android:id="@+id/btn_3" android:text="3" android:textSize="30sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:layout_width="120dp" android:layout_height="80dp" android:text="0" android:textSize="30dp" android:id="@+id/btn_0"/&gt; &lt;Button android:layout_width="120dp" android:layout_height="80dp" android:textSize="30dp" android:text="." android:id="@+id/btn_point"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;Button android:layout_width="80dp" android:layout_height="160dp" android:id="@+id/btn_equal" android:text="=" android:textSize="30sp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.example.a15581.myapplication;import android.renderscript.Double2;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; //声明变量 private Button btn_0; private Button btn_1; private Button btn_2; private Button btn_3; private Button btn_4; private Button btn_5; private Button btn_6; private Button btn_7; private Button btn_8; private Button btn_9; private Button btn_point;// 小数点 private Button btn_divide;// 除以 private Button btn_multiply;// 乘以 private Button btn_minus;// 减去 private Button btn_pluse;// 加 private Button btn_equal;// 等于 private Button btn_clear; //清空 private Button btn_del; //取消 private EditText et_showview; //输入框 private double dou = 0; //接收结果 private boolean flag;//标志服，判断是否清空编辑框 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; public void initView()&#123; flag=true; //找到按钮地址 btn_0=(Button) findViewById(R.id.btn_0); btn_1 = (Button) findViewById(R.id.btn_1); btn_2 = (Button) findViewById(R.id.btn_2); btn_3 = (Button) findViewById(R.id.btn_3); btn_4 = (Button) findViewById(R.id.btn_4); btn_5 = (Button) findViewById(R.id.btn_5); btn_6 = (Button) findViewById(R.id.btn_6); btn_7 = (Button) findViewById(R.id.btn_7); btn_8 = (Button) findViewById(R.id.btn_8); btn_9 = (Button) findViewById(R.id.btn_9); btn_point = (Button) findViewById(R.id.btn_point);// 小数点 btn_divide = (Button) findViewById(R.id.btn_div);// 除以 btn_multiply = (Button) findViewById(R.id.btn_mulitiply);// 乘以 btn_minus = (Button) findViewById(R.id.btn_minus);// 减去 btn_pluse = (Button) findViewById(R.id.btn_add);// 加 btn_equal = (Button) findViewById(R.id.btn_equal);// 等于 btn_clear = (Button) findViewById(R.id.btn_clean); btn_del = (Button) findViewById(R.id.btn_delet); et_showview = (EditText) findViewById(R.id.showview); //设置监听器 btn_0.setOnClickListener(this); btn_1.setOnClickListener(this); btn_2.setOnClickListener(this); btn_3.setOnClickListener(this); btn_4.setOnClickListener(this); btn_5.setOnClickListener(this); btn_6.setOnClickListener(this); btn_7.setOnClickListener(this); btn_8.setOnClickListener(this); btn_9.setOnClickListener(this); btn_pluse.setOnClickListener(this); btn_minus.setOnClickListener(this); btn_multiply.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_del.setOnClickListener(this); btn_clear.setOnClickListener(this); btn_point.setOnClickListener(this); btn_equal.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; String str=et_showview.getText().toString(); switch (v.getId())&#123; case R.id.btn_0: case R.id.btn_1: case R.id.btn_2: case R.id.btn_3: case R.id.btn_4: case R.id.btn_5: case R.id.btn_6: case R.id.btn_7: case R.id.btn_8: case R.id.btn_9: if(str.charAt(0)==' ')&#123; et_showview.setText(((Button) v).getText());&#125; else if(str.charAt(0)=='0'&amp;&amp;!str.contains(" ")&amp;&amp;!str.contains("."))&#123; et_showview.setText(((Button) v).getText()); &#125; else et_showview.setText(str+((Button) v).getText()); break; case R.id.btn_point: if(str=="0")&#123; et_showview.setText("0"+"."); &#125;else if(str.contains(".")||str.charAt(str.length()-1)==' ')&#123; et_showview.setText(str); &#125;else &#123; et_showview.setText(str+"."); &#125; break; case R.id.btn_add: case R.id.btn_mulitiply: case R.id.btn_div: case R.id.btn_minus: if(str.charAt(str.length()-1)==' ')&#123; et_showview.setText(str.substring(0,str.length()-3)+" "+((Button) v).getText());//返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 &#125;else &#123; et_showview.setText(str+" "+((Button) v).getText()); &#125; break; case R.id.btn_delet: if(str.length()==1)&#123; et_showview.setText("0"); &#125;else&#123; et_showview.setText(str.substring(0,str.length()-1)); &#125; break; case R.id.btn_clean: et_showview.setText("0"); break; case R.id.btn_equal: getResult(); break; default: break; &#125; &#125; private void getResult()&#123; flag=false; String result=et_showview.getText().toString(); if(!result.contains(" "))&#123; et_showview.setText("呵呵"); &#125; else &#123; String str1 = result.substring(0, result.indexOf(" "));//第一个数字 String op = result.substring(result.indexOf(" ") + 1, result.indexOf(" ") + 2);//操作符 String str2 = result.substring(result.indexOf(" ") + 3);//第二个数字 if (!str2.equals("")) &#123; Double d1 = Double.parseDouble(str1); Double d2 = Double.parseDouble(str2); if (op.equals("+")) &#123; dou = d1 + d2; &#125; else if (op.equals("-")) &#123; dou = d1 - d2; &#125; else if (op.equals("*")) &#123; dou = d1 * d2; &#125; else if (op.equals("/")) &#123; if (d1 == 0 &amp;&amp; d2 != 0) &#123; dou = 0; &#125; else if (d2 == 0) &#123; dou = 0; Toast.makeText(MainActivity.this, "There is a error", Toast.LENGTH_SHORT).show(); &#125; else &#123; dou = d1 / d2; &#125; &#125; double media = dou - (int) dou; if (media &gt; 0) &#123; String last = String.valueOf(dou); et_showview.setText(last); &#125; else &#123; if (dou &gt; 9999999999999d) &#123; et_showview.setText("over failed"); &#125; else &#123; int inter = (int) dou; String lasr = String.valueOf(inter); et_showview.setText(inter); &#125; &#125; &#125; else &#123; et_showview.setText(result); Toast.makeText(MainActivity.this,"finished",Toast.LENGTH_SHORT ); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[网页计算器]]></title>
    <url>%2F2017%2F09%2F13%2F%E7%BD%91%E9%A1%B5%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;html&gt;&lt;body&gt;&lt;div id="calculator"&gt; &lt;div class="LOGO"&gt; &lt;span class="name"&gt;简单的计算器&lt;/span&gt; &lt;span class="verson"&gt;@walker&lt;/span&gt; &lt;/div&gt; &lt;div id="shuRu"&gt; &lt;!--screen输入栏--&gt; &lt;div class="screen"&gt; &lt;input type="text" id="screenName" name="screenName" class="screen"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="keys"&gt; &lt;!-- j --&gt; &lt;!--第一排--&gt; &lt;input type="button" id="7" onclick="jsq(this.id)" value="7" class="buttons"&gt; &lt;input type="button" id="8" onclick="jsq(this.id)" value="8" class="buttons"&gt; &lt;input type="button" id="9" onclick="jsq(this.id)" value="9" class="buttons"&gt; &lt;input type="button" id="Back" onclick="tuiGe()" value="Back" class="buttons"&gt; &lt;input type="button" id="C" onclick="clearNum()" value="C" class="buttons" style="margin-right:0px"&gt; &lt;!--第二排--&gt; &lt;input type="button" id="4" onclick="jsq(this.id)" value="4" class="buttons"&gt; &lt;input type="button" id="5" onclick="jsq(this.id)" value="5" class="buttons"&gt; &lt;input type="button" id="6" onclick="jsq(this.id)" value="6" class="buttons"&gt; &lt;input type="button" id="*" onclick="jsq(this.id)" value="X" class="buttons"&gt; &lt;input type="button" id="/" onclick="jsq(this.id)" value="/" class="buttons" style="margin-right:0px"&gt; &lt;!--第三排--&gt; &lt;input type="button" id="1" onclick="jsq(this.id)" value="1" class="buttons"&gt; &lt;input type="button" id="2" onclick="jsq(this.id)" value="2" class="buttons"&gt; &lt;input type="button" id="3" onclick="jsq(this.id)" value="3" class="buttons"&gt; &lt;input type="button" id="+" onclick="jsq(this.id)" value="+" class="buttons"&gt; &lt;input type="button" id="-" onclick="jsq(this.id)" value="-" class="buttons" style="margin-right:0px"&gt; &lt;!--第四排--&gt; &lt;input type="button" id="0" onclick="jsq(this.id)" value="0" class="buttons"&gt; &lt;input type="button" id="00" onclick="jsq(this.id)" value="00" class="buttons"&gt; &lt;input type="button" id="." onclick="jsq(this.id)" value="." class="buttons"&gt; &lt;input type="button" id="%" onclick="jsq(this.id)" value="%" class="buttons"&gt; &lt;input type="button" id="eva" onclick="eva()" value="=" class="buttons" style="margin-right:0px"&gt; &lt;/div&gt; &lt;div class="footer"&gt; &lt;span class="aside"&gt;欢迎使用JavaScript计算器&lt;/span&gt; &lt;span class="link"&gt; &lt;a href="#" title="声明" target="_blank"&gt;反馈&lt;/a&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var num = 0; // 定义第一个输入的数据 function jsq(num) &#123; //获取当前输入 if(num=="%")&#123; document.getElementById('screenName').value=Math.round(document.getElementById('screenName').value)/100; &#125;else&#123; document.getElementById('screenName').value += document.getElementById(num).value; &#125; &#125; function eva() &#123; //计算输入结果 document.getElementById("screenName").value = eval(document.getElementById("screenName").value); &#125; function clearNum() &#123; //清0 document.getElementById("screenName").value = null; document.getElementById("screenName").focus(); &#125; function tuiGe() &#123; //退格 var arr = document.getElementById("screenName"); arr.value = arr.value.substring(0, arr.value.length - 1); &#125;&lt;/script&gt;&lt;style&gt;/*Basic reset*/*&#123; margin:0; padding:0; box-sizing: border-box; font: 14px Arial,sans-serif;&#125;html&#123; height:100%; background-color:lightslategrey;&#125;#calculator&#123; margin: 15px auto; width:330px; height:400px; border: 1px solid lightgray; background-color:darkgrey; padding:15px;&#125;/*LOGO*/.LOGO&#123; height:20px;&#125;.LOGO .name&#123; float:left; line-height:30px;&#125;.LOGO .verson&#123; float:right; line-height:30px;&#125;/*screen*/#shuRu&#123; margin-top:15px;&#125;.screen&#123; margin-top:5px; width:300px; height:40px; text-align: right; padding-right:10px; font-size:20px;&#125;#keys&#123; border:1px solid lightgray; height:223px; margin-top:25px; padding:8px;&#125;#keys .last&#123; margin-right:0px;&#125;.footer&#123; margin-top:20px; height:20px;&#125;.footer .link&#123; float:right;&#125;#keys .buttons&#123; float:left; width: 42px; height: 36px; text-align:center; background-color:lightgray; margin: 0 17px 20px 0;&#125;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>课后习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形化找最短两点]]></title>
    <url>%2F2017%2F09%2F13%2F%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%AF%BB%E6%89%BE%E6%9C%80%E7%9F%AD%E4%B8%A4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031#include&lt;graphics.h&gt;#include&lt;conio.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main() &#123; //画点 int x[30], y[30]; for (int i = 0; i &lt; 30; i++) &#123; x[i] = rand() % (60 - 10 + 1) + 10; y[i]= rand() % (60 - 10 + 1) + 10; initgraph(500, 500); setbkcolor(0); putpixel(x[i], y[i], 30); &#125; //画线 int L = 10000; for (int i = 0; i &lt; 30; i++) &#123; for (int j = 0; j &lt; 30; i++) &#123; Line(x[i], y[i], x[j], y[j]); int s = sqrt((x[i] * x[i] - x[j] * x[j]) + (y[i] * y[i] - y[j] * y[j])); if (s &lt; L&amp;&amp;s != 0) L = s; else clearLine(x[i], y[i], x[j], y[j]); &#125; &#125; getch(); closegraph();&#125;]]></content>
      <tags>
        <tag>课后习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS运行java程序]]></title>
    <url>%2F2017%2F09%2F12%2FAS%E8%BF%90%E8%A1%8CJAVA%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[当我们装了Android Studio 学习安卓开发的时候，难免会要学习java，这时候，难道在重新装一个编译器吗？不需要，我们直接用 Android Studio 就可以。 1、新建一个空项目，选择红色项目 2。File —–&gt; new —–&gt; new Module… 然后弹出一个框 在more module 里面选择java Library 。一路next。 3、编写相应的代码，记得把上面的第一行注释掉 4、配置，点击 run -&gt; edit configuration，在新弹出的窗口的上方点击绿色的加号按钮，选择“application”，再在右边的窗口添加信息。 5、最后在自己编写代码的界面右键，选择“run class.main()”,或者用快捷键“ctr+shift+F10”进行运行。结果如下图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库知识点]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[要解决的问题 解决方案 如何描述这些数据 E-R模型 关系数据模型 如何创建这些模型和存储这些数据 关系代数 SQL 应用程序如何访问数据库 数据库开发技术 如何提高大量数据访问效率 数据库优化技术 那些人可以操作那些数据 安全性控制 如何保证数据的正确有效 完整性控制 多人如何操作同一数据 并发控制 出现故障 数据恢复]]></content>
      <tags>
        <tag>课后习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与设计]]></title>
    <url>%2F2017%2F09%2F05%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[求根号m1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; double m; cin &gt;&gt; m; cout &lt;&lt; sqrt(m); getchar();&#125;double ABS(double x)&#123; return x &lt; 0 ? x*-1 : x;&#125;double sqrt(double m) &#123; double g = m; while ( ABS(g*g - m )&gt; 0.0000001) &#123; g = (g + m / g) / 2; &#125; return g;&#125; 最大公约数12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main()&#123; int m, n,r; cin &gt;&gt; m &gt;&gt; n; while (n!=0) &#123; r = m%n; m = n; n = r; &#125; cout &lt;&lt; m; system("pause");&#125; gcd(m,n) min{m,n}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdlib&gt;#include &lt;stack&gt; #include&lt;iostream&gt;using namespace std;int get_prime(int x)&#123; int tmp = 0; int i = 0; int j = 0; int k = 0, d; int a[10] = &#123; 0 &#125;; d = x; tmp = d; //遍历2到d中的所有数，先判断该数是否为素数，再判断该数是否为d的因数，两个条件满足则将其存入数组中；否则进行下一次循环* / for (i = 2; i &lt;= d; i++) &#123; //判断该数是否为素数，若非素数则进行下一次循环 for (j = 2; j&lt;i; j++) &#123; if (i % j == 0) &#123; break; &#125; &#125; //判断i是否为d的因数，如果是则将i存入临时数组，并更新d的值，此处用while是为了满足一个整数中有几个相同的因数的情况 while (d % i == 0) &#123; a[k++] = i; d = d / i; &#125; &#125; //分三段将该数组打印到终端 printf("%d=", tmp); for (i = 0; i&lt;k - 1; i++) &#123; printf("%d*", a[i]); &#125; printf("%d\n", a[k - 1]); return 0;&#125;int get_comment_prime()&#123; return 0;&#125;int main()&#123; int m, n; printf("please input a data:"); cin &gt;&gt; m&gt;&gt;n; get_prime(m); get_prime(n); cout&lt;&lt;get_comment_prime(); system("pause");&#125;]]></content>
      <tags>
        <tag>课后习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取猫眼top100]]></title>
    <url>%2F2017%2F08%2F30%2F%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BCtop100%2F</url>
    <content type="text"><![CDATA[学习目的：了解爬虫工作原理 3部分1.获取页面内容html代码12345678910111213141516171819import requestsfrom requests.exceptions import RequestExceptiondef get_one_page(url): try: response=requests.get(url) if response.status_code==200: return response.text return None except RequestException: return Nonedef main(): url='http://maoyan.com/board/4?' html=get_one_page(url) print (html)if __name__ == '__main__': main() 结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061"C:\Program Files\Python36-32\python.exe" C:/Users/15581/PycharmProjects/maoyantop100/spider.py&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="viewport" content="width=device-width"&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;link rel="shortcut icon" href="http://ms0.meituan.com/braavos/static/logo.png"&gt;&lt;title&gt;猫眼访问控制&lt;/title&gt;&lt;style&gt;*&#123; margin: 0; padding: 0; box-sizing: border-box;&#125;html, body&#123; text-align: center; width: 100%; max-width: 375px; margin: auto;&#125;header h3&#123; margin: 20px; font-family: monospace;&#125;footer&#123; margin-top: 20px; text-align: center;&#125;footer a &#123; font-size: 14px;&#125;@media screen and (max-width: 768px)&#123; body&#123; text-align: left !important; &#125; main&#123; width: 95%; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;!-- &lt;h1&gt;MaoYan Access Control System&lt;/h1&gt; --&gt; &lt;h3&gt; &lt;p&gt;很抱歉，您的访问被禁止了&lt;/p&gt; &lt;p&gt;如果您认为我们出错了，请联系我们 &lt;a href="mailto:oceanus.feedback@maoyan.com"&gt;oceanus.feedback@maoyan.com&lt;/a&gt;&lt;/p&gt; &lt;/h3&gt; &lt;/header&gt; &lt;footer&gt; &lt;a href="https://maoyan.com"&gt;猫眼电影&lt;/a&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;Process finished with exit code 0 2.筛选有用代码（正则表达式）12345678910111213141516171819202122232425262728import requestsimport refrom requests.exceptions import RequestExceptiondef get_one_page(url): try: response=requests.get(url) if response.status_code==200: return response.text return None except RequestException: return None #正则表达式 根据需要的内容写 这些目前看不懂的东西def parse_one_page(html):#.*?匹配任意字符串 隔开或者想要的目标结果 pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a' +'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*/)&lt;/p&gt;.*?releasetime&gt;(&gt;*?)&lt;/p&gt;' +'&gt;*?integer"&gt;(&gt;*?)&lt;/i&gt;&gt;*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S)#让.匹配换行符 item=re.findall(pattern,html) print (items)def main(): url='http://maoyan.com/board/4?' html=get_one_page(url) parse_one_page(html)if __name__ == '__main__': main() 结果1234"C:\Program Files\Python36-32\python.exe" C:/Users/15581/PycharmProjects/maoyantop100/choose.py[]Process finished with exit code 0 3.将筛选后的代码变成字典形式并以文本输出到文件12345678910111213141516171819202122232425262728293031323334353637383940414243import jsonimport requestsimport refrom requests.exceptions import RequestExceptiondef get_one_page(url): try: response=requests.get(url) if response.status_code==200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a' +'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*/)&lt;/p&gt;.*?releasetime&gt;(&gt;*?)&lt;/p&gt;' +'&gt;*?integer"&gt;(&gt;*?)&lt;/i&gt;&gt;*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern,html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2], 'actor': item[3].strip()[3:], 'time': item[4].strip()[5:], 'score': item[5]+item[6] &#125;def write_to_file(content): with open('result.txt','a',encoding='utf-8')as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') f.close()def main(): url='http://maoyan.com/board/4?' html=get_one_page(url) for item in parse_one_page(html): print (item) write_to_file(item)if __name__ == '__main__': main() 4.使用循环爬取多个页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import jsonimport requestsimport refrom multiprocessing import Poolfrom requests.exceptions import RequestExceptiondef get_one_page(url): try: response=requests.get(url) if response.status_code==200: return response.text return None except RequestException: return Nonedef parse_one_page(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(\d*)&lt;/i&gt;.*?data-src="(.*?)".*?name"&gt;&lt;a' +'.*?&gt;(.*?)&lt;/a&gt;.*?star"&gt;(.*/)&lt;/p&gt;.*?releasetime&gt;(&gt;*?)&lt;/p&gt;' +'&gt;*?integer"&gt;(&gt;*?)&lt;/i&gt;&gt;*?fraction"&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items = re.findall(pattern,html) for item in items: yield &#123; 'index': item[0], 'image': item[1], 'title': item[2], 'actor': item[3].strip()[3:], 'time': item[4].strip()[5:], 'score': item[5]+item[6] &#125;def write_to_file(content): with open('result.txt','a',encoding='utf-8')as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') f.close()def main(offset): url='http://maoyan.com/board/4?offset='+str(offset) html=get_one_page(url) for item in parse_one_page(html): print (item) write_to_file(item)if __name__ == '__main__': for i in range(10): main(i*10) ##多进程实现 ##pool=Pool() ##pool.map(main，[i*10 for i in range(10)]）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django的MTV模式]]></title>
    <url>%2F2017%2F08%2F30%2FDjango%E7%9A%84MTV%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[##学习目的：建立本地站点 MTV=model templement view pip install Django (前提是配置好python的pip工具 在博客内搜索pip 即可得教程)]]></content>
  </entry>
  <entry>
    <title><![CDATA[semmantical UI的使用]]></title>
    <url>%2F2017%2F08%2F29%2Fsemantical%20UI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学习目的：1.熟练使用semantical官网所提供的样式 2.了解常用关键词如inverted vertical等 div的嵌套 3.semantical UI 非常语义话 如div class=”ui big star segment”&gt; 就画啦一个大星星 1.简而言之：别人css javascript theme写好啦等你用。 2.别人的样式semantic.css 区域块样式引用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;first web&lt;/title&gt; &lt;link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="ui inverted vertical segment"&gt;//样式的引用 inverted 反转（颜色） vertical 垂直（不同块间没有间隙） &lt;div class="ui image"&gt;//通常用div标签表示区域块 &lt;img src="images/banner.jpg" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ui vertical segment"&gt; &lt;div class="ui container segment"&gt; &lt;div class="ui blue right ribbon label"&gt; life &lt;/div&gt; &lt;h1 class="ui header"&gt;First web&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. &lt;/p&gt; &lt;button type="button" name="button" class="ui inverted blue button"&gt;Read more&lt;/button&gt; &lt;/div&gt; &lt;div class="ui container segment"&gt; &lt;div class="ui red right ribbon label"&gt; tech &lt;/div&gt; &lt;h1 class="ui header"&gt;First web&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. &lt;/p&gt; &lt;button type="button" name="button" class="ui inverted blue button"&gt;Read more&lt;/button&gt; &lt;/div&gt; &lt;div class="ui container segment"&gt; &lt;div class="ui teal right ribbon label"&gt; news &lt;/div&gt; &lt;h1 class="ui header"&gt;First web&lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. &lt;/p&gt; &lt;button type="button" name="button" class="ui inverted blue button"&gt;Read more&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ui inverted vertical very padded segment"&gt; Mugglecoding® &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 画神盾1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="ui inverted red circular segment"&gt;//非常语义化的semantical UI &lt;div class="ui circular segment"&gt; &lt;div class="ui inverted red circular segment"&gt; &lt;i class="circular inverted blue big star icon"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.了解网格grid分布 及柱形分布column123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;First landing page&lt;/title&gt; &lt;link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="ui fixed inverted menu"&gt;//semantical 的UI menu &lt;a href="#" class="item"&gt;Home&lt;/a&gt;//带有链接的按钮通常用标签a表示 &lt;a href="#" class="item"&gt;About&lt;/a&gt; &lt;a href="#" class="item"&gt;Other&lt;/a&gt; &lt;/div&gt; &lt;div class="ui vertical basic segment"&gt; &lt;div class="ui image"&gt; &lt;img src="images/banner.jpg" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ui vertical basic segment"&gt; &lt;div class="ui grid"&gt;//grid网格分布 区域块中存在某种比例 &lt;div class="ten wide column"&gt;//10个柱形区域 &lt;div class="ui image"&gt; &lt;img src="images/devices2.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="six wide column"&gt; 6个柱形区域 &lt;h2 class="ui header"&gt; &lt;i class="icon star"&gt;&lt;/i&gt;//&lt;i&gt; 标签显示斜体文本效果 This ia a title &lt;/h2&gt; &lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ui vertical very padded inverted segment"&gt;//padded内聚 文字距离区域块边缘的多少 &lt;div class="ui grid"&gt;a &lt;div class="four wide column"&gt; &lt;div class="ui vertical inverted text menu"&gt; &lt;div class="item"&gt; &lt;h3 class="ui inverted header"&gt;Company&lt;/h3&gt; &lt;/div&gt; &lt;div class="item"&gt; Address : CN &lt;/div&gt; &lt;div class="item"&gt; Tel : 010-66666 &lt;/div&gt; &lt;div class="item"&gt; Fax : 010-66666 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="four wide column"&gt; &lt;div class="ui vertical inverted text menu"&gt; &lt;div class="item"&gt; &lt;h3 class="ui inverted header"&gt;Company&lt;/h3&gt; &lt;/div&gt; &lt;div class="item"&gt; Address : CN &lt;/div&gt; &lt;div class="item"&gt; Tel : 010-66666 &lt;/div&gt; &lt;div class="item"&gt; Fax : 010-66666 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="four wide column"&gt; &lt;div class="ui vertical inverted text menu"&gt; &lt;div class="item"&gt; &lt;h3 class="ui inverted header"&gt;Company&lt;/h3&gt; &lt;/div&gt; &lt;div class="item"&gt; Address : CN &lt;/div&gt; &lt;div class="item"&gt; Tel : 010-66666 &lt;/div&gt; &lt;div class="item"&gt; Fax : 010-66666 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="four wide column"&gt; &lt;div class="ui vertical inverted text menu"&gt; &lt;div class="item"&gt; &lt;h3 class="ui inverted header"&gt;Company&lt;/h3&gt; &lt;/div&gt; &lt;div class="item"&gt; Address : CN &lt;/div&gt; &lt;div class="item"&gt; Tel : 010-66666 &lt;/div&gt; &lt;div class="item"&gt; Fax : 010-66666 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 对semantic较复杂的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"&gt; &lt;title&gt;Apple(中国)-非官方网站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 菜单部分开始 --&gt; &lt;div class="ui inverted fixed fitted borderless fluid nine item menu"&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img class="" src="images/appleicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt;Mac&lt;/a&gt; &lt;a href="#" class="item"&gt;iPad&lt;/a&gt; &lt;a href="#" class="item"&gt;iPhone&lt;/a&gt; &lt;a href="#" class="item"&gt;Watch&lt;/a&gt; &lt;a href="#" class="item"&gt;Music&lt;/a&gt; &lt;a href="#" class="item"&gt;技术支持&lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img class="" src="images/searchicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img class="" src="images/buyicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 菜单部分结束 --&gt; &lt;!-- 导航图部分开始 --&gt; &lt;div class="ui secondary vertical basic segment "&gt; &lt;div class="ui banner image"&gt; &lt;img src="images/banner.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 导航图部分结束 --&gt; &lt;!-- 4张小图部分开始 --&gt; &lt;div class="ui secondary vertical basic segment "&gt; &lt;div class="ui fitted text menu"&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img1.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img2.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img3.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img4.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4张小图部分结束 --&gt; &lt;!-- 页尾部分开始 --&gt; &lt;div class="ui vertical secondary very padded segment"&gt; &lt;div class="ui container"&gt; &lt;div class="sub header"&gt; 双镜头摄像头仅于 iPhone 7 Plus 提供。亮黑色外观仅于 128GB 及以上存储容量的机型提供。 &lt;/div&gt; &lt;div class="ui divider"&gt;&lt;/div&gt; &lt;div class="ui five column grid"&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; 查找零售店 &lt;/a&gt; &lt;a class="item"&gt; iPad &lt;/a&gt; &lt;a class="item"&gt; iPhone &lt;/a&gt; &lt;a class="item"&gt; Watch &lt;/a&gt; &lt;a class="item"&gt; iPod &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; 查找零售店 &lt;/a&gt; &lt;a class="item"&gt; iPad &lt;/a&gt; &lt;a class="item"&gt; iPhone &lt;/a&gt; &lt;a class="item"&gt; Watch &lt;/a&gt; &lt;a class="item"&gt; iPod &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; 查找零售店 &lt;/a&gt; &lt;div class="item"&gt; &lt;!-- nothing here just want a litte space XD--&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h4&gt;商务应用&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; Apple 与商务 &lt;/a&gt; &lt;a class="item"&gt; 商务选购 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; 查找零售店 &lt;/a&gt; &lt;div class="item"&gt; &lt;!-- nothing here just want a litte space XD--&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;h4&gt;商务应用&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; Apple 与商务 &lt;/a&gt; &lt;a class="item"&gt; 商务选购 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt; 查找零售店 &lt;/a&gt; &lt;a class="item"&gt; iPad &lt;/a&gt; &lt;a class="item"&gt; iPhone &lt;/a&gt; &lt;a class="item"&gt; Watch &lt;/a&gt; &lt;a class="item"&gt; iPod &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾部分结束 --&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[coolweather5]]></title>
    <url>%2F2017%2F08%2F17%2FCoolweather5%2F</url>
    <content type="text"><![CDATA[学习目的:1.将天气显示到界面上 首先在Utility类中添加解析JSON数据的方法 12345678910111213141516171819public class Utility &#123; //... /** * 将返回的JSON数据解析成Weather实体类 */ public static Weather handleWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray("HeWeather"); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; handleWeatherResponse()方法通过jsonObject jsonArray将天气主体内容解析出来 如下：12345678&#123; "status"："ok", "basic":&#123;&#125;, "aqi"：&#123;&#125;, "now":&#123;&#125;, "suggestion":&#123;&#125;, "daily_forecast":[]&#125; 按照上面数据格式定义的GSON实体类，只需通过fromjson()直接将JSON数据转换成weather对象。 接下来 在活动中请求天气数据 以及将数据展示在界面上。修改WeatherAcivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package com.coolweather.android;import android.content.Intent;import android.content.SharedPreferences;import android.graphics.Color;import android.os.Build;import android.os.Bundle;import android.preference.PreferenceManager;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v4.widget.SwipeRefreshLayout;import android.support.v7.app.AppCompatActivity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.ScrollView;import android.widget.TextView;import android.widget.Toast;import com.bumptech.glide.Glide;import com.coolweather.android.gson.Forecast;import com.coolweather.android.gson.Weather;import com.coolweather.android.service.AutoUpdateService;import com.coolweather.android.util.HttpUtil;import com.coolweather.android.util.Utility;import java.io.IOException;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Response;public class WeatherActivity extends AppCompatActivity &#123; public DrawerLayout drawerLayout; public SwipeRefreshLayout swipeRefresh; private ScrollView weatherLayout; private Button navButton; private TextView titleCity; private TextView titleUpdateTime; private TextView degreeText; private TextView weatherInfoText; private LinearLayout forecastLayout; private TextView aqiText; private TextView pm25Text; private TextView comfortText; private TextView carWashText; private TextView sportText; private ImageView bingPicImg; private String mWeatherId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &gt;= 21) &#123; View decorView = getWindow().getDecorView(); decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; setContentView(R.layout.activity_weather); // 初始化各控件 bingPicImg = (ImageView) findViewById(R.id.bing_pic_img); weatherLayout = (ScrollView) findViewById(R.id.weather_layout); titleCity = (TextView) findViewById(R.id.title_city); titleUpdateTime = (TextView) findViewById(R.id.title_update_time); degreeText = (TextView) findViewById(R.id.degree_text); weatherInfoText = (TextView) findViewById(R.id.weather_info_text); forecastLayout = (LinearLayout) findViewById(R.id.forecast_layout); aqiText = (TextView) findViewById(R.id.aqi_text); pm25Text = (TextView) findViewById(R.id.pm25_text); comfortText = (TextView) findViewById(R.id.comfort_text); carWashText = (TextView) findViewById(R.id.car_wash_text); sportText = (TextView) findViewById(R.id.sport_text); swipeRefresh = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh); swipeRefresh.setColorSchemeResources(R.color.colorPrimary); drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); navButton = (Button) findViewById(R.id.nav_button); SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this); String weatherString = prefs.getString("weather", null); if (weatherString != null) &#123; // 有缓存时直接解析天气数据 Weather weather = Utility.handleWeatherResponse(weatherString); mWeatherId = weather.basic.weatherId; showWeatherInfo(weather); &#125; else &#123; // 无缓存时去服务器查询天气 mWeatherId = getIntent().getStringExtra("weather_id"); weatherLayout.setVisibility(View.INVISIBLE); requestWeather(mWeatherId); &#125; swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; requestWeather(mWeatherId); &#125; &#125;); navButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; drawerLayout.openDrawer(GravityCompat.START); &#125; &#125;); String bingPic = prefs.getString("bing_pic", null); if (bingPic != null) &#123; Glide.with(this).load(bingPic).into(bingPicImg); &#125; else &#123; loadBingPic(); &#125; &#125; /** * 根据天气id请求城市天气信息。 */ public void requestWeather(final String weatherId) &#123; String weatherUrl = "http://guolin.tech/api/weather?cityid=" + weatherId + "&amp;key=bc0418b57b2d4918819d3974ac1285d9"; HttpUtil.sendOkHttpRequest(weatherUrl, new Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; final String responseText = response.body().string(); final Weather weather = Utility.handleWeatherResponse(responseText); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (weather != null &amp;&amp; "ok".equals(weather.status)) &#123; SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(WeatherActivity.this).edit(); editor.putString("weather", responseText); editor.apply(); mWeatherId = weather.basic.weatherId; showWeatherInfo(weather); &#125; else &#123; Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show(); &#125; swipeRefresh.setRefreshing(false); &#125; &#125;); &#125; @Override public void onFailure(Call call, IOException e) &#123; e.printStackTrace(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(WeatherActivity.this, "获取天气信息失败", Toast.LENGTH_SHORT).show(); swipeRefresh.setRefreshing(false); &#125; &#125;); &#125; &#125;); loadBingPic(); &#125; /** * 处理并展示Weather实体类中的数据。 */ private void showWeatherInfo(Weather weather) &#123; String cityName = weather.basic.cityName; String updateTime = weather.basic.update.updateTime.split(" ")[1]; String degree = weather.now.temperature + "℃"; String weatherInfo = weather.now.more.info; titleCity.setText(cityName); titleUpdateTime.setText(updateTime); degreeText.setText(degree); weatherInfoText.setText(weatherInfo); forecastLayout.removeAllViews(); for (Forecast forecast : weather.forecastList) &#123; View view = LayoutInflater.from(this).inflate(R.layout.forecast_item, forecastLayout, false); TextView dateText = (TextView) view.findViewById(R.id.date_text); TextView infoText = (TextView) view.findViewById(R.id.info_text); TextView maxText = (TextView) view.findViewById(R.id.max_text); TextView minText = (TextView) view.findViewById(R.id.min_text); dateText.setText(forecast.date); infoText.setText(forecast.more.info); maxText.setText(forecast.temperature.max); minText.setText(forecast.temperature.min); forecastLayout.addView(view); &#125; if (weather.aqi != null) &#123; aqiText.setText(weather.aqi.city.aqi); pm25Text.setText(weather.aqi.city.pm25); &#125; String comfort = "舒适度：" + weather.suggestion.comfort.info; String carWash = "洗车指数：" + weather.suggestion.carWash.info; String sport = "运行建议：" + weather.suggestion.sport.info; comfortText.setText(comfort); carWashText.setText(carWash); sportText.setText(sport); weatherLayout.setVisibility(View.VISIBLE); Intent intent = new Intent(this, AutoUpdateService.class); startService(intent); &#125;&#125; 接下来，如何从省市列表跳转到天气界面修改ChooseAreaFragment12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.coolweather.android;import android.app.ProgressDialog;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.ListView;import android.widget.TextView;import android.widget.Toast;import com.coolweather.android.db.City;import com.coolweather.android.db.County;import com.coolweather.android.db.Province;import com.coolweather.android.util.HttpUtil;import com.coolweather.android.util.Utility;import org.litepal.crud.DataSupport;import java.io.IOException;import java.util.ArrayList;import java.util.List;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Response;public class ChooseAreaFragment extends Fragment &#123; //... @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (currentLevel == LEVEL_PROVINCE) &#123; selectedProvince = provinceList.get(position); queryCities(); &#125; else if (currentLevel == LEVEL_CITY) &#123; selectedCity = cityList.get(position); queryCounties(); &#125; else if (currentLevel == LEVEL_COUNTY) &#123; String weatherId = countyList.get(position).getWeatherId(); if (getActivity() instanceof MainActivity) &#123; Intent intent = new Intent(getActivity(), WeatherActivity.class); intent.putExtra("weather_id", weatherId); startActivity(intent); getActivity().finish(); &#125; else if (getActivity() instanceof WeatherActivity) &#123; WeatherActivity activity = (WeatherActivity) getActivity(); activity.drawerLayout.closeDrawers(); activity.swipeRefresh.setRefreshing(true); activity.requestWeather(weatherId); &#125; &#125; &#125; &#125;); backButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (currentLevel == LEVEL_COUNTY) &#123; queryCities(); &#125; else if (currentLevel == LEVEL_CITY) &#123; queryProvinces(); &#125; &#125; &#125;); queryProvinces(); &#125;&#125; onItemClick()加拉一个if判断 当前级别是LEVEL_COUNTY 就启动WeatherActivity 把当前选择县的id传过去 还需在MainActivit加入缓存数据判断 MainActivit12345678910111213141516171819202122import android.content.Intent;import android.content.SharedPreferences;import android.preference.PreferenceManager;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this); if (prefs.getString("weather", null) != null) &#123; Intent intent = new Intent(this, WeatherActivity.class); startActivity(intent); finish(); &#125; &#125;&#125; 现在onCreate()方法一开始先从SharedPreferences文件中读取数据 不为null就说明之前请求过天气数据 直接跳转到WeatherActivity即可]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coolweather6]]></title>
    <url>%2F2017%2F08%2F17%2FCoolweather6%2F</url>
    <content type="text"><![CDATA[学习目的：1.获取必应每日一图 1.获取必应每日一图 每日一图接口：http://guolin.tech/api/bing_pic 服务器返回http://cn.bing.com/az/hprichbg/rb/AlaskaLynx_ROW9337883641_1920x1080.jpg每日一图背景 使用Glide加载即可 修改activity_weather`xml //…3qe]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易版小恐龙]]></title>
    <url>%2F2017%2F08%2F16%2F%E7%AE%80%E6%98%93%E7%89%88%E5%B0%8F%E6%81%90%E9%BE%99%2F</url>
    <content type="text"><![CDATA[别人的代码，目前还在研究。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Chrome Dinosaur Game&lt;/title&gt; &lt;style type="text/css"&gt; #game &#123; background-color: black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="game" height="400" width="800"&gt;&lt;/canvas&gt; &lt;script type="text/javascript"&gt; /////////////////////// // Utility Functions // /////////////////////// function topWall(obj) &#123; return obj.y; &#125; function bottomWall(obj) &#123; return obj.y + obj.height; &#125; function leftWall(obj) &#123; return obj.x; &#125; function rightWall(obj) &#123; return obj.x + obj.width; &#125; ////////////////// // Game Objects // ////////////////// // ---------- // DINOSAUR function Dinosaur (x, dividerY) &#123; this.width = 55; this.height = 70; this.x = x; this.y = dividerY - this.height; this.vy = 0; this.jumpVelocity = -20; &#125; Dinosaur.prototype.draw = function(context) &#123; var oldFill = context.fillStyle; context.fillStyle = "yellow"; context.fillRect(this.x, this.y, this.width, this.height); context.fillStyle = oldFill; &#125;; Dinosaur.prototype.jump = function() &#123; console.log("Jump called"); this.vy = this.jumpVelocity; &#125;; Dinosaur.prototype.update = function(divider, gravity) &#123; this.y += this.vy; this.vy += gravity; if (bottomWall(this) &gt; topWall(divider) &amp;&amp; this.vy &gt; 0) &#123; this.y = topWall(divider) - this.height; this.vy = 0; return; &#125; &#125;; // ---------- // DIVIDER function Divider (gameWidth, gameHeight) &#123; this.width = gameWidth; this.height = 4; this.x = 0; this.y = gameHeight - this.height - Math.floor(0.2 * gameHeight); &#125; Divider.prototype.draw = function(context) &#123; context.fillRect(this.x, this.y, this.width, this.height); &#125;; // ---------- // ---------- // CACTUS function Cactus(gameWidth, groundY)&#123; this.width = 16; //fixed width cactus this.height = (Math.random() &gt; 0.5) ? 30 : 70// two different cactus this.x = gameWidth; this.x = gameWidth;// spawn cactus at screen end this.y = groundY - this.height; &#125; Cactus.prototype.draw = function(context)&#123; var oldFill = context.fillStyle; context.fillStyle = "green"; context.fillRect(this.x, this.y, this.width, this.height); context.fillStyle = oldFill; &#125;; // ---------- // GAME function Game () &#123; var canvas = document.getElementById("game"); this.width = canvas.width; this.height = canvas.height; this.context = canvas.getContext("2d"); this.context.fillStyle = "brown"; document.spacePressed = false; document.addEventListener("keydown", function(e) &#123; if (e.key === " ") this.spacePressed = true; &#125;); document.addEventListener("keyup", function(e) &#123; if (e.key === " ") this.spacePressed = false; &#125;); this.gravity = 1.5; this.divider = new Divider(this.width, this.height); this.dino = new Dinosaur(Math.floor(0.1 * this.width), this.divider.y); this.cacti = []; this.runSpeed = -10; this.paused = false; this.noOfFrames = 0; &#125; Game.prototype.spawnCactus = function(probability) //Spawns a new cactus depending upon the probability &#123; if(Math.random() &lt;= probability)&#123; this.cacti.push(new Cactus(this.width, this.divider.y)); &#125; &#125; Game.prototype.update = function () &#123; // Dinosaur jump start if(this.paused)&#123; return; &#125; if (document.spacePressed == true &amp;&amp; bottomWall(this.dino) &gt;= topWall(this.divider)) &#123; console.log("Conditions met"); this.dino.jump(); &#125; this.dino.update(this.divider, this.gravity); // Removing old cacti that cross the eft border of the screen if(this.cacti.length &gt; 0 &amp;&amp; rightWall(this.cacti[0]) &lt; 0) &#123; this.cacti.shift(); &#125; // Spawning new cacti //Case 1: There are no cacti on the screen if(this.cacti.length == 0)&#123; //Spawn a cactus with high probability this.spawnCactus(0.5); &#125; //Case 2: There is atleast one cactus else if ( this.cacti.length &gt; 0 &amp;&amp; this.width - leftWall(this.cacti[this.cacti.length-1]) &gt; this.jumpDistance + 150) &#123; this.spawnCactus(0.05); &#125; // Moving the cacti for (i = 0; i &lt; this.cacti.length; i++)&#123; this.cacti[i].x += this.runSpeed; &#125; //Collision Detection for(i = 0; i &lt; this.cacti.length; i++)&#123; if( rightWall(this.dino) &gt;= leftWall(this.cacti[i]) &amp;&amp; leftWall(this.dino) &lt;= rightWall(this.cacti[i]) &amp;&amp; bottomWall(this.dino) &gt;= topWall(this.cacti[i])) &#123; // COLLISION OCCURED this.paused = true; &#125; this.noOfFrames++; this.score = Math.floor(this.noOfFrames/10); &#125; //Jump Distance of the Dinosaur // This is a CONSTANT in this gamebecause run speed is constant //Equations: time = t * 2 * v / g where v is the jump velocity // Horizontal ditance s = vx * t where vx is the run speed this.jumpDistance = Math.floor(this.runSpeed * (2 * this.dino.jumpVelocity) / this.gravity); // Math.floor() because we only use integer value. &#125;; Game.prototype.draw = function () &#123; // clear rectangle of game this.context.clearRect(0, 0, this.width, this.height); // draw divider line this.divider.draw(this.context); // draw the dinosaur this.dino.draw(this.context); //drawing the cactii for (i = 0; i &lt; this.cacti.length; i++)&#123; this.cacti[i].draw(this.context); &#125; var oldFill = this.context.fillStyle; this.context.fillStyle = "white"; this.context.fillText(this.score, this.width-40, 30); this.context.fillStyle = oldFill; &#125;; var game = new Game(); function main (timeStamp) &#123; game.update(); game.draw(); window.requestAnimationFrame(main); &#125; var startGame = window.requestAnimationFrame(main); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[GIT 版本控制 hexo blog]]></title>
    <url>%2F2017%2F08%2F15%2Fgit%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[完整教程：廖雪峰 mkdir 文件名 cd 文件名 pwd //显示当前路径 git init 修改 git add . git commit -m “version” 版本回退 git log //所有提交的commit 版本 git status //当前状态 git diff //查看改的地方 git reset –hard HEAD~3 //往上跳3个 git reset –hard 6361683 // 版本序列号前几位 commit 是增加/删除文件的改变 只改变文件内容，不改变文件多少-》no change to commit-》fuck？ 常用命令 cd .. git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写） git add -A ：是上面两个功能的合集（git add –all的缩写）]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级技巧]]></title>
    <url>%2F2017%2F08%2F15%2FCODE%202%20chaper13%2F</url>
    <content type="text"><![CDATA[学习目的：1.全局获取Context技巧（活动本身就是一个context对象）2. 使用INtent传递对象（serializable与Parcclablc方式）创建MyApplication类继承Application123456789public clss MyApplication extends Application&#123; private static Context context; public void onCreate()&#123; context=getApplicationContext(); &#125; public static Context getContext()&#123; return context; &#125;&#125; 修改AndroidMaifest.xml12345678910111213141516171819&lt;application android:name="com.example.networktest.MyApplication"//添加一行就行 路径一定要正确 android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="i6VD2fHKM3msMfZtIOXAhFSzDiYGFIwL" /&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true" android:process=":remote"&gt; &lt;/service&gt; &lt;/application&gt; 使用INtent传递对象（serializable与Parcclablc方式） serializable 序列化（方法：让类实现serializable接口）如：定义person类12345678910111213141516public class person implements Serializable&#123; private String name; private int age; public String getName()&#123; return name; &#125; public void setName()&#123; this.name=name; &#125; public int getAge()&#123; return age; &#125; public void setAge()&#123; this.age=age; &#125;&#125; FristActivity123456Person person=new person();person.setName();person.setAge();Intent intent=new Intent(FristActivity.this,SecondActivity.class);intent.putExtra(Person_data,person);startActivity(intent); 在SecondActivity获取这个对象1Person person=(Person)getIntent().getSerializableExtra("Person_data"); Parcclablc方式 (将一个完整的对象进行分解)]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coolweather4]]></title>
    <url>%2F2017%2F08%2F15%2FCoolweather4%2F</url>
    <content type="text"><![CDATA[学习目的:1.显示天气信息 2.编写天气界面 1.显示天气信息（由于和风天气返回的json数据很复杂，用JSONObject解析很麻烦，这里借助Gson解析）回顾返回数据的大致格式123456789101112&#123; "HeWeather":[ &#123; "status":"ok", "basic":&#123;&#125;, "api":&#123;&#125;, "suggestion":&#123;&#125;, "daily_forecast":[] &#125; ]&#125; 可以将status api等5个部分内容定义为5个实体类例：“basic”;{ “city”:”苏州”， “id”:”CN101190401”, “update”:{ “loc”:”2016-08-08 21:58” }} 12345678910111213141516171819202122按照此结构早GSON下建一个Basic类```javaimport com.google.gson.annotations.SerializedName;public class Basic &#123; @SerializedName(&quot;city&quot;) public String cityName; @SerializedName(&quot;id&quot;) public String weatherId; public Update update; public class Update &#123; @SerializedName(&quot;loc&quot;) public String updateTime; &#125;&#125; 类推12345678910111213public class AQI &#123; public AQICity city; public class AQICity &#123; public String aqi; public String pm25; &#125;&#125; 123456789101112131415161718import com.google.gson.annotations.SerializedName;public class Now &#123; @SerializedName("tmp") public String temperature; @SerializedName("cond") public More more; public class More &#123; @SerializedName("txt") public String info; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import com.google.gson.annotations.SerializedName;public class Suggestion &#123; @SerializedName("comf") public Comfort comfort; @SerializedName("cw") public CarWash carWash; public Sport sport; public class Comfort &#123; @SerializedName("txt") public String info; &#125; public class CarWash &#123; @SerializedName("txt") public String info; &#125; public class Sport &#123; @SerializedName("txt") public String info; &#125;&#125; 12345678910111213141516171819202122232425262728import com.google.gson.annotations.SerializedName;public class Forecast &#123; public String date; @SerializedName("tmp") public Temperature temperature; @SerializedName("cond") public More more; public class Temperature &#123; public String max; public String min; &#125; public class More &#123; @SerializedName("txt_d") public String info; &#125;&#125; 新建Weather类对五个类进行引用1234567891011121314151617181920import com.google.gson.annotations.SerializedName;import java.util.List;public class Weather &#123; public String status; public Basic basic; public AQI aqi; public Now now; public Suggestion suggestion; @SerializedName("daily_forecast") public List&lt;Forecast&gt; forecastList;&#125; 2.编写天气界面 新建WeatherActivity 并指定布局activity_weather.xml 新建title.xml作为头布局123456789101112131415161718192021222324252627282930313233&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize"&gt; &lt;Button android:id="@+id/nav_button" android:layout_width="30dp" android:layout_height="30dp" android:layout_marginLeft="10dp" android:layout_alignParentLeft="true" android:layout_centerVertical="true" android:background="@drawable/ic_home" /&gt; &lt;TextView android:id="@+id/title_city" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:textColor="#fff" android:textSize="20sp" /&gt; &lt;TextView android:id="@+id/title_update_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:layout_alignParentRight="true" android:layout_centerVertical="true" android:textColor="#fff" android:textSize="16sp"/&gt;&lt;/RelativeLayout&gt; 居中更新城市名 居右更新时间 新建now.xml作为当前天气信息布局123456789101112131415161718192021222324&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp"&gt; &lt;TextView android:id="@+id/degree_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end" android:textColor="#fff" android:textSize="60sp" /&gt; &lt;TextView android:id="@+id/weather_info_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="end" android:textColor="#fff" android:textSize="20sp" /&gt;&lt;/LinearLayout&gt; 两个TextView 一个显示气温 一个显示天气概况 新建forecast.xml作为未来几天天气布局12345678910111213141516171819202122232425&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp" android:background="#8000"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="15dp" android:layout_marginTop="15dp" android:text="预报" android:textColor="#fff" android:textSize="20sp"/&gt; &lt;LinearLayout android:id="@+id/forecast_layout" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; LinearLayout做一个半透明背景 TextView标题 LinearLayout显示未来几天天气布局 定义未来几天天气子布局forecast_item.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp"&gt; &lt;TextView android:id="@+id/date_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="2" android:textColor="#fff"/&gt; &lt;TextView android:id="@+id/info_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="1" android:gravity="center" android:textColor="#fff"/&gt; &lt;TextView android:id="@+id/max_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_weight="1" android:gravity="right" android:textColor="#fff"/&gt; &lt;TextView android:id="@+id/min_text" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_weight="1" android:gravity="right" android:textColor="#fff"/&gt;&lt;/LinearLayout&gt; 四个TextView 天气预报日期 天气概况 最高温度 最低温度 新建aqi.xml作为空气质量信息布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp" android:background="#8000"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="15dp" android:layout_marginTop="15dp" android:text="空气质量" android:textColor="#fff" android:textSize="20sp"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp"&gt; &lt;RelativeLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_centerInParent="true"&gt; &lt;TextView android:id="@+id/aqi_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#fff" android:textSize="40sp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:text="AQI指数" android:textColor="#fff"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_centerInParent="true"&gt; &lt;TextView android:id="@+id/pm25_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textColor="#fff" android:textSize="40sp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:text="PM2.5指数" android:textColor="#fff" /&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; LinearLayout半透明背景 TextView定义标题 RelativeLayout左右平分居中对齐 用于显示AQI和PM2.5 新建suggestion.xml作为生活建议信息的布局123456789101112131415161718192021222324252627282930313233343536373839&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp" android:background="#8000"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="15dp" android:layout_marginTop="15dp" android:text="生活建议" android:textColor="#fff" android:textSize="20sp"/&gt; &lt;TextView android:id="@+id/comfort_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="15dp" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/car_wash_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="15dp" android:textColor="#fff" /&gt; &lt;TextView android:id="@+id/sport_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="15dp" android:textColor="#fff" /&gt;&lt;/LinearLayout&gt; LinearLayout半透明背景 TextView定义标题 其他三个TextView显示舒适度 洗车指数 运动建议相关数据 将每个部分布局引入到activity_weather.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorPrimary"&gt; &lt;ImageView android:id="@+id/bing_pic_img" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" /&gt; &lt;android.support.v4.widget.DrawerLayout android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ScrollView android:id="@+id/weather_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:scrollbars="none" android:overScrollMode="never"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:fitsSystemWindows="true"&gt; &lt;include layout="@layout/title" /&gt; &lt;include layout="@layout/now" /&gt; &lt;include layout="@layout/forecast" /&gt; &lt;include layout="@layout/aqi" /&gt; &lt;include layout="@layout/suggestion" /&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;fragment android:id="@+id/choose_area_fragment" android:name="com.coolweather.android.ChooseAreaFragment" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/FrameLayout&gt; ScrollViewn允许滚动]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客恢复教程]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[搭建hexo和配置next主题 本地搜索服务 一键部署 背景动画 next主题样式 next+网易云 next+畅言 可能出现的错误及原因：网络原因（大部分） 主题配置错误（重来花的的时间《改错） git版本过低（网上说的 差点被坑）]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级技巧]]></title>
    <url>%2F2017%2F08%2F15%2F1.CODE%202%20chaper13%2F</url>
    <content type="text"><![CDATA[学习目的：1.定制自己的日志工具 2.调试android程序 新建LogUitl类1234567891011121314151617181920212223242526272829303132333435public class LogUitl&#123; public static final int VERBOSE=1; public static final int DEBUG=2; public static final int INFO=3; public static final int WARN=4; public static final int VERROR=5; public static final int NOTHING=1; public static int level=VERBOSE; public static void v(String tag,String msg)&#123; if(level&lt;=VERBOSE)&#123; Log.v(tag,msg); &#125; &#125; public static void d(String tag,String msg)&#123; if(level&lt;=DEBUG)&#123; Log.d(tag,msg); &#125; &#125; public static void i (String tag,String msg)&#123; if(level&lt;=INFO)&#123; Log.i(tag,msg); &#125; &#125; public static void w(String tag,String msg)&#123; if(level&lt;=WARN)&#123; Log.w(tag,msg); &#125; &#125; public static void e(String tag,String msg)&#123; if(level&lt;=ERROR)&#123; Log.e(tag,msg); &#125; &#125;&#125; 使用 如打印WARN级别的日志1LogUitl.w("TAG","warn log"); 2.调试android程序 3.创建定时任务 Alarm机制如：设置一个任务10s后执行12long triggerAtTime=SystemClock.elapsedRealtime()+10*1000;manager.set(AlarmManager.ELAPSED_REALLTIME_WAKEUP,triggerAtTime,pendingIntent); ELAPSED_REALLTIME_WAKEUP四种模式的其中一种]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coolweather2]]></title>
    <url>%2F2017%2F08%2F14%2FCoolweather2%2F</url>
    <content type="text"><![CDATA[学习目的：1.遍历全国省市县数据（获取json数据 处理返回的json数据） 1.遍历全国省市县数据 在Util包新建HttpUtil类 获取json数据123456789101112import okhttp3.OkHttpClient;import okhttp3.Request;public class HttpUtil &#123; public static void sendOkHttpRequest(String address, okhttp3.Callback callback) &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(address).build(); client.newCall(request).enqueue(callback); &#125;&#125; 再新建Utility类处理返回的json数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import android.text.TextUtils;import com.coolweather.android.db.City;import com.coolweather.android.db.County;import com.coolweather.android.db.Province;import com.coolweather.android.gson.Weather;import com.google.gson.Gson;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;public class Utility &#123; /** * 解析和处理服务器返回的省级数据 */ public static boolean handleProvinceResponse(String response) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allProvinces = new JSONArray(response); for (int i = 0; i &lt; allProvinces.length(); i++) &#123; JSONObject provinceObject = allProvinces.getJSONObject(i); Province province = new Province(); province.setProvinceName(provinceObject.getString("name")); province.setProvinceCode(provinceObject.getInt("id")); province.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; /** * 解析和处理服务器返回的市级数据 */ public static boolean handleCityResponse(String response, int provinceId) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allCities = new JSONArray(response); for (int i = 0; i &lt; allCities.length(); i++) &#123; JSONObject cityObject = allCities.getJSONObject(i); City city = new City(); city.setCityName(cityObject.getString("name")); city.setCityCode(cityObject.getInt("id")); city.setProvinceId(provinceId); city.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; /** * 解析和处理服务器返回的县级数据 */ public static boolean handleCountyResponse(String response, int cityId) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allCounties = new JSONArray(response); for (int i = 0; i &lt; allCounties.length(); i++) &#123; JSONObject countyObject = allCounties.getJSONObject(i); County county = new County(); county.setCountyName(countyObject.getString("name")); county.setWeatherId(countyObject.getString("weather_id")); county.setCityId(cityId); county.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; /** * 将返回的JSON数据解析成Weather实体类 */ public static Weather handleWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray("HeWeather"); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coolweather3]]></title>
    <url>%2F2017%2F08%2F14%2FCoolweather3%2F</url>
    <content type="text"><![CDATA[学习目的：1.布局+数据库 显示市级界面 县级界面 省级界面 新建choose_area.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#fff" android:fitsSystemWindows="true"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary"&gt; &lt;TextView android:id="@+id/title_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:textColor="#fff" android:textSize="20sp"/&gt; &lt;Button android:id="@+id/back_button" android:layout_width="25dp" android:layout_height="25dp" android:layout_marginLeft="10dp" android:layout_alignParentLeft="true" android:layout_centerVertical="true" android:background="@drawable/ic_back"/&gt; &lt;/RelativeLayout&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 关键：编写用于遍历省市县数据的碎片 新建Choose-AreaFragment类继承Fragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273import android.app.ProgressDialog;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.ListView;import android.widget.TextView;import android.widget.Toast;import com.coolweather.android.db.City;import com.coolweather.android.db.County;import com.coolweather.android.db.Province;import com.coolweather.android.util.HttpUtil;import com.coolweather.android.util.Utility;import org.litepal.crud.DataSupport;import java.io.IOException;import java.util.ArrayList;import java.util.List;import okhttp3.Call;import okhttp3.Callback;import okhttp3.Response;public class ChooseAreaFragment extends Fragment &#123; private static final String TAG = "ChooseAreaFragment"; public static final int LEVEL_PROVINCE = 0; public static final int LEVEL_CITY = 1; public static final int LEVEL_COUNTY = 2; private ProgressDialog progressDialog; private TextView titleText; private Button backButton; private ListView listView; private ArrayAdapter&lt;String&gt; adapter; private List&lt;String&gt; dataList = new ArrayList&lt;&gt;(); /** * 省列表 */ private List&lt;Province&gt; provinceList; /** * 市列表 */ private List&lt;City&gt; cityList; /** * 县列表 */ private List&lt;County&gt; countyList; /** * 选中的省份 */ private Province selectedProvince; /** * 选中的城市 */ private City selectedCity; /** * 当前选中的级别 */ private int currentLevel; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.choose_area, container, false); titleText = (TextView) view.findViewById(R.id.title_text); backButton = (Button) view.findViewById(R.id.back_button); listView = (ListView) view.findViewById(R.id.list_view); adapter = new ArrayAdapter&lt;&gt;(getContext(), android.R.layout.simple_list_item_1, dataList); listView.setAdapter(adapter); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; if (currentLevel == LEVEL_PROVINCE) &#123; selectedProvince = provinceList.get(position); queryCities(); &#125; else if (currentLevel == LEVEL_CITY) &#123; selectedCity = cityList.get(position); queryCounties(); &#125; else if (currentLevel == LEVEL_COUNTY) &#123; String weatherId = countyList.get(position).getWeatherId(); if (getActivity() instanceof MainActivity) &#123; Intent intent = new Intent(getActivity(), WeatherActivity.class); intent.putExtra("weather_id", weatherId); startActivity(intent); getActivity().finish(); &#125; else if (getActivity() instanceof WeatherActivity) &#123; WeatherActivity activity = (WeatherActivity) getActivity(); activity.drawerLayout.closeDrawers(); activity.swipeRefresh.setRefreshing(true); activity.requestWeather(weatherId); &#125; &#125; &#125; &#125;); backButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (currentLevel == LEVEL_COUNTY) &#123; queryCities(); &#125; else if (currentLevel == LEVEL_CITY) &#123; queryProvinces(); &#125; &#125; &#125;); queryProvinces(); &#125; /** * 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询。 */ private void queryProvinces() &#123; titleText.setText("中国"); backButton.setVisibility(View.GONE); provinceList = DataSupport.findAll(Province.class); if (provinceList.size() &gt; 0) &#123; dataList.clear(); for (Province province : provinceList) &#123; dataList.add(province.getProvinceName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_PROVINCE; &#125; else &#123; String address = "http://guolin.tech/api/china"; queryFromServer(address, "province"); &#125; &#125; /** * 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询。 */ private void queryCities() &#123; titleText.setText(selectedProvince.getProvinceName()); backButton.setVisibility(View.VISIBLE); cityList = DataSupport.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class); if (cityList.size() &gt; 0) &#123; dataList.clear(); for (City city : cityList) &#123; dataList.add(city.getCityName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_CITY; &#125; else &#123; int provinceCode = selectedProvince.getProvinceCode(); String address = "http://guolin.tech/api/china/" + provinceCode; queryFromServer(address, "city"); &#125; &#125; /** * 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询。 */ private void queryCounties() &#123; titleText.setText(selectedCity.getCityName()); backButton.setVisibility(View.VISIBLE); countyList = DataSupport.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class); if (countyList.size() &gt; 0) &#123; dataList.clear(); for (County county : countyList) &#123; dataList.add(county.getCountyName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); currentLevel = LEVEL_COUNTY; &#125; else &#123; int provinceCode = selectedProvince.getProvinceCode(); int cityCode = selectedCity.getCityCode(); String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode; queryFromServer(address, "county"); &#125; &#125; /** * 根据传入的地址和类型从服务器上查询省市县数据。 */ private void queryFromServer(String address, final String type) &#123; showProgressDialog(); HttpUtil.sendOkHttpRequest(address, new Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; String responseText = response.body().string(); boolean result = false; if ("province".equals(type)) &#123; result = Utility.handleProvinceResponse(responseText); &#125; else if ("city".equals(type)) &#123; result = Utility.handleCityResponse(responseText, selectedProvince.getId()); &#125; else if ("county".equals(type)) &#123; result = Utility.handleCountyResponse(responseText, selectedCity.getId()); &#125; if (result) &#123; getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; closeProgressDialog(); if ("province".equals(type)) &#123; queryProvinces(); &#125; else if ("city".equals(type)) &#123; queryCities(); &#125; else if ("county".equals(type)) &#123; queryCounties(); &#125; &#125; &#125;); &#125; &#125; @Override public void onFailure(Call call, IOException e) &#123; // 通过runOnUiThread()方法回到主线程处理逻辑 getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; closeProgressDialog(); Toast.makeText(getContext(), "加载失败", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125;); &#125; /** * 显示进度对话框 */ private void showProgressDialog() &#123; if (progressDialog == null) &#123; progressDialog = new ProgressDialog(getActivity()); progressDialog.setMessage("正在加载..."); progressDialog.setCanceledOnTouchOutside(false); &#125; progressDialog.show(); &#125; /** * 关闭进度对话框 */ private void closeProgressDialog() &#123; if (progressDialog != null) &#123; progressDialog.dismiss(); &#125; &#125;&#125; 遍历省市县数据完成 但碎片不能直接显示在界面上 还需添加到活动里activity_main.xml123456789101112&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/choose_area_fragment" android:name="com.coolweather.android.ChooseAreaFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt; 另外 由于碎片布局已定义标题栏 所以不需要ActionBar 所以修改style.xml1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 申请权限1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 到此可以显示市级界面 县级界面 省级界面 ！]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coolweather]]></title>
    <url>%2F2017%2F08%2F13%2FCoolweather%2F</url>
    <content type="text"><![CDATA[学习目的：1.功能需求和可行性分析 2.加入创建数据库和表的各项配置 1.功能需求和可行性分析 可以罗列出全国的省 市 县 可以查看全国任意城市的天气信息 可以自由切换城市，去看其他城市天气 提供手动更新和后台自动更新天气功能 有API key（key=bf79cd24a8494d0eb2c7c949fce6c383）和weather id（cityid=CN101190401）就能获取任意天气信息 如：查看苏州天气：http://guolin.tech/api/weather?cityid=CN101190401&amp;key=bf79cd24a8494d0eb2c7c949fce6c383 信息以json格式返回 提取下重要信息123456789101112&#123; "HeWeather":[ &#123; "status":"ok", "basic":&#123;&#125;, "api":&#123;&#125;, "suggestion":&#123;&#125;, "daily_forecast":[] &#125; ]&#125; 2.创建数据库和表 添加依赖123compile 'org.litepal.android:core:1.3.2' compile 'com.squareup.okhttp3:okhttp:3.4.1' compile 'com.google.code.gson:gson:2.7' 在DB包下新建Province类 City类 Country类12345678910111213141516171819202122232425262728293031323334import org.litepal.crud.DataSupport;public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445mport org.litepal.crud.DataSupport;public class County extends DataSupport &#123; private int id; private String countyName; private String weatherId; private int cityId; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCountyName() &#123; return countyName; &#125; public void setCountyName(String countyName) &#123; this.countyName = countyName; &#125; public String getWeatherId() &#123; return weatherId; &#125; public void setWeatherId(String weatherId) &#123; this.weatherId = weatherId; &#125; public int getCityId() &#123; return cityId; &#125; public void setCityId(int cityId) &#123; this.cityId = cityId; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.litepal.crud.DataSupport;public class City extends DataSupport &#123; private int id; private String cityName; private int cityCode; private int provinceId; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCityName() &#123; return cityName; &#125; public void setCityName(String cityName) &#123; this.cityName = cityName; &#125; public int getCityCode() &#123; return cityCode; &#125; public void setCityCode(int cityCode) &#123; this.cityCode = cityCode; &#125; public int getProvinceId() &#123; return provinceId; &#125; public void setProvinceId(int provinceId) &#123; this.provinceId = provinceId; &#125;&#125; 配置litepal.xml文件 将实体类添加到映射表中app/src/main-&gt;New-&gt;Directory-&gt;assets-&gt;litepal.xml12345678910111213litepal&gt; &lt;dbname value="cool_weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.coolweather.android.db.Province" /&gt; &lt;mapping class="com.coolweather.android.db.City" /&gt; &lt;mapping class="com.coolweather.android.db.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; 还需配置LitePalApplication 修改AndroidManifest.xml12&lt;application android:name="org.litepal.LitePalApplication" 数据库配置完成！]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest5(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F11%2FMaterialtest5%2F</url>
    <content type="text"><![CDATA[学习目的：3.可折叠的标题栏(界面编写) 3.可折叠的标题栏（借助CollapsingToolbarLayout基于Toolbar的布局） CollapsingToolbarLayout被限定作为AppBarLayout的子布局来使用 首先实现标题栏123456789&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"//定义命名空间 android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 套入 AppBarLayout123456789101112131415&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 再套入CollapsingToolbarLayout1234567891011121314151617181920212223242526&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" android:fitsSystemWindows="true" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 在CollapsingToolbarLayout定义标题栏的内容12345678910111213141516171819202122232425262728293031323334353637383940&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" android:fitsSystemWindows="true" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/fruit_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop"//指定折叠模式 android:fitsSystemWindows="true" app:layout_collapseMode="parallax" /&gt;//在折叠过程中产生错位偏移 &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 水果的标题栏界面完成 编写水果内容详情(NestedScrollView滚动)只能放一个字布局activity_fruit.xml123456789101112131415161718192021222324&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 套入布局123456789101112131415161718192021222324252627&lt;android.support.v4.widget.NestedScrollViewandroid:layout_width="match_parent"android:layout_height="match_parent"app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt;&lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="15dp" android:layout_marginLeft="15dp" android:layout_marginRight="15dp" android:layout_marginTop="35dp" app:cardCornerRadius="4dp"&gt; &lt;TextView android:id="@+id/fruit_content_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" /&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 添加悬浮按钮 &lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="16dp" android:src="@drawable/ic_comment" app:layout_anchor="@id/appBar" app:layout_anchorGravity="bottom|end" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest6(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F11%2FMaterialtest6%2F</url>
    <content type="text"><![CDATA[学习目的：3.可折叠的标题栏(逻辑编写) 4.充分利用系统状态栏空间（上拉时背景图与状态栏融合）FruitActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FruitActivity extends AppCompatActivity &#123; public static final String FRUIT_NAME = "fruit_name"; public static final String FRUIT_IMAGE_ID = "fruit_image_id"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_fruit); Intent intent = getIntent(); String fruitName = intent.getStringExtra(FRUIT_NAME); int fruitImageId = intent.getIntExtra(FRUIT_IMAGE_ID, 0); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar); ImageView fruitImageView = (ImageView) findViewById(R.id.fruit_image_view); TextView fruitContentText = (TextView) findViewById(R.id.fruit_content_text); setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); &#125; collapsingToolbar.setTitle(fruitName); Glide.with(this).load(fruitImageId).into(fruitImageView); String fruitContent = generateFruitContent(fruitName); fruitContentText.setText(fruitContent); &#125; private String generateFruitContent(String fruitName) &#123; StringBuilder fruitContent = new StringBuilder(); for (int i = 0; i &lt; 500; i++) &#123; fruitContent.append(fruitName); &#125; return fruitContent.toString(); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: finish(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; FruitAdapter1234567891011121314151617181920212223242526public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123; //... @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (mContext == null) &#123; mContext = parent.getContext(); &#125; View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.cardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Intent intent = new Intent(mContext, FruitActivity.class); intent.putExtra(FruitActivity.FRUIT_NAME, fruit.getName()); intent.putExtra(FruitActivity.FRUIT_IMAGE_ID, fruit.getImageId()); mContext.startActivity(intent); &#125; &#125;); return holder; &#125; //...&#125; 充分利用系统状态栏空间（上拉时背景图与状态栏融合）activity_fruit123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt;//上拉时背景图与状态栏融合 还需设置主题透明 &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt;//上拉时背景图与状态栏融合 还需设置主题透明 &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" android:fitsSystemWindows="true"//上拉时背景图与状态栏融合 还需设置主题透明 app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/fruit_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" android:fitsSystemWindows="true" app:layout_collapseMode="parallax" /&gt; //...&lt;/android.support.design.widget.CoordinatorLayout&gt; 还需设置主题透明 创建New-&gt;Directory-&gt;values-v21-&gt;New-&gt;Values resource file-&gt;style.xml1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="FruitActivityTheme" parent="AppTheme"&gt; &lt;/style&gt;&lt;/resources&gt; AndroidMaifest.xml1234&lt;activity android:name=".FruitActivity" android:theme="@style/FruitActivityTheme"&gt; &lt;/activity&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest4(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F10%2FMaterialtest4%2F</url>
    <content type="text"><![CDATA[学习目的：2.卡片式布局（CardView）实际上也是一个FrameLayout 2.卡片式布局（CardView）实际上也是一个FrameLayout添加依赖123compile 'com.android.support:recyclerview-v7:24.2.1' compile 'com.android.support:cardview-v7:24.2.1' compile 'com.github.bumptech.glide:glide:3.7.0'//glide是超级强大的图片加载库 activity_main1234&lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; Fruit类123456789101112131415161718public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125; fruit_item.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="5dp" app:cardCornerRadius="4dp"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="match_parent" android:layout_height="100dp" android:scaleType="centerCrop" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_margin="5dp" android:textSize="16sp" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 适配器RecyclerView.Adapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186ublic class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123; private static final String TAG = "FruitAdapter"; private Context mContext; private List&lt;Fruit&gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder &#123; CardView cardView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123; super(view); cardView = (CardView) view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125; &#125; public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (mContext == null) &#123; mContext = parent.getContext(); &#125; View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.cardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Intent intent = new Intent(mContext, FruitActivity.class); intent.putExtra(FruitActivity.FRUIT_NAME, fruit.getName()); intent.putExtra(FruitActivity.FRUIT_IMAGE_ID, fruit.getImageId()); mContext.startActivity(intent); &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitName.setText(fruit.getName()); Glide.with(mContext).load(fruit.getImageId()).into(holder.fruitImage); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125;&#125;``` MainActivity```javapublic class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; private Fruit[] fruits = &#123;new Fruit("Apple", R.drawable.apple), new Fruit("Banana", R.drawable.banana), new Fruit("Orange", R.drawable.orange), new Fruit("Watermelon", R.drawable.watermelon), new Fruit("Pear", R.drawable.pear), new Fruit("Grape", R.drawable.grape), new Fruit("Pineapple", R.drawable.pineapple), new Fruit("Strawberry", R.drawable.strawberry), new Fruit("Cherry", R.drawable.cherry), new Fruit("Mango", R.drawable.mango)&#125;; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); private FruitAdapter adapter; private SwipeRefreshLayout swipeRefresh; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); NavigationView navView = (NavigationView) findViewById(R.id.nav_view); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_menu); &#125; navView.setCheckedItem(R.id.nav_call); navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem item) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, "Data deleted", Snackbar.LENGTH_SHORT) .setAction("Undo", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125; &#125;); initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); GridLayoutManager layoutManager = new GridLayoutManager(this, 2); recyclerView.setLayoutManager(layoutManager); adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); swipeRefresh = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh); swipeRefresh.setColorSchemeResources(R.color.colorPrimary); swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; refreshFruits(); &#125; &#125;); &#125; private void refreshFruits() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; initFruits(); adapter.notifyDataSetChanged(); swipeRefresh.setRefreshing(false); &#125; &#125;); &#125; &#125;).start(); &#125; private void initFruits() &#123; fruitList.clear(); for (int i = 0; i &lt; 50; i++) &#123; Random random = new Random(); int index = random.nextInt(fruits.length); fruitList.add(fruits[index]); &#125; &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); break; case R.id.backup: Toast.makeText(this, "You clicked Backup", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "You clicked Delete", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "You clicked Settings", Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest3(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F10%2FMaterialtest3%2F</url>
    <content type="text"><![CDATA[学习目的：1.悬浮按钮（FloatingAcgtionButton有投影）和可交互提示(Snackbar更先进的提示工具) FloatingAcgtionButton(Design support的一个控件) 12345678&lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@drawable/ic_done" app：elevation="8dp" /&gt;//指定悬浮高度 高度越大投影效果小 FloatingActionButton的点击事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show(); &#125; &#125;);``` Snackbar更先进的提示工具（Design support）(用户接到提示可以进行（按钮形式）逻辑操作 toast不行)```javaFloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, "Data deleted", Snackbar.LENGTH_SHORT) .setAction("Undo", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125; &#125;);``` 如此提示会遮挡FloatingActionButton解决方法Coordinatorlayout(将FrameLayout替换成Coordinatorlayoutactivity_main```xml&lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@drawable/ic_done" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest2(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F09%2FMaterialtest2%2F</url>
    <content type="text"><![CDATA[学习目的：1.NavigationView 2.nav_head.xml(放置头像 邮箱 用户名) 3.使用NavigationView 1.NavigationView 添加依赖12345678910111213141516171819202122232425262728293031compile 'com.android.support:design:24.2.1'//Design supprot compile 'de.hdodenhof:circleimageview:2.1.0'//开源项目 轻松实现图片圆形化``` 在menu下创建nav_menu.xml```java?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_call" android:icon="@drawable/nav_call" android:title="Call" /&gt; &lt;item android:id="@+id/nav_friends" android:icon="@drawable/nav_friends" android:title="Friends" /&gt; &lt;item android:id="@+id/nav_location" android:icon="@drawable/nav_location" android:title="Location" /&gt; &lt;item android:id="@+id/nav_mail" android:icon="@drawable/nav_mail" android:title="Mail" /&gt; &lt;item android:id="@+id/nav_task" android:icon="@drawable/nav_task" android:title="Tasks" /&gt; &lt;/group&gt;&lt;/menu&gt; 3.nav_head.xml(放置头像 邮箱 用户名)123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp" android:background="?attr/colorPrimary" android:padding="10dp"&gt; &lt;de.hdodenhof.circleimageview.CircleImageView//图片圆形化控件 android:id="@+id/icon_image" android:layout_width="70dp" android:layout_height="70dp" android:layout_centerInParent="true" android:src="@drawable/nav_icon" /&gt; &lt;TextView android:id="@+id/username" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:text="tonygreendev@gmail.com" android:textColor="#FFF" android:textSize="14sp" /&gt; &lt;TextView android:id="@+id/mail" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@id/username" android:text="Tony Green" android:textColor="#FFF" android:textSize="14sp" /&gt;&lt;/RelativeLayout&gt; 使用NavigationViewactivity_maind的TextView替换成1234567&lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/nav_header" app:menu="@menu/nav_menu" /&gt; 设置点击事件123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); NavigationView navView = (NavigationView) findViewById(R.id.nav_view); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_menu); &#125; navView.setCheckedItem(R.id.nav_call); navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem item) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[materialtest(最佳UI体验)]]></title>
    <url>%2F2017%2F08%2F08%2FMaterialtest%2F</url>
    <content type="text"><![CDATA[学习目的：1.什么是Materrial Design 2.Toolbar与Actionbar（已淘汰） (Materrial控件) 3.app命名空间 1.什么是Materrial Design:Google推出的全新界面语言 2.Toolbar与Actionbar（已淘汰） (Materrial控件)1android:theme="@style/AppTheme"&gt; res/values/styles.xml12345678910&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt;//默认使用Actionbar &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;``` 禁用Actionbar```javaname="AppTheme" parent="Theme.AppCompat.Light.NoActionBar 用Toolbar替代Actionbar12345678&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap" /&gt; 3.创建mene文件夹 新建toolbar.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/backup" android:icon="@drawable/ic_backup" android:title="Backup" app:showAsAction="always"/&gt; &lt;item android:id="@+id/delete" android:icon="@drawable/ic_delete" android:title="Delete" app:showAsAction="ifRoom"/&gt; &lt;item android:id="@+id/settings" android:icon="@drawable/ic_settings" android:title="Settings" app:showAsAction="never"/&gt;&lt;/menu&gt; app:showAsAction指定显示位置 never永远在菜单栏 ifRoom屏幕空间足够则显示在Toolbar中 always永远显示在Toolbar中 4.滑动菜单DrawerLayout(一种布局：能放两个直接子控件 一个子控件显示主屏幕内容 另一个子控件是滑动菜单显示内容)activity_main123456789101112131415161718192021222324252627282930&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap" /&gt; &lt;/FrameLayout&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" android:text="This is name" android:testSize="30sp" android:background="#FFF"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 防止用户不知道左边可以滑动（设置导航栏）MainActivity12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); NavigationView navView = (NavigationView) findViewById(R.id.nav_view); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.drawable.ic_menu); &#125; &#125;//... @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); break; //... default: &#125; return true; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lbstest]]></title>
    <url>%2F2017%2F08%2F07%2FLbstest%2F</url>
    <content type="text"><![CDATA[学习目的：1.LBS(基于位置的服务)确定用户位置的两种方式（GPS 网络定位(手机与各基站的距离算出位置)） http://developer.baidu.com/user/reg（申请成为百度开发者） 申请APIkey http://lbsyun.baidu.com/apiconsole/key 使用百度定位 准备LBS SDK http://lbsyun.baidu.com/sdk/download androidMainifest.xml12345678910111213141516171819202122232425262728293031323334&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.lbstest"&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="i6VD2fHKM3msMfZtIOXAhFSzDiYGFIwL" /&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true" android:process=":remote"&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext());//LocationClient实例创建Context参数 mLocationClient.registerLocationListener(new MyLocationListener());//注册一个监听器 当获取到位置信息就会回调这个监听器 setContentView(R.layout.activity_main); positionText = (TextView) findViewById(R.id.position_text_view); List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();//创建List集合 没有授权的权限加入到List中 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (!permissionList.isEmpty()) &#123; String [] permissions = permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this, permissions, 1); &#125; else &#123; requestLocation(); &#125; &#125; private void requestLocation() &#123; mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0) &#123; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, "必须同意所有权限才能使用本程序", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125; else &#123; Toast.makeText(this, "发生未知错误", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; public class MyLocationListener implements BDLocationListener &#123; @Override public void onReceiveLocation(BDLocation location) &#123; StringBuilder currentPosition = new StringBuilder(); currentPosition.append("定位方式："); if (location.getLocType() == BDLocation.TypeGpsLocation) &#123; currentPosition.append("GPS"); &#125; else if (location.getLocType() == BDLocation.TypeNetWorkLocation) &#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;&#125; 问题:LocationClient的start()只会定位一次 快速移动定位需要LBS SDK提供的方法MainActivity中添加12345678910111213141516171819private void requestLocation() &#123; initLocation(); mLocationClient.start(); &#125; private void initLocation()&#123; LocationClientOption option = new LocationClientOption();//更新的间隔 option.setScanSpan(5000); mLocationClient.setLocOption(option); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop();//停止定位 &#125; 强制指定GPS进行定位123456private void initLocation()&#123; LocationClientOption option = new LocationClientOption(); option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); mLocationClient.setLocOption(option); &#125; 到此，位置信息以文本显示 具体化位置信息12345678910111213141516171819202122232425262728293031323334private void initLocation()&#123; LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; public class MyLocationListener implements BDLocationListener &#123; @Override public void onReceiveLocation(BDLocation location) &#123; StringBuilder currentPosition = new StringBuilder(); currentPosition.append("纬度：").append(location.getLatitude()).append("\n"); currentPosition.append("经线：").append(location.getLongitude()).append("\n"); currentPosition.append("国家：").append(location.getCountry()).append("\n"); currentPosition.append("省：").append(location.getProvince()).append("\n"); currentPosition.append("市：").append(location.getCity()).append("\n"); currentPosition.append("区：").append(location.getDistrict()).append("\n"); currentPosition.append("街道：").append(location.getStreet()).append("\n"); currentPosition.append("定位方式："); if (location.getLocType() == BDLocation.TypeGpsLocation) &#123; currentPosition.append("GPS"); &#125; else if (location.getLocType() == BDLocation.TypeNetWorkLocation) &#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); if (location.getLocType() == BDLocation.TypeGpsLocation || location.getLocType() == BDLocation.TypeNetWorkLocation) &#123; navigateTo(location); &#125; &#125; &#125; 到此，位置信息以文本显示 使用百度地图(显示地图)1234567891011&lt;TextView android:id="@+id/position_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="gone" /&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/bmapView" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" /&gt; 修改MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class MainActivity extends AppCompatActivity &#123; private MapView mapView; //... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView = (MapView) findViewById(R.id.bmapView); //... &#125; //... @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125; //...&#125;``` 移动到我的位置(BaiduMap类 地图的总控制器)```javapublic class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; private MapView mapView; private BaiduMap baiduMap; private boolean isFirstLocate = true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView = (MapView) findViewById(R.id.bmapView); baiduMap = mapView.getMap(); baiduMap.setMyLocationEnabled(true); positionText = (TextView) findViewById(R.id.position_text_view); List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (!permissionList.isEmpty()) &#123; String [] permissions = permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this, permissions, 1); &#125; else &#123; requestLocation(); &#125; &#125; private void navigateTo(BDLocation location) &#123; if (isFirstLocate) &#123; Toast.makeText(this, "nav to " + location.getAddrStr(), Toast.LENGTH_SHORT).show(); LatLng ll = new LatLng(location.getLatitude(), location.getLongitude()); MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update = MapStatusUpdateFactory.zoomTo(16f); baiduMap.animateMapStatus(update); isFirstLocate = false; &#125; MyLocationData.Builder locationBuilder = new MyLocationData. Builder(); locationBuilder.latitude(location.getLatitude()); locationBuilder.longitude(location.getLongitude()); MyLocationData locationData = locationBuilder.build(); baiduMap.setMyLocationData(locationData); &#125; private void requestLocation() &#123; initLocation(); mLocationClient.start(); &#125; private void initLocation()&#123; LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0) &#123; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, "必须同意所有权限才能使用本程序", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125; else &#123; Toast.makeText(this, "发生未知错误", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; public class MyLocationListener implements BDLocationListener &#123; @Override public void onReceiveLocation(BDLocation location) &#123; if (location.getLocType() == BDLocation.TypeGpsLocation || location.getLocType() == BDLocation.TypeNetWorkLocation) &#123; navigateTo(location); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lbstest2]]></title>
    <url>%2F2017%2F08%2F07%2FLbstest2%2F</url>
    <content type="text"><![CDATA[androidMainifest12345678910111213141516171819202122232425262728293031323334&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.lbstest"&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="i6VD2fHKM3msMfZtIOXAhFSzDiYGFIwL" /&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true" android:process=":remote"&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; private MapView mapView; private BaiduMap baiduMap; private boolean isFirstLocate = true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient = new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView = (MapView) findViewById(R.id.bmapView); baiduMap = mapView.getMap(); baiduMap.setMyLocationEnabled(true); positionText = (TextView) findViewById(R.id.position_text_view); List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if (!permissionList.isEmpty()) &#123; String [] permissions = permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this, permissions, 1); &#125; else &#123; requestLocation(); &#125; &#125; private void navigateTo(BDLocation location) &#123; if (isFirstLocate) &#123; Toast.makeText(this, "nav to " + location.getAddrStr(), Toast.LENGTH_SHORT).show(); LatLng ll = new LatLng(location.getLatitude(), location.getLongitude()); MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update = MapStatusUpdateFactory.zoomTo(16f); baiduMap.animateMapStatus(update); isFirstLocate = false; &#125; MyLocationData.Builder locationBuilder = new MyLocationData. Builder(); locationBuilder.latitude(location.getLatitude()); locationBuilder.longitude(location.getLongitude()); MyLocationData locationData = locationBuilder.build(); baiduMap.setMyLocationData(locationData); &#125; private void requestLocation() &#123; initLocation(); mLocationClient.start(); &#125; private void initLocation()&#123; LocationClientOption option = new LocationClientOption(); option.setScanSpan(5000); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0) &#123; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, "必须同意所有权限才能使用本程序", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125; else &#123; Toast.makeText(this, "发生未知错误", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; public class MyLocationListener implements BDLocationListener &#123; @Override public void onReceiveLocation(BDLocation location) &#123;// StringBuilder currentPosition = new StringBuilder();// currentPosition.append("纬度：").append(location.getLatitude()).append("\n");// currentPosition.append("经线：").append(location.getLongitude()).append("\n");// currentPosition.append("国家：").append(location.getCountry()).append("\n");// currentPosition.append("省：").append(location.getProvince()).append("\n");// currentPosition.append("市：").append(location.getCity()).append("\n");// currentPosition.append("区：").append(location.getDistrict()).append("\n");// currentPosition.append("街道：").append(location.getStreet()).append("\n");// currentPosition.append("定位方式：");// if (location.getLocType() == BDLocation.TypeGpsLocation) &#123;// currentPosition.append("GPS");// &#125; else if (location.getLocType() == BDLocation.TypeNetWorkLocation) &#123;// currentPosition.append("网络");// &#125;// positionText.setText(currentPosition); if (location.getLocType() == BDLocation.TypeGpsLocation || location.getLocType() == BDLocation.TypeNetWorkLocation) &#123; navigateTo(location); &#125; &#125; &#125;&#125; 布局123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/position_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="gone" /&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/bmapView" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" /&gt;&lt;/LinearLayout&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servicetest]]></title>
    <url>%2F2017%2F08%2F04%2FServicetest%2F</url>
    <content type="text"><![CDATA[学习目的：1.定义一个服务(服务都需要注册) 2.启动和停止活动 3.活动与服务进行通信 4.服务的生命周期 5.服务的更多技巧（前台服务，intentService） 1.定义一个服务New-&gt;Service-&gt;Service 以下自动生成的代码123456789public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; throw new UnsupportedOperationException("Not yet implemented"); &#125; 重写Service中的方法123456789101112131415161718@Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; 注册自动完成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=".MyService" android:enabled="true" android:exported="true" /&gt; &lt;service android:name=".MyIntentService" /&gt; &lt;/application&gt;``` 2.启动和停止活动```javapublic class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService = (Button) findViewById(R.id.start_service); Button stopService = (Button) findViewById(R.id.stop_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.start_service: Intent startIntent = new Intent(this, MyService.class); startService(startIntent); // 启动服务 break; case R.id.stop_service: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); // 停止服务 break; &#125; &#125;&#125; 3.活动与服务进行通信（让活动具有下载功能，活动可以随时调用）思路：创建Binder对象对下载功能进行管理MyService1234567891011121314151617181920212223242526272829ublic class MyService extends Service &#123; public MyService() &#123; &#125; private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder &#123; public void startDownload() &#123; Log.d("MyService", "startDownload executed"); &#125; public int getProgress() &#123; Log.d("MyService", "getProgress executed"); return 0; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 活动与服务绑定javapublic class MainActivity extends AppCompatActivity implements View.OnClickListener{ private MyService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceDisconnected(ComponentName name) { } @Override public void onServiceConnected(ComponentName name, IBinder service) { downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bindService = (Button) findViewById(R.id.bind_service); Button unbindService = (Button) findViewById(R.id.unbind_service); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.bind_service: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务 break; case R.id.unbind_service: unbindService(connection); // 解绑服务 break; default: break; } } }12345678910111213141516171819202122232425262728294.服务的生命周期```textA started service 被开启的service通过其他组件调用 startService()被创建。 这种service可以无限地运行下去，必须调用stopSelf()方法或者其他组件调用stopService()方法来停止它。 当service被停止时，系统会销毁它。A bound service 被绑定的service是当其他组件（一个客户）调用bindService()来创建的。 客户可以通过一个IBinder接口和service进行通信。 客户可以通过 unbindService()方法来关闭这种连接。 一个service可以同时和多个客户绑定，当多个客户都解除绑定之后，系统会销毁service。 这两条路径并不是完全分开的。 即是说，你可以和一个已经调用了 startService()而被开启的service进行绑定。 比如，一个后台音乐service可能因调用 startService()方法而被开启了，稍后，可能用户想要控制播放器或者得到一些当前歌曲的信息，可以通过bindService()将一个activity和service绑定。这种情况下，stopService()或 stopSelf()实际上并不能停止这个service，除非所有的客户都解除绑定。 5.服务的更多技巧（前台服务，intentService)创建前台服务12345678910111213141516171819202122public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d("MyService", "onCreate executed"); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title") .setContentText("This is content text") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); startForeground(1, notification); &#125;&#125; 显示效果是一条通知，下拉有详细信息 使用intentService(需要用到android多线程)1234567891011121314151617public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable()&#123; @verride public void run()&#123; //处理逻辑 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125;&#125; 一旦启动就一直运行 必须调用stopService的stopSelf()方法才能让服务停止1234567new Thread(new Runnable()&#123; @verride public void run()&#123; //处理逻辑 stopSelf(); &#125;&#125;).start(); intentService解决程序员忘开线程 或忘stopSelf()12345678910111213141516171819public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super("MyIntentService"); // 调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(Intent intent) &#123; // 打印当前线程的id Log.d("MyIntentService", "Thread id is " + Thread.currentThread(). getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService", "onDestroy executed"); &#125;&#125; MainActivity1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startIntentService = (Button) findViewById(R.id.start_intent_service); startIntentService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.start_intent_service: // 打印主线程的id Log.d("MainActivity", "Thread id is " + Thread.currentThread(). getId()); Intent intentService = new Intent(this, MyIntentService.class); startService(intentService); break; default: break; &#125; &#125;&#125; 注册1&lt;service android:name=".MyIntentService" /&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servicebesttest]]></title>
    <url>%2F2017%2F08%2F04%2FServicebestpractice%2F</url>
    <content type="text"><![CDATA[学习目的：1.完整版下载示例 （@verride表示重写方法 无则是新建方法） 添加依赖1compile 'com.squareup.okhttp3:okhttp:3.4.1' 定义一个回调接口（对下载过程中的各种状态进行监听和回调）DownloadListenter12345678910111213public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; AsynsTask实现下载功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//三个参数 传入数据 进度显示数据单位 反馈执行结果数据类型public class DownloadTask extends AsyncTask&lt;String, Integer, Integer&gt; &#123; public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private boolean isCanceled = false; private boolean isPaused = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; //下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream is = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadedLength = 0; // 记录已下载的文件长度 String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/")); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory + fileName); if (file.exists()) &#123; downloadedLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0) &#123; return TYPE_FAILED; &#125; else if (contentLength == downloadedLength) &#123; // 已下载字节和文件总字节相等，说明已经下载完成了 return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 断点下载，指定从哪个字节开始下载 .addHeader("RANGE", "bytes=" + downloadedLength + "-") .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null) &#123; is = response.body().byteStream(); savedFile = new RandomAccessFile(file, "rw"); savedFile.seek(downloadedLength); // 跳过已下载的字节 byte[] b = new byte[1024]; int total = 0; int len; while ((len = is.read(b)) != -1) &#123; if (isCanceled) &#123; return TYPE_CANCELED; &#125; else if(isPaused) &#123; return TYPE_PAUSED; &#125; else &#123; total += len; savedFile.write(b, 0, len); // 计算已下载的百分比 int progress = (int) ((total + downloadedLength) * 100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (is != null) &#123; is.close(); &#125; if (savedFile != null) &#123; savedFile.close(); &#125; if (isCanceled &amp;&amp; file != null) &#123; file.delete(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return TYPE_FAILED; &#125; //界面显示当前下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if (progress &gt; lastProgress) &#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //通知最终下载结果 @Override protected void onPostExecute(Integer status) &#123; switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; public void pauseDownload() &#123; isPaused = true; &#125; public void cancelDownload() &#123; isCanceled = true; &#125; //获取下载文件总长度 private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful()) &#123; long contentLength = response.body().contentLength(); response.close(); return contentLength; &#125; return 0; &#125; 创建下载服务DownloadService（重写5个方法） DownloadBinder内部类（重写3个方法）两个类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class DownloadService extends Service &#123; private DownloadTask downloadTask; private String downloadUrl; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1, getNotification("Downloading...", progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification("Download Success", -1)); Toast.makeText(DownloadService.this, "Download Success", Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification("Download Failed", -1)); Toast.makeText(DownloadService.this, "Download Failed", Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, "Paused", Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show(); &#125; &#125;; private DownloadBinder mBinder = new DownloadBinder(); @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder &#123; public void startDownload(String url) &#123; if (downloadTask == null) &#123; downloadUrl = url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1, getNotification("Downloading...", 0)); Toast.makeText(DownloadService.this, "Downloading...", Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload() &#123; if (downloadTask != null) &#123; downloadTask.pauseDownload(); &#125; &#125; public void cancelDownload() &#123; if (downloadTask != null) &#123; downloadTask.cancelDownload(); &#125; else &#123; if (downloadUrl != null) &#123; // 取消下载时需将文件删除，并将通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf("/")); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if (file.exists()) &#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, "Canceled", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; private NotificationManager getNotificationManager() &#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; private Notification getNotification(String title, int progress) &#123; Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if (progress &gt;= 0) &#123; // 当progress大于或等于0时才需显示下载进度 builder.setContentText(progress + "%"); builder.setProgress(100, progress, false); &#125; return builder.build(); &#125;&#125; MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (DownloadService.DownloadBinder) service; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.start_download); Button pauseDownload = (Button) findViewById(R.id.pause_download); Button cancelDownload = (Button) findViewById(R.id.cancel_download); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this, DownloadService.class); startService(intent); // 启动服务 bindService(intent, connection, BIND_AUTO_CREATE); // 绑定服务 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View v) &#123; if (downloadBinder == null) &#123; return; &#125; switch (v.getId()) &#123; case R.id.start_download: String url = "https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe"; downloadBinder.startDownload(url); break; case R.id.pause_download: downloadBinder.pauseDownload(); break; case R.id.cancel_download: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, "拒绝权限将无法使用程序", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 权限声明 &lt;service android:name=".DownloadService" android:enabled="true" android:exported="true" /&gt;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[androidthreadtest]]></title>
    <url>%2F2017%2F08%2F02%2FAndroidthreadtest%2F</url>
    <content type="text"><![CDATA[学习目的：1.了解android线程的使用 2.了解主线程与子线程区别 3.解析异步处理机制主线程与子线程：所谓主线程，在Windows窗体应用程序中一般指UI线程，这个是程序启动的时候首先创建的线程。而子线程，一般指为了完成某个特殊任务，并行于主线程的其他线程。例如让一个窗体单独开一个线程，去远程数据库中取得数据资料，下载并且保存到本地文件中。所以，主线程和子线程是构建于线程这个通用概念上的人为的习惯称呼，并不是什么官方的固有专用词语。MainActivity（简而言之，为实现某个功能而创建爱的线程是子线程） 1.了解android线程的使用(例：在子线程更新UI) 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView) findViewById(R.id.text); Button changeText = (Button) findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; test.setText("Nice to meet you"); &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; logcat报错（说明不能在子线程更新UI）修改如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; public static final int UPDATE_TEXT = 1; private TextView text; private Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case UPDATE_TEXT: // 在这里可以进行UI操作 text.setText("Nice to meet you"); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView) findViewById(R.id.text); Button changeText = (Button) findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); // 将Message对象发送出去 &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 3.解析异步处理机制（Message MessageQueue Looper Handler四个部分）异步处理机制的核心思想：一条Message经过如下转展调用，从子线程进入主线程，从而使不能更新UI变成可以更新UI 4.使用AsyncTask类（更方便的进行UI操作）1class DownloadTask extends AsyncTask&lt;Void Integer Boolean&gt;&#123;...&#125;// 三个参数Params:执行AsyncTask需要传入的参数Progress:后台任务执行时，需要在当前界面显示进度Result:返回值类型 还需重写四个方法12345678910111213141516171819202122232425262728293031323334353637class DownloadTask extends AsyncTask&lt;Void Integer Boolean&gt;&#123; @verride protected void onPreExecute()&#123; progressDialog.show();//显示进度对话框 &#125; @verride protected Boolean doInBackground(void... Params)&#123; try&#123; while(true)&#123; int downloadPercent=doDownload();//这是一个虚构的方法 publishProgress(downloadPercent); if(downloadPercent&gt;=100)&#123; break; &#125; &#125;catch(Exception e)&#123; return false; &#125; return true; &#125; &#125; @verride protected void onProgressUpdata(Integer... values)&#123; //在这里更新下载进度 progressDialog.setMessage("Download"+values[0]+"%"); &#125; @verride protected void onPostExecute(Boolean result)&#123; progressDialog.dismiss();//关闭进度对话框 if(result)&#123; Toast.makeText(context,"Download Succeeded",Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(context,"Download Failed",Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 想要启动这个任务1new DownloadTask().execute();]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[networktest2]]></title>
    <url>%2F2017%2F08%2F02%2FNetworktest2%2F</url>
    <content type="text"><![CDATA[1.搭建Apache服务器 搜索Apache http srever 一路next 成功标志 在Apache/htdocs下新建html文件 xml数据格式1234567891011121314151617&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;id&gt; &lt;name&gt;Google Maps&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;2&lt;id&gt; &lt;name&gt;Chorme&lt;/name&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;3&lt;id&gt; &lt;name&gt;Google Play&lt;/name&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/app&gt;&lt;/apps&gt; 2.Pull解析方式（解析XML格式数据）（例子结果在log呈现）MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 指定访问的服务器地址是电脑本机 .url("http://10.0.2.2/get_data.xml")//get_data.xml我们在Apache/htdocs下新建的文件 10.0.2.2对模拟器来说是本机地址 .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); parseXMLWithPull(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void parseXMLWithPull(String xmlData) &#123; try &#123; XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType = xmlPullParser.getEventType(); String id = ""; String name = ""; String version = ""; while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; // 开始解析某个结点 case XmlPullParser.START_TAG: &#123; if ("id".equals(nodeName)) &#123; id = xmlPullParser.nextText(); &#125; else if ("name".equals(nodeName)) &#123; name = xmlPullParser.nextText(); &#125; else if ("version".equals(nodeName)) &#123; version = xmlPullParser.nextText(); &#125; break; &#125; // 完成解析某个结点 case XmlPullParser.END_TAG: &#123; if ("app".equals(nodeName)) &#123; Log.d("MainActivity", "id is " + id); Log.d("MainActivity", "name is " + name); Log.d("MainActivity", "version is " + version); &#125; break; &#125; default: break; &#125; eventType = xmlPullParser.next(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 3.SAX解析方式(解析XML格式数据)（实现解析功能同上）新建类继承DefaultHandler 重写5个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ContentHandler extends DefaultHandler &#123; private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; @Override public void startDocument() throws SAXException &#123; id = new StringBuilder(); name = new StringBuilder(); version = new StringBuilder(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // 记录当前结点名 nodeName = localName; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 根据当前的结点名判断将内容添加到哪一个StringBuilder对象中 if ("id".equals(nodeName)) &#123; id.append(ch, start, length); &#125; else if ("name".equals(nodeName)) &#123; name.append(ch, start, length); &#125; else if ("version".equals(nodeName)) &#123; version.append(ch, start, length); &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if ("app".equals(localName)) &#123; Log.d("ContentHandler", "id is " + id.toString().trim()); Log.d("ContentHandler", "name is " + name.toString().trim()); Log.d("ContentHandler", "version is " + version.toString().trim()); // 最后要将StringBuilder清空掉 id.setLength(0); name.setLength(0); version.setLength(0); &#125; &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125;&#125; MainActivity1234567891011121314151617181920212223242526272829303132333435363738private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 指定访问的服务器地址是电脑本机 .url("http://10.0.2.2/get_data.xml")//get_data.xml我们在Apache/htdocs下新建的文件 10.0.2.2对模拟器来说是本机地址 .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); parseXMLWithSAX(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void parseXMLWithSAX(String xmlData) &#123; try &#123; SAXParserFactory factory = SAXParserFactory.newInstance(); XMLReader xmlReader = factory.newSAXParser().getXMLReader(); ContentHandler handler = new ContentHandler(); // 将ContentHandler的实例设置到XMLReader中 xmlReader.setContentHandler(handler); // 开始执行解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 4.解析JSON数据格式json数据格式1&#123;“name”:"Tome","age":20&#125; 用JSONObject解析1234567891011121314151617181920212223242526272829303132333435363738394041private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 指定访问的服务器地址是电脑本机 .url("http://10.0.2.2/get_data.json")//get_data.xml我们在Apache/htdocs下新建的文件 10.0.2.2对模拟器来说是本机地址 .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); parseJSONWithJSONObject(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void parseJSONWithJSONObject(String jsonData) &#123; try &#123; JSONArray jsonArray = new JSONArray(jsonData); for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); String id = jsonObject.getString("id"); String name = jsonObject.getString("name"); String version = jsonObject.getString("version"); Log.d("MainActivity", "id is " + id); Log.d("MainActivity", "name is " + name); Log.d("MainActivity", "version is " + version); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 5.使用GSON解析JSON添加依赖1compile 'com.google.code.gson:gson:2.7' 新建App类123456789101112131415161718192021222324252627282930313233public class App &#123; private String id; private String name; private String version; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getVersion() &#123; return version; &#125; public void setVersion(String version) &#123; this.version = version; &#125;&#125; MainActivity private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 指定访问的服务器地址是电脑本机 .url("http://10.0.2.2/get_data.json") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); parseJSONWithGSON(responseData); } catch (Exception e) { e.printStackTrace(); } } }).start(); } private void parseJSONWithGSON(String jsonData) { Gson gson = new Gson(); List&lt;App&gt; appList = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;() {}.getType()); for (App app : appList) { Log.d("MainActivity", "id is " + app.getId()); Log.d("MainActivity", "name is " + app.getName()); Log.d("MainActivity", "version is " + app.getVersion()); } }]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[networktest3]]></title>
    <url>%2F2017%2F08%2F02%2FNetWorktest3%2F</url>
    <content type="text"><![CDATA[优化：（在tese1，2中http请求代码基本相同 但我们每一次发送请求都编写一次代码）将通用的网络操作放到一个类HttpUil HttpUil1234567891011121314151617181920212223242526272829public class HttpUtil &#123; public static void sendHttpRequest(final String address, final HttpCallbackListener listener) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; return response.toString(); &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125;&#125; 若需发起请求(sendHttpRequest()内部没有开启线程 调用时可能阻塞主线程)12String address=&quot;http://wwww.baid.com&quot;;String response=HttpUtil.sendHttpRequest(address); 解决方法(Java的回调机制)首先定义接口 HttpCallbackListener1234567public interface HttpCallbackListener &#123; void onFinish(String response); void onError(Exception e);&#125; 修改HttoUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class HttpUtil &#123; public static void sendHttpRequest(final String address, final HttpCallbackListener listener) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; if (listener != null) &#123; // 回调onFinish()方法 listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; if (listener != null) &#123; // 回调onError()方法 listener.onError(e); &#125; &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125;&#125;``` 传入HttoCallbackListener实例```javaHttpUtil.sendHttpRequest(address,new HttpCallbackListener())&#123; @version public void onFinish(String response)&#123; //在这里根据返回内容执行具体逻辑 &#125; @version public void onError(Exception e)&#123; //在这里对异常进行处理 &#125;&#125; 使用HttpURIConnection太复杂 改用Okhttp在HttpUtil内田间sendOkhttpRequest()方法12345678910111213141516171819202122public static void sendOkHttpRequest(final String address, final okhttp3.Callback callback) &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); &#125;``` ```javaHttpUtil.sendOkHttpRequest(address,new HttpCallbackListener())&#123; @version public void onFinish(String response)&#123; //在这里根据返回内容执行具体逻辑 String responseData=response.body().strng(); &#125; @version public void onError(Exception e)&#123; //在这里对异常进行处理 &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[networktest]]></title>
    <url>%2F2017%2F08%2F01%2FNetworktest%2F</url>
    <content type="text"><![CDATA[学习目的：1.使用HTTP访问网络 2.使用HttpURIConnection 1.使用HTTP访问网络工作原理：客户端向服务器发出HTTP请求 服务器接收到请求返回数据 客户端解析处理 2.使用HttpURIConnection（本例获取的是html代码） 布局123456789101112131415&lt;Button android:id="@+id/send_request" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Send Request" /&gt; &lt;ScrollView//滚动查看界面显示不了的内容 android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:id="@+id/response_text" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt; MainActivity类12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Override public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123; sendRequestWithHttpURLConnection(); &#125; &#125;private void sendRequestWithHttpURLConnection() &#123; // 开启线程来发起网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; BufferedReader reader = null; try &#123; URL url = new URL("http://www.baidu.com"); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream in = connection.getInputStream(); // 下面对获取到的输入流进行读取 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; showResponse(response.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 添加权限12&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 3.提交数据给服务器（如：提交用户名和密码）数据用&amp;隔开 123connection.setRequestMethod("POST");DataOutPutStream out=new DataOutPutStream(connection.getOutPutStream());out.writeBytes("username=admin&amp;password=123456789"); 4.使用Okhttp添加依赖1234567dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.squareup.okhttp3:okhttp:3.4.1'//自动下载两个库Okhttp库 Okio库&#125; 用Okhttp重写http的例子12345678910111213141516171819202122232425262728293031323334353637public void onClick(View v) &#123; if (v.getId() == R.id.send_request) &#123;// sendRequestWithHttpURLConnection(); sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://www.baidu.com") .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); showResponse(responseData); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; // 在这里进行UI操作，将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[playvideotest]]></title>
    <url>%2F2017%2F07%2F31%2FPlayvideotest%2F</url>
    <content type="text"><![CDATA[学习目的:1.播放视频 暂停视频 停止视频(videoView类的使用)权限1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; MainActivity类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private VideoView videoView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); videoView = (VideoView) findViewById(R.id.video_view); Button play = (Button) findViewById(R.id.play); Button pause = (Button) findViewById(R.id.pause); Button replay = (Button) findViewById(R.id.replay); play.setOnClickListener(this); pause.setOnClickListener(this); replay.setOnClickListener(this); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; else &#123; initVideoPath(); // 初始化MediaPlayer &#125; &#125; private void initVideoPath() &#123; File file = new File(Environment.getExternalStorageDirectory(), "movie.mp4"); videoView.setVideoPath(file.getPath()); // 指定视频文件的路径 &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; initVideoPath(); &#125; else &#123; Toast.makeText(this, "拒绝权限将无法使用程序", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.play: if (!videoView.isPlaying()) &#123; videoView.start(); // 开始播放 &#125; break; case R.id.pause: if (videoView.isPlaying()) &#123; videoView.pause(); // 暂停播放 &#125; break; case R.id.replay: if (videoView.isPlaying()) &#123; videoView.resume(); // 重新播放 &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (videoView != null) &#123; videoView.suspend(); &#125; &#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notificationtset]]></title>
    <url>%2F2017%2F07%2F31%2FNotificationtest%2F</url>
    <content type="text"><![CDATA[学习目的:1.发通知（程序不在前台运行，但希望向用户发一些提示信息）NotificationActivity类1234567891011public class NotificationActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.notification_layout); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(1); &#125;&#125; 点击事件1234567891011121314151617181920public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notice: NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title")//指定标题内容 .setContentText("This is content text")//指定正文内容 .setWhen(System.currentTimeMillis())//指定通知被创建时间 .setSmallIcon(R.mipmap.ic_launcher)//设置通知的小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))//设置通知的大图标 .setAutoCancel(true);//点击后 通知自动取消 .build(); manager.notify(1, notification);//让通知显示 break; default: break; &#125; &#125; 设置点击通知点击事件PendingIntent（点击通知调到NotificationAcitity.xml并点击后自动消失）12345678910111213141516171819202122public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send_notice: Intent intent=new Intent(this,NotificationAcitity.class); PendingIntent pi=PendingIntent.getActivity(this,0,intent,0); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle("This is content title")//指定标题内容 .setContentText("This is content text")//指定正文内容 .setWhen(System.currentTimeMillis())//指定通知被创建时间 .setSmallIcon(R.mipmap.ic_launcher)//设置通知的小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))//设置通知的大图标 .setContentIntent(pi); .setAutoCancel(true);//点击后 通知自动取消 .build(); manager.notify(1, notification);//让通知显示 break; default: break; &#125; &#125;` 通知的进阶：通知提示音 灯光 /振动需要申请权限 123Notification notification = new NotificationCompat.Builder(this)setSound(Uri.fromFile(new File("/System/media/audio/ringtone/Luna.ogg"))).bulid(); 振动12345Notification notification = new NotificationCompat.Builder(this)setVibrate(new log[]&#123;0,1000,1000,1000&#125;)震动1秒 静止1秒.bulid();&lt;uses-permission android:name="android.permission.VIBRATE" /&gt; 灯光123Notification notification = new NotificationCompat.Builder(this)setLight(Color.GREEN,1000,1000);.bulid(); 直接使用默认设置123Notification notification = new NotificationCompat.Builder(this)setDefaults(NotificationCompat.DEFAULT_ALL).bulid(); 通知的高级功能 解决超长文字显示不僚的问题 显示超大图片 setStyle()方法123Notification notification = new NotificationCompat.Builder(this).setStyle(new NotificationCompat.BigTextStyle().bigText("fbdvdsjfekfjlsfjskfbjsefbsejfjsjdkfbsdbsdubseufhfusefhuiegeiefjselgbsuohsufbsudfbusfseffusfus")).bulid(); 显示超大图片123Notification notification = new NotificationCompat.Builder(this).setStyle(new NotificationCompat.BigPictureStyle.BigPicture(BitmapFactory.decodeResource(getResources(),R.drawable.big_image)));.bulid(); 设置通知的重要程度setPriority()123Notification notification = new NotificationCompat.Builder(this)setPriority(NotificationCompat.PRIORITY_MAX)//最高权限.bulid();]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[playaudiotest]]></title>
    <url>%2F2017%2F07%2F31%2FPlayaudiotest%2F</url>
    <content type="text"><![CDATA[学习目的:1.播放音频 暂停音频 停止音频(MediaPlayer类的使用)权限声明1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; MainActivity类`javapublic class MainActivity extends AppCompatActivity implements View.OnClickListener{ private MediaPlayer mediaPlayer = new MediaPlayer(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button play = (Button) findViewById(R.id.play); Button pause = (Button) findViewById(R.id.pause); Button stop = (Button) findViewById(R.id.stop); play.setOnClickListener(this); pause.setOnClickListener(this); stop.setOnClickListener(this); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(MainActivity.this, new String[]{ Manifest.permission. WRITE_EXTERNAL_STORAGE }, 1); } else { initMediaPlayer(); // 初始化MediaPlayer } } private void initMediaPlayer() { try { File file = new File(Environment.getExternalStorageDirectory(), &quot;music.mp3&quot;); mediaPlayer.setDataSource(file.getPath()); // 指定音频文件的路径 mediaPlayer.prepare(); // 让MediaPlayer进入到准备状态 } catch (Exception e) { e.printStackTrace(); } } @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { switch (requestCode) { case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { initMediaPlayer(); } else { Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); } break; default: } } @Override public void onClick(View v) { switch (v.getId()) { case R.id.play: if (!mediaPlayer.isPlaying()) { mediaPlayer.start(); // 开始播放 } break; case R.id.pause: if (mediaPlayer.isPlaying()) { mediaPlayer.pause(); // 暂停播放 } break; case R.id.stop: if (mediaPlayer.isPlaying()) { mediaPlayer.reset(); // 停止播放 initMediaPlayer(); } break; default: break; } } @Override protected void onDestroy() { super.onDestroy(); if (mediaPlayer != null) { mediaPlayer.stop(); mediaPlayer.release(); } } }]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cameraalbumtest]]></title>
    <url>%2F2017%2F07%2F31%2FCameraalbumtest%2F</url>
    <content type="text"><![CDATA[学习目的：调用系统相册 摄像头123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private ImageView picture; private Uri imageUri; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button takePhoto = (Button) findViewById(R.id.take_photo); Button chooseFromAlbum = (Button) findViewById(R.id.choose_from_album); picture = (ImageView) findViewById(R.id.picture); takePhoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 创建File对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(), "output_image.jpg"); try &#123; if (outputImage.exists()) &#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (Build.VERSION.SDK_INT &lt; 24) &#123; imageUri = Uri.fromFile(outputImage); &#125; else &#123; imageUri = FileProvider.getUriForFile(MainActivity.this, "com.example.cameraalbumtest.fileprovider", outputImage); &#125; // 启动相机程序 Intent intent = new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(intent, TAKE_PHOTO); &#125; &#125;); chooseFromAlbum.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; else &#123; openAlbum(); &#125; &#125; &#125;); &#125; private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO); // 打开相册 &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openAlbum(); &#125; else &#123; Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case TAKE_PHOTO: if (resultCode == RESULT_OK) &#123; try &#123; // 将拍摄的照片显示出来 Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); picture.setImageBitmap(bitmap); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; break; case CHOOSE_PHOTO: if (resultCode == RESULT_OK) &#123; // 判断手机系统版本号 if (Build.VERSION.SDK_INT &gt;= 19) &#123; // 4.4及以上系统使用这个方法处理图片 handleImageOnKitKat(data); &#125; else &#123; // 4.4以下系统使用这个方法处理图片 handleImageBeforeKitKat(data); &#125; &#125; break; default: break; &#125; &#125; @TargetApi(19) private void handleImageOnKitKat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); Log.d("TAG", "handleImageOnKitKat: uri is " + uri); if (DocumentsContract.isDocumentUri(this, uri)) &#123; // 如果是document类型的Uri，则通过document id处理 String docId = DocumentsContract.getDocumentId(uri); if("com.android.providers.media.documents".equals(uri.getAuthority())) &#123; String id = docId.split(":")[1]; // 解析出数字格式的id String selection = MediaStore.Images.Media._ID + "=" + id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection); &#125; else if ("com.android.providers.downloads.documents".equals(uri.getAuthority())) &#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(docId)); imagePath = getImagePath(contentUri, null); &#125; &#125; else if ("content".equalsIgnoreCase(uri.getScheme())) &#123; // 如果是content类型的Uri，则使用普通方式处理 imagePath = getImagePath(uri, null); &#125; else if ("file".equalsIgnoreCase(uri.getScheme())) &#123; // 如果是file类型的Uri，直接获取图片路径即可 imagePath = uri.getPath(); &#125; displayImage(imagePath); // 根据图片路径显示图片 &#125; private void handleImageBeforeKitKat(Intent data) &#123; Uri uri = data.getData(); String imagePath = getImagePath(uri, null); displayImage(imagePath); &#125; private String getImagePath(Uri uri, String selection) &#123; String path = null; // 通过Uri和selection来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri, null, selection, null, null); if (cursor != null) &#123; if (cursor.moveToFirst()) &#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath) &#123; if (imagePath != null) &#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); picture.setImageBitmap(bitmap); &#125; else &#123; Toast.makeText(this, "failed to get image", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[contactstest]]></title>
    <url>%2F2017%2F07%2F30%2FContactstest%2F</url>
    <content type="text"><![CDATA[学习目的:1.读取系统联系人 1.读取系统联系人1&lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;//权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactsList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactsView = (ListView) findViewById(R.id.contacts_view); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout. simple_list_item_1, contactsList); contactsView.setAdapter(adapter); if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(this, new String[]&#123; Manifest.permission.READ_CONTACTS &#125;, 1);//申请权限 &#125; else &#123; readContacts(); &#125; &#125; private void readContacts() &#123; Cursor cursor = null; try &#123; // 查询联系人数据 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; // 获取联系人姓名 String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); // 获取联系人手机号 String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); //ContactsContract.CommonDataKinds.Phone类提供的常量就是uri.parse()解析出来的结果 contactsList.add(displayName + "\n" + number); &#125; adapter.notifyDataSetChanged(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (cursor != null) &#123; cursor.close(); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; readContacts(); &#125; else &#123; Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[databasetest2]]></title>
    <url>%2F2017%2F07%2F30%2FDatabasetest2%2F</url>
    <content type="text"><![CDATA[学习目的:1.实现跨程序数据共享 1.新建内容提供器的两种方法1.新建内容提供器（通过新建一个类继承ContentProvider类的方式创建）重写如下方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DatabaseProvider extends ContentProvider &#123; @Override //初始化内容提供器时调用 这时候数据库完成创建或升级操作 public boolean onCreate() &#123; return false; &#125; @Override //Uri确定那张表 projection确定查询那些列 selection与selectionArgs约束查询哪些行 sortOrder对结果进行排序最后存到Cursor对象中 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return null; &#125; @Override //Uri指定要添加的表 values待添加的数据 public Uri insert(Uri uri, ContentValues values) &#123; return null; &#125; @Override //uri确定哪张表 values新数据保存在此 selection 与 selectionArgs约束更新哪些行 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override //uri确定哪张表 selection 与 selectionArgs约束删除哪些行 public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override //根据传入的uri返回相应的MIME public String getType(Uri uri) &#123; return null; &#125; 2.重点解析uri参数标准的URI写法12345//表示调用方期望访问的是com.eaxmple.app这个应用的tabel表的数据content://com.eaxmple.app.provider/tablel//可以加id//表示调用方期望访问的是com.eaxmple.app这个应用的tabel表中id为1的数据content://com.eaxmple.app.provider/tablel/1 URI格式 * #1234//表示匹配任意表内容content://com.eaxmple.app.provider/*//表示匹配tablel表任意一行内容content://com.eaxmple.app.provider/tablel/# 3.UriMatcher类的math（）方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = "com.example.databasetest.provider"; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI("com.eaxmple.app.provider", "book", BOOK_DIR);//内容提供器 表名 使数据与之关联 uriMatcher.addURI("com.eaxmple.app.provider", "book/#", BOOK_ITEM); uriMatcher.addURI("com.eaxmple.app.provider", "category", CATEGORY_DIR); uriMatcher.addURI("com.eaxmple.app.provider", "category/#", CATEGORY_ITEM); &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 查询数据 switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query("Book", projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query("Book", projection, "id = ?", new String[] &#123; bookId &#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query("Category", projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query("Category", projection, "id = ?", new String[] &#123; categoryId &#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125;1.新建内容提供器（AS快捷方式创建） com.example.broadcasttest-&gt;new-&gt;other-&gt;Content Provider//重写几个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154修改databaseProvider```java//继承内容提供器public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM); uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM); &#125; @Override //创建一个yDatabaseHelper实例 这时候数据库完成创建或升级操作 public boolean onCreate() &#123; dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 查询数据 SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] &#123; bookId &#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;, projection, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;, null, null, sortOrder); break; default: break; &#125; return cursor; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // 添加数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // 更新数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int updatedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Category&quot;, values, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return updatedRows; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // 删除数据 SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] &#123; bookId &#125;); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;, &quot;id = ?&quot;, new String[] &#123; categoryId &#125;); break; default: break; &#125; return deletedRows; &#125; @Override //所有内容提供器都必须提供的方法 用于获取URI对象所对应的MIME类型 MIME由三个部分组成 //1.必须以vnd开头 2.uri以路径结尾则android.cursor.dir/ 以id结尾则android.cursor.item/ 3.最后接上vnd.&lt;authority&gt;.&lt;path&gt; //例如：URI：content://com.eaxmple.app.provider/tabel //MIME:vnd.android.sursor.dir/vnd.com.eaxmple.app.provider.tabel public String getType(Uri uri) &#123; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book&quot;;//返回MIME case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest. provider.category&quot;; &#125; return null; &#125; mydatabaseHalper类12345678910111213141516171819202122232425262728293031323334353637public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK = "create table Book (" + "id integer primary key autoincrement, " + "author text, " + "price real, " + "pages integer, " + "name text)"; public static final String CREATE_CATEGORY = "create table Category (" + "id integer primary key autoincrement, " + "category_name text, " + "category_code integer)"; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); // Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("drop table if exists Book"); db.execSQL("drop table if exists Category"); onCreate(db); &#125;&#125; MianActivity类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2); Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); Button addData = (Button) findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 开始组装第一条数据 values.put("name", "The Da Vinci Code"); values.put("author", "Dan Brown"); values.put("pages", 454); values.put("price", 16.96); db.insert("Book", null, values); // 插入第一条数据 values.clear(); // 开始组装第二条数据 values.put("name", "The Lost Symbol"); values.put("author", "Dan Brown"); values.put("pages", 510); values.put("price", 19.95); db.insert("Book", null, values); // 插入第二条数据 &#125; &#125;); Button updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put("price", 10.99); db.update("Book", values, "name = ?", new String[] &#123; "The Da Vinci Code" &#125;); &#125; &#125;); Button deleteButton = (Button) findViewById(R.id.delete_data); deleteButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); db.delete("Book", "pages &gt; ?", new String[] &#123; "500" &#125;); &#125; &#125;); Button queryButton = (Button) findViewById(R.id.query_data); queryButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); // 查询Book表中所有的数据 Cursor cursor = db.query("Book", null, null, null, null, null, null); if (cursor.moveToFirst()) &#123; do &#123; // 遍历Cursor对象，取出数据并打印 String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("MainActivity", "book name is " + name); Log.d("MainActivity", "book author is " + author); Log.d("MainActivity", "book pages is " + pages); Log.d("MainActivity", "book price is " + price); &#125; while (cursor.moveToNext()); &#125; cursor.close(); &#125; &#125;); &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtimepermissiontest]]></title>
    <url>%2F2017%2F07%2F30%2FRuntimepermissiontest%2F</url>
    <content type="text"><![CDATA[学习目的：1.了解权限及如何申请权限1.了解权限及如何申请权限1234567891011121314151617Button makeCall = (Button) findViewById(R.id.make_call); makeCall.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL);//打电话 intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);``` ```java&lt;uses-permission android:name="android.permission.CALL_PHONE" /&gt; 但在高版本的Android系统会出错 权限问题 permission Denial 修改如下123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button makeCall = (Button) findViewById(R.id.make_call); makeCall.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //判断用户是否已授权 将返回值与PackageManager.PERMISSION_GRANTED比较 if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.CALL_PHONE)!=PackageManager.PERMISSION_GRANTED)&#123; //申请授权 Activity实例 String数组 请求码 ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1); &#125;else&#123; call(); &#125; &#125; &#125;); &#125; private void call() &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; &#125;//判断最后的授权结果 @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBestTest]]></title>
    <url>%2F2017%2F07%2F29%2FDataBestTest%2F</url>
    <content type="text"><![CDATA[学习目的：1.创建数据库 2.升级数据库 3.对数据库的四种操作 4.使用SQL操作数据库 5.使用LitePal操作数据库 1.创建名为BookStore.db数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//MyDatabaseHelperpublic class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK = "create table Book (" + "id integer primary key autoincrement, " + "author text, " + "price real, " + "pages integer, " + "name text)"; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; //MainActivity public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2); Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); &#125; 2.升级数据库(给它加东西) onUpgrade()建表Category12345678910public static final String CREATE_CATEGORY = "create table Category (" + "id integer primary key autoincrement, " + "category_name text, " + "category_code integer)"; public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show(); &#125; onUpgrade()方法12345public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("drop table if exists Book"); db.execSQL("drop table if exists Category"); onCreate(db); &#125; MianActivity123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);//将数据库版本号指定为2 Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); 3.对数据库的四种操作 Create添加 insert（）方法 Retrieve查询 Updata（）方法 Updata更新 Delete删除 1.Create添加 insert（）方法123456789101112131415161718192021Button addData = (Button) findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues();//提供put（）方法 // 开始组装第一条数据 values.put("name", "The Da Vinci Code"); values.put("author", "Dan Brown"); values.put("pages", 454); values.put("price", 16.96); db.insert("Book", null, values); // 插入第一条数据 表名 给空的列赋值null ContentValues对象（提供put（）方法） values.clear(); // 开始组装第二条数据 values.put("name", "The Lost Symbol"); values.put("author", "Dan Brown"); values.put("pages", 510); values.put("price", 19.95); db.insert("Book", null, values); // 插入第二条数据 &#125; &#125;); 2.Updata更新 Updata（）方法1234567891011Button updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put("price", 10.99); db.update("Book", values, "name = ?", new String[] &#123; "The Da Vinci Code" &#125;);//更新name =The Da Vinci Code的这一行 //将名字为he Da Vinci Code的price改为10.99 &#125; &#125;); 3.Delete删除12345678Button deleteButton = (Button) findViewById(R.id.delete_data); deleteButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); db.delete("Book", "pages &gt; ?", new String[] &#123; "500" &#125;);//删除页数超过500页的的boo表中的数据 &#125; &#125;); 4.Retrieve查询 query（）方法1234567891011121314151617181920212223Button queryButton = (Button) findViewById(R.id.query_data); queryButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db = dbHelper.getWritableDatabase(); // 查询Book表中所有的数据 Cursor cursor = db.query("Book", null, null, null, null, null, null);//调用getColumnIndex方法 if (cursor.moveToFirst()) &#123; do &#123; // 遍历Cursor对象，取出数据并打印 String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("MainActivity", "book name is " + name); Log.d("MainActivity", "book author is " + author); Log.d("MainActivity", "book pages is " + pages); Log.d("MainActivity", "book price is " + price); &#125; while (cursor.moveToNext()); &#125; cursor.close(); &#125; &#125;); 使用SQL操作数据库 添加数据 12db.execSQL("insret into Book (name,author,pages,price)values(?,?,?,?)",new String[]&#123;"The Da Vinci Code","Dan Brown ","545","16.96"&#125;);db.execSQL("insret into Book (name,author,pages,price)values(?,?,?,?)",new String[]&#123;"The Lost Symbol","Dan Brown ","545","16.96"&#125;); 更新数据 1db.execSQL("updata Book set price=? where name=?",new String[]&#123;"10.99","The Da Vinci Code"&#125;); 删除数据 1db.execSQL("delete from Book where pages&gt;?,new String[]&#123;"500"&#125;"); 查询数据 1db.rawQuery("select * from Book",null); 5.使用LitePal操作数据库]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LitePal]]></title>
    <url>%2F2017%2F07%2F29%2FLietPal%2F</url>
    <content type="text"><![CDATA[学习目的：1.使用来源库LitePal(使用ORM 对象关系映射)创建数据库 2. 升级数据库(litepal会自动保存更新前的数据) 3.使用LitePal添加数据 1.使用来源库LitePal 配置LitePal 1compile 'org.litepal.android:core:1.3.2' 配置litepal.xml文件 12345678910&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="2" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.example.litepaltest.Book"&gt;&lt;/mapping&gt; &lt;mapping class="com.example.litepaltest.Category"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 用面向对象思维实现建表功能（不用和SQL打交道） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.litepal.crud.DataSupport;public class Book &#123;//Book对应Book表 private int id; private String author; private double price; private int pages; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setPress(String press) &#123; this.press = press; &#125;&#125; 将Book类映射到模型列表中 12345678910&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="2" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.example.litepaltest.Book"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 只需要任意一次数据库操作 BookSrore.db数据库可自动创建1234567Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Connector.getDatabase(); &#125; &#125;); 升级数据库(litepal会自动保存更新前的数据)1234567891011//Book类 private String press; public String getPress() &#123; return press; &#125; public void setPrice(double price) &#123; this.price = price; &#125; 新建表Category 12345678910111213141516171819202122//Category类public class Category &#123; private int id; private String categoryName; private int categoryCode; public void setId(int id) &#123; this.id = id; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public void setCategoryCode(int categoryCode) &#123; this.categoryCode = categoryCode; &#125;&#125; 将Category类映射到模型列表中 12&lt;mapping class="com.example.litepaltest.Category"&gt;&lt;/mapping&gt; 3.使用LitePal添加数据 使Book类继承DataSupport 123public class Book extends DataSupport&#123; ...&#125; 添加数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Button addData = (Button) findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); book.setName("The Da Vinci Code"); book.setAuthor("Dan Brown"); book.setPages(454); book.setPrice(16.96); book.setPress("Unknow"); book.save();//save()由DataSupport继承而来 &#125; &#125;);``` 4.使用LitePal更新数据(1.对已存储（model.isSaved()方法）对象重新设值 2.)```javaButton updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); book.setName("The Lost Symol"); book.setPrice(10.99); book.save(); book.setPrice(14.95);//对象重新设值 book.save(); &#125; &#125;)；``` 更巧妙地方法```javaButton updateData = (Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book = new Book(); book.setPrice(14.95); book.setPress("Anchor"); book.updateAll("name = ? and author = ?", "The Lost Symbol", "Dan Brown"); &#125; &#125;);``` 将数据更新成默认值```javaBook book=new Book();book.setTofault("page");//setTofault()方法将数据更新成默认值book.updateAll(); 5.使用LitePal删除数据 delete()方法1234567Button deleteButton = (Button) findViewById(R.id.delete_data); deleteButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; DataSupport.deleteAll(Book.class, "price &lt; ?", "15"); &#125; &#125;); 6.查询数据 查询API：findALL findFrist findLast1234567891011121314Button queryButton = (Button) findViewById(R.id.query_data); queryButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;Book&gt; books = DataSupport.findAll(Book.class); for (Book book: books) &#123; Log.d("MainActivity", "book name is " + book.getName()); Log.d("MainActivity", "book author is " + book.getAuthor()); Log.d("MainActivity", "book pages is " + book.getPages()); Log.d("MainActivity", "book price is " + book.getPrice()); Log.d("MainActivity", "book press is " + book.getPress()); &#125; &#125; &#125;); 查询API12345678910//select()指定查询哪几列List&lt;Book&gt;books=DataSupport.select("name","author").find(Book.class);//where()指定查询约束条件List&lt;Book&gt;books=DataSupport.where("pages&gt;?","400").find(Book.class);//order()指定结果排序方式List&lt;Book&gt;books=DataSupport.order("price desc").find(Book.class);//limit()查询结果数量List&lt;Book&gt;books=DataSupport.limit(3).find(Book.class);//offset()查询结果偏移量List&lt;Book&gt;books=DataSupport.limit(3).offset().find(Book.class);]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sharedpreferencestest]]></title>
    <url>%2F2017%2F07%2F28%2Fsharedpreferencestest%2F</url>
    <content type="text"><![CDATA[学习目的：1.获取sharedpreferences对象的三种方法 1.获取sharedpreferencestest对象的三种方法 Context类中的getsharedpreferences（） Activity类中的getDefaulsharedpreferences() PreferenceManager类中的getDefaulsharedpreferences() 范例 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button saveData = (Button) findViewById(R.id.save_data); saveData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();//data文件名 editor.putString("name", "Tom");//存储String数据 editor.putInt("age", 28);//存储Int数据 editor.putBoolean("married", false);//存储Boolean数据 editor.apply(); &#125; &#125;);&#125; 读取数据 Button restoreData = (Button) findViewById(R.id.restore_data); restoreData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE); String name = pref.getString("name", ""); int age = pref.getInt("age", 0); boolean married = pref.getBoolean("married", false); Log.d("MainActivity", "name is " + name); Log.d("MainActivity", "age is " + age); Log.d("MainActivity", "married is " + married); } }); }]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filepersistencetest]]></title>
    <url>%2F2017%2F07%2F28%2FFilepersistencetests%2F</url>
    <content type="text"><![CDATA[学习目的：文件存储 将数据保存到文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void save(String inputText) &#123; FileOutputStream out = null; BufferedWriter writer = null; try &#123; out = openFileOutput("data", Context.MODE_PRIVATE);//MODE_PRIVATE指定同一文件名将被覆盖 openFileOutput（）获得FileOutputSteame对象 再借助它构建OutputStreamWriter对象 再使用OutputStreamWriter构建BufferedWriter对象 writer = new BufferedWriter(new OutputStreamWriter(out));// writer.write(inputText); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;``` - 范例```javapublic class MainActivity extends AppCompatActivity &#123; private EditText edit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); edit = (EditText) findViewById(R.id.edit); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText = edit.getText().toString(); save(inputText);//掉用自定义方法 存储输入字符 &#125;``` - 从文件中读取数据```javapublic String load() &#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; in = openFileInput("data");//获取FileInputStream对象data reader = new BufferedReader(new InputStreamReader(in));构建InputStreamReader对象reader String line = ""; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125; 范例 public class MainActivity extends AppCompatActivity { private EditText edit; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); edit = (EditText) findViewById(R.id.edit); String inputText = load(); if (!TextUtils.isEmpty(inputText)) { edit.setText(inputText); edit.setSelection(inputText.length()); Toast.makeText(this, "Restoring succeeded", Toast.LENGTH_SHORT).show(); } }]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActivityLifeCycleText chaper2]]></title>
    <url>%2F2017%2F07%2F27%2FActivityLifeCycleText%2F</url>
    <content type="text"><![CDATA[学习目的：了解活动的运行周期]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BroadCastTest]]></title>
    <url>%2F2017%2F07%2F25%2FBroadCastTest%2F</url>
    <content type="text"><![CDATA[学习目的：1.了解标准广播 有序广播区别(简单，不赘述) 2.接收系统广播 3,发送自定义广播 4.使用本地广播 2.接收系统广播1.动态注册监听网络变化 需要声明权限 12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.broadcasttest&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&gt; 新建NetworkChangeReceiver类 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");//当网络发生变化 系统发出值/为android.net.conn.CONNECTIVITY_CHANGE的广播 要监听什么广播就加什么action networkChangeReceiver = new NetworkChangeReceiver();//新建NetworkChangeReceiver实例 registerReceiver(networkChangeReceiver, intentFilter);//对其进行注册 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver);//动态注册的的广播接收器一定要取消注册 &#125;class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(content,"network changes",Toast.LENGTH_SHORT).show(); &#125; 优化（告诉用户有网还是没网）1234567891011121314151617class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);//ConnectivityManager 系统服务类 专门管理网络getSystemService获得NetworkInfo实例 NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();// if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, "network is available", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, "network is unavailable", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; 2.静态注册监听网路变化直接NEW-other-BoardCastReceriver12345678910public class BoardCompelteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "Board Complete", Toast.LENGTH_SHORT).show(); &#125;&#125; 添加权限(部分自动生成)1234567891011&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;//系统启动时会发android.intent.action.BOOT_COMPLETED值得广播 &lt;/intent-filter&gt; &lt;/receiver&gt; 3,发送自定义广播1.发送标准广播12345678910111213141516171819202122232425262728293031323334353637public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125;添加权限```text&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;``` 按钮启动```javaButton button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST"); sendBroadcast(intent); &#125; &#125;); &lt;h3&gt;2.发送有序广播&lt;/h3&gt;改一行代码```javasendOrderedBroadcast(intent,null);//这时广播接收器有先后顺序 如何定义先后顺序1234567&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt;//100优先级最高 &lt;action android:name="com.example.broadcasttest.MY_BROADCAST"/&gt; &lt;/intent-filter&gt; 是否允许继续传递1234ublic void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show(); abortBroadcast();//表示截断 &#125; 4.使用本地广播1234567891011121314151617181920212223242526272829303132333435363738394041424344ublic class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例 Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent); // 发送本地广播 &#125; &#125;); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");//当网络发生变化 系统发出值/为android.net.conn.CONNECTIVITY_CHANGE的广播 要监听什么广播就加什么action localReceiver = new LocalReceiver();//新建NetworkChangeReceiver实例 localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver); &#125; class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125; &#125; 本地广播的优势不用担心机密数据泄露其他程序将广播发送到我们程序内部比全局广播更高效]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BroadcastBestPractise]]></title>
    <url>%2F2017%2F07%2F24%2FBroadcastBestPractise%2F</url>
    <content type="text"><![CDATA[学习目的：实现登陆成功后强制下线功能(关闭所有活动，返回登陆界面)1.新建ActivityCollector类123456789101112131415161718192021public class ActivityCollector &#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity) &#123; activities.add(activity); &#125; public static void removeActivity(Activity activity) &#123; activities.remove(activity); &#125; public static void finishAll() &#123; for (Activity activity : activities) &#123; if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125; 2.创建BaseActivity类作为所有活动的父类1234567891011121314public class BaseActivity extends AppCompatActivity &#123; private ForceOfflineReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityCollector.addActivity(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125; 3.新建LoginActivity类及其布局(登陆的处理)12345678910111213141516171819202122232425262728293031323334public class LoginActivity extends BaseActivity &#123; private EditText accountEdit; private EditText passwordEdit; private Button login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); accountEdit = (EditText) findViewById(R.id.account); passwordEdit = (EditText) findViewById(R.id.password); login = (Button) findViewById(R.id.login); login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String account = accountEdit.getText().toString(); String password = passwordEdit.getText().toString(); // 如果账号是admin且密码是123456，就认为登录成功 if (account.equals("admin") &amp;&amp; password.equals("123456")) &#123; Intent intent = new Intent(LoginActivity.this, MainActivity.class); startActivity(intent); finish(); &#125; else &#123; Toast.makeText(LoginActivity.this, "account or password is invalid", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 4.修改MainACTIVITY类及其布局123456789101112131415161718public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button forceOffline = (Button) findViewById(R.id.force_offline); forceOffline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcastbestpractice.FORCE_OFFLINE"); sendBroadcast(intent);//发送com.example.broadcastbestpractice.FORCE_OFFLINE广播 表示强制下线 //需要创建广播接收器 &#125; &#125;); &#125;&#125; 在BaseActivity类注册广播接收器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class BaseActivity extends AppCompatActivity &#123; private ForceOfflineReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityCollector.addActivity(this); &#125; @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcastbestpractice.FORCE_OFFLINE"); receiver = new ForceOfflineReceiver(); registerReceiver(receiver, intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); if (receiver != null) &#123; unregisterReceiver(receiver); receiver = null; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125; class ForceOfflineReceiver extends BroadcastReceiver &#123; @Override public void onReceive(final Context context, Intent intent) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context);//创建一个对话框 builder.setTitle("Warning"); builder.setMessage("You are forced to be offline. Please try to login again."); builder.setCancelable(false); //注册确定按钮 builder.setPositiveButton("OK", new DialogInterface.OnClickListener() &#123;//给ok按钮设置点击事件 @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCollector.finishAll(); // 销毁所有活动 Intent intent = new Intent(context, LoginActivity.class); context.startActivity(intent); // 重新启动LoginActivity &#125; &#125;); builder.show(); &#125; &#125;&#125; 将LoginActivity作为主界面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;activity android:name=".LoginActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;``` 完工!chaper6 实现记住密码功能```javapublic class LoginActivity extends BaseActivity &#123; private SharedPreferences pref; private SharedPreferences.Editor editor; private EditText accountEdit; private EditText passwordEdit; private Button login; private CheckBox rememberPass; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); pref = PreferenceManager.getDefaultSharedPreferences(this); accountEdit = (EditText) findViewById(R.id.account); passwordEdit = (EditText) findViewById(R.id.password); rememberPass = (CheckBox) findViewById(R.id.remember_pass); login = (Button) findViewById(R.id.login); boolean isRemember = pref.getBoolean("remember_password", false); if (isRemember) &#123; // 将账号和密码都设置到文本框中 String account = pref.getString("account", ""); String password = pref.getString("password", ""); accountEdit.setText(account); passwordEdit.setText(password); rememberPass.setChecked(true); &#125; login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String account = accountEdit.getText().toString(); String password = passwordEdit.getText().toString(); // 如果账号是admin且密码是123456，就认为登录成功 if (account.equals("admin") &amp;&amp; password.equals("123456")) &#123; editor = pref.edit(); if (rememberPass.isChecked()) &#123; // 检查复选框是否被选中 editor.putBoolean("remember_password", true); editor.putString("account", account); editor.putString("password", password); &#125; else &#123; editor.clear(); &#125; editor.apply(); Intent intent = new Intent(LoginActivity.this, MainActivity.class); startActivity(intent); finish(); &#125; else &#123; Toast.makeText(LoginActivity.this, "account or password is invalid", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentBestPractise]]></title>
    <url>%2F2017%2F07%2F24%2FFragmentBestPractise%2F</url>
    <content type="text"><![CDATA[学习目的：制作简易版新闻应用1.为RecycleView添加依赖1compile 'com.android.support:recyclerview-v7:24.2.1' 2.新建News类1234567891011121314151617181920212223public class News &#123; private String title; private String content; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 3.新建布局news_content_frag1234567891011121314151617181920212223242526272829303132333435363738394041&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/visibility_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:visibility="invisible" &gt; &lt;TextView android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:padding="10dp" android:textSize="20sp" /&gt; &lt;View//分割线 android:layout_width="match_parent" android:layout_height="1dp" android:background="#000" /&gt; &lt;TextView android:id="@+id/news_content" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:padding="15dp" android:textSize="18sp" /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:layout_alignParentLeft="true" android:background="#000" /&gt;&lt;/RelativeLayout&gt; 4.新建NewsContentFragment //加载布局 套路123456789101112131415161718192021public class NewsContentFragment extends Fragment &#123; private View view; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; view = inflater.inflate(R.layout.news_content_frag, container, false);//R.layout 布局文件 return view; &#125; public void refresh(String newsTitle, String newsContent) &#123; View visibilityLayout = view.findViewById(R.id.visibility_layout);//R.id 布局文件中的子布局 如LinerLayout visibilityLayout.setVisibility(View.VISIBLE); TextView newsTitleText = (TextView) view.findViewById (R.id.news_title); TextView newsContentText = (TextView) view.findViewById(R.id.news_content); newsTitleText.setText(newsTitle); // 刷新新闻的标题 newsContentText.setText(newsContent); // 刷新新闻的内容 &#125;&#125; 5.新建newsContentAcyivity及其布局文件news_content news_content 123456&lt;fragment android:id="@+id/news_content_fragment" android:name="com.example.fragmentbestpractice.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; NewsContentActivity类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class NewsContentActivity extends AppCompatActivity &#123; public static void actionStart(Context context, String newsTitle, String newsContent) &#123;//启动活动的最佳写法 Intent intent = new Intent(context, NewsContentActivity.class); intent.putExtra("news_title", newsTitle); intent.putExtra("news_content", newsContent); context.startActivity(intent); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.news_content); String newsTitle = getIntent().getStringExtra("news_title"); // 获取传入的新闻标题 String newsContent = getIntent().getStringExtra("news_content"); // 获取传入的新闻内容 NewsContentFragment newsContentFragment = (NewsContentFragment)getSupportFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(newsTitle, newsContent); // 刷新NewsContentFragment界面 &#125;&#125;``` &lt;h3&gt;6.新建layout-sw600dp文件夹 新建activity_main文件&lt;/h3&gt;- 双页```java&lt;fragment android:id="@+id/news_title_fragment" android:name="com.example.fragmentbestpractice.NewsTitleFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;FrameLayout android:id="@+id/news_content_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" &gt; &lt;fragment android:id="@+id/news_content_fragment" android:name="com.example.fragmentbestpractice.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/FrameLayout&gt;``` &lt;h3&gt;7.在NewsTitleFragment类中新建RecyclerView的适配器内部类NewsAdaper&lt;/h3&gt;- 适配器代码千篇一律，只是参数有变化```javaclass NewsAdapter extends RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt; &#123; private List&lt;News&gt; mNewsList; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView newsTitleText; public ViewHolder(View view) &#123; super(view); newsTitleText = (TextView) view.findViewById(R.id.news_title); &#125; &#125; public NewsAdapter(List&lt;News&gt; newsList) &#123; mNewsList = newsList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_item, parent, false); final ViewHolder holder = new ViewHolder(view); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; News news = mNewsList.get(holder.getAdapterPosition()); if (isTwoPane) &#123; NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(news.getTitle(), news.getContent()); &#125; else &#123; NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent()); &#125; &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; News news = mNewsList.get(position); holder.newsTitleText.setText(news.getTitle()); &#125; @Override public int getItemCount() &#123; return mNewsList.size(); &#125; &#125;&#125; 8.NewsTitleFragment类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class NewsTitleFragment extends Fragment &#123; private boolean isTwoPane; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.news_title_frag, container, false); RecyclerView newsTitleRecyclerView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); newsTitleRecyclerView.setLayoutManager(layoutManager); NewsAdapter adapter = new NewsAdapter(getNews()); newsTitleRecyclerView.setAdapter(adapter); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (getActivity().findViewById(R.id.news_content_layout) != null) &#123; isTwoPane = true; // 可以找到news_content_layout布局时，为双页模式 &#125; else &#123; isTwoPane = false; // 找不到news_content_layout布局时，为单页模式 &#125; &#125; private List&lt;News&gt; getNews() &#123; List&lt;News&gt; newsList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 50; i++) &#123; News news = new News(); news.setTitle("This is news title " + i); news.setContent(getRandomLengthContent("This is news content " + i + ". ")); newsList.add(news); &#125; return newsList; &#125; private String getRandomLengthContent(String content) &#123;//设置随机信息 Random random = new Random(); int length = random.nextInt(20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; builder.append(content); &#125; return builder.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FragmentText]]></title>
    <url>%2F2017%2F07%2F23%2FFragmentText%2F</url>
    <content type="text"><![CDATA[学习目的：1.碎片的简单用法 2.动态添加碎片(创建布局需要加载) 3.碎片 活动之间进行通信 4.加载布局技巧1.碎片的简单用法 1234567891011121314151617181920212223242526272829303132333435类LeftFragment（创建布局需要加载 ，活动也是一样）public class LeftFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,//重写onCreateView()方法 Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.left_fragment, container, false);//将布局动态加载进来 return view; &#125;&#125;类RightFragment（创建布局需要加载 ，活动也是一样）public class RightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,//重写onCreateView()方法 Bundle savedInstanceState) &#123; Log.d(TAG, "onCreateView"); View view = inflater.inflate(R.layout.right_fragment, container, false);//将布局动态加载进来 return view; &#125;布局 &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;fragment android:id="@+id/right_fragment" android:name="com.example.fragmenttest.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" /&gt; 2.动态添加碎片 创建待添加的碎片实例 获取FragmentManager 开启一个事物 向容器内添加或替换碎片 提交事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546布局&lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;FrameLayout//这种布局把所有控件放在左上角 android:id="@+id/right_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt;&lt;/FrameLayout&gt;向FrameLayout里添加内容public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(this); replaceFragment(new RightFragment());//动态添加RightFragment &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: replaceFragment(new AnotherRightFragment());//动态添加AnotherRightFragment break; default: break; &#125; &#125; private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager();//获取FragmentManager FragmentTransaction transaction = fragmentManager.beginTransaction();//开启一个事物 transaction.replace(R.id.right_layout, fragment);//向容器内替换碎片 transaction.addToBackStack(null);//模拟返回栈（碎片中 按back会直接退出 不会返回上一步） transaction.commit();//提交事务 &#125;&#125; 3.碎片 活动之间进行通信 （从布局文件获取碎片实例）调用FragmentManager的findFragmentById() 可以在活动得到相应碎片实例 然后就可调用 1RightFragment rightFragment=(RightFragment)getFragmentManager().findFragmentById(R.id.right_fragment); （碎片调用实例） 用getActivity（） 1MainActivity mainActivity=(MainActivity)getActivity(); 4.碎片的生命周期 onAtach() onCreateView() omActivityCreated() onDestroyView() onDeath() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class RightFragment extends Fragment &#123; public static final String TAG = "RightFragment"; @Override public void onAttach(Context context) &#123; super.onAttach(context); Log.d(TAG, "onAttach"); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, "onCreate"); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.d(TAG, "onCreateView"); View view = inflater.inflate(R.layout.right_fragment, container, false); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.d(TAG, "onActivityCreated"); &#125; @Override public void onStart() &#123; super.onStart(); Log.d(TAG, "onStart"); &#125; @Override public void onResume() &#123; super.onResume(); Log.d(TAG, "onResume"); &#125; @Override public void onPause() &#123; super.onPause(); Log.d(TAG, "onPause"); &#125; @Override public void onStop() &#123; super.onStop(); Log.d(TAG, "onStop"); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.d(TAG, "onDestroyView"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.d(TAG, "onDetach"); &#125;&#125; 4.加载布局技巧 1.限定符small nomal large xlarge(单页手机模式 双页平板模式) 新建layout-large文件夹 在下面创建布局 运行时根据设备自动识别 2.分辨率ldpi hdpi xhdpi xxhdpi 新建layout-sw600dp文件夹 然后新建布局 运行时根据设备自动识别 3.方向 land port 新建layout-land文件夹 然后新建布局 运行时根据设备自动识别]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBestPractise]]></title>
    <url>%2F2017%2F07%2F22%2FUIBestPractise%2F</url>
    <content type="text"><![CDATA[学习目的：1.编写简单聊天软件思路：1.主界面：输入框 发送按钮 2.新建Msg类 3.编写RecyclerView的子布局 4.可见属性（使发送 接受的消息在同一布局内）5.创建RecycleView的适配类 1.主界面(简单 ，不赘述)123456789101112131415161718192021222324252627282930313233&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#d8e0e8&quot; &gt; &lt;android.support.v7.widget.RecyclerView //用于显示聊天内容 android:id=&quot;@+id/msg_recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;EditText android:id=&quot;@+id/input_text&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;Type something here&quot; android:maxLines=&quot;2&quot; /&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Send&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 2.新建Msg类123456789101112131415161718192021222324ublic class Msg &#123; public static final int TYPE_RECEIVED = 0; public static final int TYPE_SENT = 1; private String content;//消息内容 private int type;//消息类型（TYPE_RECEIVED or TYPE_SENT ） public Msg(String content, int type) &#123; this.content = content; this.type = type; &#125; public String getContent() &#123; return content; &#125; public int getType() &#123; return type; &#125;&#125; 3.编写RecyclerView的子布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;10dp&quot; &gt; &lt;LinearLayout android:id=&quot;@+id/left_layout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:background=&quot;@drawable/message_left&quot; &gt; &lt;TextView android:id=&quot;@+id/left_msg&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;10dp&quot; android:textColor=&quot;#fff&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/right_layout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right&quot; android:background=&quot;@drawable/message_right&quot; &gt; &lt;TextView android:id=&quot;@+id/right_msg&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;10dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 5.创建RecycleView的适配类MsgAdaper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MsgAdapter extends RecyclerView.Adapter&lt;MsgAdapter.ViewHolder&gt; &#123; private List&lt;Msg&gt; mMsgList; static class ViewHolder extends RecyclerView.ViewHolder &#123; LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; public ViewHolder(View view) &#123; super(view); leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); leftMsg = (TextView) view.findViewById(R.id.left_msg); rightMsg = (TextView) view.findViewById(R.id.right_msg); &#125; &#125; public MsgAdapter(List&lt;Msg&gt; msgList) &#123; mMsgList = msgList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Msg msg = mMsgList.get(position); if (msg.getType() == Msg.TYPE_RECEIVED) &#123; // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏 holder.leftLayout.setVisibility(View.VISIBLE); holder.rightLayout.setVisibility(View.GONE); holder.leftMsg.setText(msg.getContent()); &#125; else if(msg.getType() == Msg.TYPE_SENT) &#123; // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏 holder.rightLayout.setVisibility(View.VISIBLE); holder.leftLayout.setVisibility(View.GONE); holder.rightMsg.setText(msg.getContent()); &#125; &#125; 6.MainActivity类 private List&lt;Msg&gt; msgList = new ArrayList&lt;Msg&gt;(); private EditText inputText; private Button send; private RecyclerView msgRecyclerView; private MsgAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initMsgs(); // 初始化消息数据 inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view);//都 LinearLayoutManager layoutManager = new LinearLayoutManager(this);//是 msgRecyclerView.setLayoutManager(layoutManager);//套 adapter = new MsgAdapter(msgList);//路 msgRecyclerView.setAdapter(adapter);//啊 send.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String content = inputText.getText().toString(); if (!&quot;&quot;.equals(content)) { Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); adapter.notifyItemInserted(msgList.size() - 1); // 当有新消息时，刷新ListView中的显示 //不是RecycleView吗？ msgRecyclerView.scrollToPosition(msgList.size() - 1); // 将ListView定位到最后一行 //不是RecycleView吗？ inputText.setText(&quot;&quot;); // 清空输入框中的内容 } } });]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView]]></title>
    <url>%2F2017%2F07%2F21%2FRecycleView%2F</url>
    <content type="text"><![CDATA[学习目的：1.RecycleView的基本用法 2.实现横向列表 3.实现瀑布流 4.RecycleView的点击事件（需添加依赖库） 1.RecycleView的基本用法（不止可实现列表 还可实现瀑布流等） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788添加一行代码（依赖）dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:24.2.1&apos; compile &apos;com.android.support:recyclerview-v7:24.2.1&apos;//recycleview定义在suprot库中 需添加依赖库&#125;创建RecycleView布局&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;重写FruitAdaper类（思路：ViewHolder获取子项布局ID再设置监听器）public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123;// 中括号里一般是类名 泛型 private List&lt;Fruit&gt; mFruitList;//定义全局变量 static class ViewHolder extends RecyclerView.ViewHolder &#123;//RecycleView有ViewHolder内部类 View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123;//子项的布局 super(view); fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125; &#125; public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked view &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked image &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123;//对子项数据进行赋值 Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125; MainActivity类 public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits();//初始化数据 自定义方法 RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); LinearLayoutManager layoutManager=new LinearLayoutManager(this);//指定布局方式 可以是横向 竖向 此为竖向 recyclerView.setLayoutManager(layoutManager);//启动自定义布局 FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; 2.实现横向列表（只用加一行代码）123456RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);LinearLayoutManager layoutManager=new LinearLayoutManager(this);//指定布局方式 可以是横向 竖向 此为竖向layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);//横向线性布局 默认为竖向recyclerView.setLayoutManager(layoutManager);//启动自定义布局FruitAdapter adapter = new FruitAdapter(fruitList);recyclerView.setAdapter(adapter); 3.实现瀑布流 (只用加一行代码)1234567RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);LinearLayoutManager layoutManager=new LinearLayoutManager(this);//指定布局方式 可以是横向 竖向 此为竖向StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);//瀑布流 默认为竖向recyclerView.setLayoutManager(layoutManager);//启动自定义布局FruitAdapter adapter = new FruitAdapter(fruitList);recyclerView.setAdapter(adapter); 4.RecycleView的点击事件1234567891011121314151617181920212223242526272829303132333435363738394041不同于ListView（setOnItemClickListener） RecycleView没有点击事件static class ViewHolder extends RecyclerView.ViewHolder &#123;//RecycleView有ViewHolder内部类 View fruitView;//保存最外层子布局实例 ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123;//子项的布局 super(view); fruitView = view;//保存最外层子布局实例 fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125;&#125;public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList;&#125;@Overridepublic ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123;//给RecycleViewS设置点击事件 @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked view &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked image &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder;&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logcat及log]]></title>
    <url>%2F2017%2F07%2F20%2Flogcat%E5%8F%8Alog%2F</url>
    <content type="text"><![CDATA[log12345log.v()//verbose 琐碎日志log.d()//debug调试信息log.i()//比较重要的数据 用户数据log.w()//warnlog.e()//error logcat and 过滤器]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView]]></title>
    <url>%2F2017%2F07%2F20%2FListView%2F</url>
    <content type="text"><![CDATA[学习目的：1.了解ListView（列表）的用法 2.定制listview的界面(自定义适配器) 3.提升ListView的运行效率4.ListView的点击事件 ListView（列表）的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566ListView需要大量数据 来源数据库 或自定义public class MainActivity extends AppCompatActivity &#123; private String[] data=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;c&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArraryAdapter&lt;String&gt;adapter = new ArraryAdapter(MainActivity.this, R.layout.fruit_item, data);//第一个参数 上下文 布局ID 数据名//ArraryAdapter数组适配器 ListView listView = (ListView) findViewById(R.id.list_view);//导入布局id listView.setAdapter(adapter);//启动适配器 &#125; &#125;``` &lt;h3&gt;定制listview的界面&lt;/h3&gt;&lt;img src=&apos;http://img.027cgb.cn/20170722/20177222181775731906.png&apos; /&gt;```Android如：列表每一项包含图片及文字详解每一步：1.两个布局activity_main 及fruit_item(简单，不赘述)2.fruit类（简单，不赘述）public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125;3.FruitAdaper类public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123;//继承ArrayAdaper 从而使之能调用适配器需要的函数 //泛型为fruit类 private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123;//上下文 布局id 列表对象 super(context, textViewResourceId, objects);//调用父类构造函数 及FruitAdapter()等同于ArrayAdaper() resourceId = textViewResourceId;//之所以另定义一个变量来获得textViewResourceId,是怕使用过程中将之改变 &#125;// 重写getView方法(获取到视图类对象的指针，并转换成CAdaptoneViewView 的指针) public View getView(int position, View convertView, ViewGroup parent) &#123;/ /每个子项滚动到屏幕内都会被调用 Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view=layoutInflater.from(getContext()).inflate(resourceId,parent,false);//为子项加载我们传入的布局 ImageView fruitImage=(ImageView)view.findViewById(R.id.fruit_image);//ImageView内部类 TextView fruitName=(TextView)view.findViewById(R.id.fruit_name);//TextView内部类 fruitImage.setImageResouceId(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125; 4.MianActivity类12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;();//用ArrayList（）方法声明一个fruitList列表 指定泛型为Fruit @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);//第一个参数 传入水果对象 布局ID 水果列表 ListView listView = (ListView) findViewById(R.id.list_view);//导入布局id listView.setAdapter(adapter);//启动适配器 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;//给listview设置监听器 @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();//设置逻辑 &#125; &#125;); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i++) &#123;//循环两次是出于谨慎 Fruit apple = new Fruit(&quot;Apple&quot;, R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(&quot;Orange&quot;, R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(&quot;Pear&quot;, R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; 3.ListView的优化123456789101112131415161718192021222324252627282930需要优化的点：1.getView每一次滑动都要将布局重载！（效率低）2.每次getView（）都会通过findViewById获取一次控件实例优化思路 使用convertView参数（布局缓存重用） 新建viewHolder集合类优化后代码：public View getView(int position, View convertView, ViewGroup parent) &#123;//每个子项滚动到屏幕内都会被调用 Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById (R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name); view.setTag(viewHolder); // 将ViewHolder存储在View中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); // 重新获取ViewHolder &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125; 4.ListView的点击事件1234567891011121314151617简单，不赘述。 protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);//第一个参数 传入水果对象 布局ID 水果列表 ListView listView = (ListView) findViewById(R.id.list_view);//导入布局id listView.setAdapter(adapter);//启动适配器 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;//给listview设置监听器 @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();//设置逻辑 &#125; &#125;); &#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build.gradle文件详解]]></title>
    <url>%2F2017%2F07%2F20%2Fbuild.gradle%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[build.gradle(项目目录下)123456789101112131415161718192021buildscript &#123; repositories &#123; jcenter()//代码托管仓库，声明后可引用jcenter上的开源项目 &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.0&apos;//“依赖”文件使用classpath声明一个gradle插件 声明的原因：让gradle知道构建的是Android java 还是c++ //com.android.tools.build:gradle:2.2.0说明构建的是android项目 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter()//代码托管仓库，声明后可引用jcenter上的开源项目 &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; build.gradle(项目目录下)12345678910111213141516171819202122232425apply plugin: &apos;com.android.application&apos;//应用一个插件 两个值可选 应用程序模块 （可直接运行） com.android.library库模块（作为代码库依附别的库运行）android &#123; compileSdkVersion 24 //编译所用sdk版本 buildToolsVersion &quot;24.0.2&quot;//构建工具版本 defaultConfig &#123;//细节配置 applicationId &quot;com.example.helloworld&quot;//项目包名 minSdkVersion 15//最低sdk版本 targetSdkVersion 24//充分测试的sdk版本 versionCode 1//项目版本号 versionName &quot;1.0&quot;//项目版本名 &#125; buildTypes &#123;//生成安装文件的相关配置 release &#123;//release指定生产正式版安装文件的配置 debug闭包指定生成测试版安装文件的配置 minifyEnabled false//指定是否对项目的代码进行混淆 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;//proguardFiles指定混淆的规则文件 //proguard-android.txt通用混淆规则 //proguard-rules.pro自定义混淆规则 &#125; &#125;&#125;dependencies &#123;//指定项目的所有依赖文件 compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)//本地依赖声明 compile &apos;com.android.support:appcompat-v7:24.2.1&apos;//远程依赖声明 testCompile &apos;junit:junit:4.12&apos;//声明测试用例库&#125;]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActivityText]]></title>
    <url>%2F2017%2F07%2F20%2FActivityText%2F</url>
    <content type="text"><![CDATA[学习目的：1.了解standard启动模式 2.singleTop启动模式 3.singleTask启动模式 4.singleInstance启动模式5.实用技巧：知晓当前活动 随时退出程序 启动活动最佳写法 standard启动模式123456789Android是利用返回栈来管理活动的！在standard模式下，每启用一个新活动就会在返回栈入栈并置于栈顶。如：button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123;Intent intent = new Intent(FirstActivity.this, SecondActivity.class);startActivity(intent);&#125;按三次返回键才能退出！ singleTop启动模式12345当栈顶是该活动不创建新实例（与standard的不同之处）android:launchMode=&quot;singleTop&quot;//需要在活动先声明代码同上仅一次back可退出程序 singleTask启动模式12解决重复创建栈顶活动的问题！使某个活动在上下文之存在一个实例。android:launchMode=&quot;singleTask&quot;//需要在活动先声明 singleInstance启动模式12启用一个新的返回栈管理这个活动，解决共享活动实例的问题！android:launchMode=&quot;singleInstance&quot;//需要在活动先声明 知晓当前活动123456789public class BaseActivity extends AppCompatActivity &#123;//无需注册，TM就是个java类 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName()); //需要让BaseActivity成为所有类的父类，因其继承AppCompatActivity,所以其他类功能不变 &#125;&#125; 随时退出程序(思路：创建一个集合类对所有活动进行管理)12345678910111213141516171819202122232425262728public class ActivityCollector &#123; public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();//用List存储活动 public static void addActivity(Activity activity) &#123;//添加活动 activities.add(activity); &#125; public static void removeActivity(Activity activity) &#123;//不多说，看来add remove finish方法都写好啦 activities.remove(activity); &#125; public static void finishAll() &#123; for (Activity activity : activities) &#123;//销毁全部活动 if (!activity.isFinishing()) &#123; activity.finish(); &#125; &#125; &#125;&#125;随时退出举例：Button button3 = (Button) findViewById(R.id.button_3); button3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ActivityCollector.finishAll();&#125;&#125; 启动活动最佳写法123456789101112131415161718为了解决 如secondActivity不是你开发的，但你需要知道启动这个活动需要传递那些数据 等问题原写法：Intent intent = new Intent(FristActivity.this, SecondActivity.class); intent.putExtra("param1", data1); intent.putExtra("param2", data2); startActivity(intent);改进写法：public class SecondActivity extends BaseActivity &#123; public static void actionStart(Context context, String data1, String data2) &#123; Intent intent = new Intent(context, SecondActivity.class); intent.putExtra("param1", data1);//intent传递的数据 intent.putExtra("param2", data2); context.startActivity(intent);//context 上下文 &#125; &#125;只需一行代码启动SecondActivity SecondActivity.actionStart(FirstActivity.this, "data1", "data2"); 标题栏去除方法 android:theme=”@style/Theme.AppCompat.NoActionBar” 其他因为AppCompltActivity 影响 不行]]></content>
      <tags>
        <tag>CODE 2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为修理deepin而学的linux]]></title>
    <url>%2F2017%2F07%2F13%2F%E4%B8%BA%E5%AD%A6%E4%BC%9A%E4%B8%8D%E6%8D%9F%E5%9D%8F%E6%96%87%E4%BB%B6%E8%80%8C%E6%81%A2%E5%A4%8Ddeepin%E5%86%99%E7%9A%84linux%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[常用命令 date 日期 cat 日历 df 磁盘占用率 free 空闲内存数量 文件系统跳转 pwd ls cd 使用 ls 命令的“-l”选项，则结果以长模式输出。 ls -lt –reverse 发序输出 操作文件和目录 cp — 复制文件和目录 mv — 移动/重命名文件和目录 mkdir — 创建目录 rm — 删除文件和目录 ln — 创建硬链接和符号链接 ###]]></content>
  </entry>
  <entry>
    <title><![CDATA[Andriod sdk 更新问题]]></title>
    <url>%2F2017%2F06%2F18%2FANdriod%20sdk%20%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述 123456使用SDK Manager更新时出现问题Failed to fetch URL https://dl-ssl.google.com/android/repository/repository-6.xml, reason: Connection to https://dl-ssl.google.com refusedFailed to fetch URL http://dl-ssl.google.com/android/repository/addons_list-1.xml, reason: Connection to http://dl-ssl.google.com refusedFailed to fetch URL https://dl-ssl.google.com/android/repository/addons_list-1.xml, reason: hostname in certificate didn't match: &lt;dl-ssl.google.com&gt; != &lt;www.google.com&gt;更新ADT时无法解析https://dl-ssl.google.com/android/eclipse 解决办法 由于某些众所周知又无法理解的原因，我们大陆使用Google的服务会出现种种问题，譬如Android开发也会出现阻碍。不过首先要说明的是一般情况下使用SDK Manager更新或者更新Eclipse的ADT插件是没有问题的，我以前也能正常更新，但是昨天不知道节点抽什么风，压根无法连接服务器，出现了上边的种种问题，下面说一下如果网络抽风的话应该如何解决问题。 第一种方法一劳永逸，直接配置VPN，但是现在想找个速度快又稳定还免费的VPN实在不易，尤其是更新SDK，以几kb/s的速度一个文件需要400多分钟，所以也就放弃了VPN。 另一种方法是使用http协议而不是https协议，因为https协议进行了加密处理，大陆因为无法审查，直接封死，而http协议则进行过滤处理，如果不访问乱七八糟的东西，更新个SDK还是没问题的。在SDK Manager下Tools-&gt;Options打开了SDK Manager的Settings，选中“Force https://… sources to be fetched using http://…”，强制使用http协议。而在更新ADT插件的时候则使用网址http://dl-ssl.google.com/android/eclipse，而不是https://dl-ssl.google.com/android/eclipse，这个在官方开发文档里也有介绍。但是昨天的情况就是使用http协议也无法访问。 再说一个比较麻烦的方法，就是直接打开https://dl-ssl.google.com/android/repository/addons_list.xmlhttps://dl-ssl.google.com/android/repository/repository.xmlhttps://dl-ssl.google.com/android/repository/addon.xml这几个文件，找到你要下载的文件名，直接用迅雷下载，ADT可以直接在官网下载ADT包进行安装。具体方法自己搜索。]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置变量时 系统 用户变量的区别]]></title>
    <url>%2F2017%2F06%2F18%2F%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F%E6%97%B6%20%20%E7%B3%BB%E7%BB%9F%20%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[我们在Java运行环境或Android开发环境时，经常要配置环境变量，如图所示， 这里有administrator的用户变量(U)，和系统变量（S），那麽，它们之间有什么区别呢？简单的说，一个是当前用户使用，你用其它用户登陆，这个环境变量就不起作用了。系统变量，是对所有用户都可使用的。简单的说：系统变量：不管以哪个用户名登陆到计算机都能使用；用户变量：只能以设置变量时的用户名登陆才能使用。 如果我们在自己的电脑上运行程序，用户只有一个，看不出系统变量和用户变量的区别，但是，如果一台电脑有多个用户，就能看出用户变量和系统变量的区别了~~PS：我们在配置的时候，一般都是配置系统变量（S），]]></content>
  </entry>
  <entry>
    <title><![CDATA[JDK SDK下载配置]]></title>
    <url>%2F2017%2F06%2F14%2FJDK%20SDK%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1231、JDK(Java Development Kit) 是 Java 语言的软件开发工具包(SDK)。开发Java程序必须要的工具包。2、软件开发工具包（外语首字母缩写：SDK、外语全称：Software Development Kit）一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。这个封装了程序具体实现的细节；例如点击按钮这个事件的具体细节就封装在sdk中，开发者只需要调用相应的方法或接口就可以实现点击按钮的事件处理，具体调用操作系统的细节就有sdk去处理3、ADT是Android开发的eclipse插件，用于打包和封装Android应用 官网下载：http://www.oracle.com/technetwork/java/javase/downloads/index.html 默认安装路径：c:/program files/java 安装成功检验方法：cmd中输入Java -version 配置jdk：https://jingyan.baidu.com/album/f96699bb8b38e0894e3c1bef.html 检验配置成功：JAVAC 别再在这上面浪费时间！！！ Android SDK的安装与环境变量配置 下载SDK tool 再下载sdk 默认安装路径：c:/program files（X86）/Andriod 1、下载Android SDK，点击安装，直接默认路径即可！下载地址：http://developer.android.com/sdk/index.htmlAndroid SDK的安装与环境变量配置 2、默认路径安装后，安装完成，开始配置环境变量。3、打开计算机属性——高级系统设置——环境变量（如上文）4、新建一个环境变量，变量名：ANDROID_HOME，变量值：C:\Program Files (x86)\Android\android-sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹），点击确认。Android SDK的安装与环境变量配置 5、在变量PATH后面加上变量值%ANDROID_HOME%\tools;点击确认即可。 如果没有这个变量，新建一个即可！新建方法见上文！6、Android SDK配置完成，接下来验证配置是否成功。7、点击运行——输入cmd——回车——输入android -h——回车，如果出现一堆英文，如下图所示，即表示配置成功！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品经理练成]]></title>
    <url>%2F2017%2F06%2F04%2F%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[1.象棋主类 文件ChineseChess.Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package cn.edu.ouc.chineseChess; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.util.LinkedList; /** * 象棋主类 * * @author cnlht */ public class ChineseChess extends JFrame implements ActionListener &#123; ChessBoard board = null; Demon demon = null; MakeChessManual record = null; Container con = null; JMenuBar bar; JMenu fileMenu; JMenuItem 制作棋谱, 保存棋谱, 演示棋谱; JFileChooser fileChooser = null; LinkedList 棋谱 = null; public ChineseChess() &#123; bar = new JMenuBar(); fileMenu = new JMenu("中国象棋"); 制作棋谱 = new JMenuItem("制作棋谱"); 保存棋谱 = new JMenuItem("保存棋谱"); 保存棋谱.setEnabled(false); 演示棋谱 = new JMenuItem("演示棋谱"); fileMenu.add(制作棋谱); fileMenu.add(保存棋谱); fileMenu.add(演示棋谱); bar.add(fileMenu); setJMenuBar(bar); setTitle(制作棋谱.getText()); 制作棋谱.addActionListener(this); 保存棋谱.addActionListener(this); 演示棋谱.addActionListener(this); board = new ChessBoard(45, 45, 9, 10); record = board.record; con = getContentPane(); JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true, board, record); split.setDividerSize(5); split.setDividerLocation(460); con.add(split, BorderLayout.CENTER); addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); setVisible(true); setBounds(60, 20, 690, 540); fileChooser = new JFileChooser(); con.validate(); validate(); &#125; public void actionPerformed(ActionEvent e) &#123; if (e.getSource() == 制作棋谱) &#123; con.removeAll(); 保存棋谱.setEnabled(true); this.setTitle(制作棋谱.getText()); board = new ChessBoard(45, 45, 9, 10); record = board.record; JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true, board, record); split.setDividerSize(5); split.setDividerLocation(460); con.add(split, BorderLayout.CENTER); validate(); &#125; if (e.getSource() == 保存棋谱) &#123; int state = fileChooser.showSaveDialog(null); File saveFile = fileChooser.getSelectedFile(); if (saveFile != null &amp;&amp; state == JFileChooser.APPROVE_OPTION) &#123; try &#123; FileOutputStream outOne = new FileOutputStream(saveFile); ObjectOutputStream outTwo = new ObjectOutputStream(outOne); outTwo.writeObject(record.获取棋谱()); outOne.close(); outTwo.close(); &#125; catch (IOException event) &#123; &#125; &#125; &#125; if (e.getSource() == 演示棋谱) &#123; con.removeAll(); con.repaint(); con.validate(); validate(); 保存棋谱.setEnabled(false); int state = fileChooser.showOpenDialog(null); File openFile = fileChooser.getSelectedFile(); if (openFile != null &amp;&amp; state == JFileChooser.APPROVE_OPTION) &#123; try &#123; FileInputStream inOne = new FileInputStream(openFile); ObjectInputStream inTwo = new ObjectInputStream(inOne); 棋谱 = (LinkedList) inTwo.readObject(); inOne.close(); inTwo.close(); ChessBoard board = new ChessBoard(45, 45, 9, 10); demon = new Demon(board); demon.set棋谱(棋谱); con.add(demon, BorderLayout.CENTER); con.validate(); validate(); this.setTitle(演示棋谱.getText() + ":" + openFile); &#125; catch (Exception event) &#123; JLabel label = new JLabel("不是棋谱文件"); label.setFont(new Font("隶书", Font.BOLD, 60)); label.setForeground(Color.red); label.setHorizontalAlignment(SwingConstants.CENTER); con.add(label, BorderLayout.CENTER); con.validate(); this.setTitle("没有打开棋谱"); validate(); &#125; &#125; else &#123; JLabel label = new JLabel("没有打开棋谱文件呢"); label.setFont(new Font("隶书", Font.BOLD, 50)); label.setForeground(Color.pink); label.setHorizontalAlignment(SwingConstants.CENTER); con.add(label, BorderLayout.CENTER); con.validate(); this.setTitle("没有打开棋谱文件呢"); validate(); &#125; &#125; &#125; public static void main(String args[]) &#123; new ChineseChess(); &#125; &#125; 2.象棋棋盘类文件ChessBoard.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369package cn.edu.ouc.chineseChess; import javax.swing.*; import java.awt.*; import java.awt.event.*; /** * 棋盘类 * * @author cnlht */ public class ChessBoard extends JPanel implements MouseListener, MouseMotionListener &#123; public ChessPoint point[][]; public int unitWidth, unitHeight; private int x轴长, y轴长; private int x, y; private Image img; protected Image pieceImg; private boolean move = false; public String 红方颜色 = "红方", 黑方颜色 = "黑方"; ChessPiece 红车1, 红车2, 红马1, 红马2, 红相1, 红相2, 红帅, 红士1, 红士2, 红兵1, 红兵2, 红兵3, 红兵4, 红兵5, 红炮1, 红炮2; ChessPiece 黑车1, 黑车2, 黑马1, 黑马2, 黑将, 黑士1, 黑士2, 黑卒1, 黑卒2, 黑卒3, 黑卒4, 黑卒5, 黑象1, 黑象2, 黑炮1, 黑炮2; int startX, startY; int startI, startJ; public boolean 红方走棋 = true, 黑方走棋 = false; Rule rule = null; public MakeChessManual record = null; public ChessBoard(int w, int h, int r, int c) &#123; setLayout(null); addMouseListener(this); addMouseMotionListener(this); Color bc = getBackground(); unitWidth = w; unitHeight = h; x轴长 = r; y轴长 = c; point = new ChessPoint[r + 1][c + 1]; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; point[i][j] = new ChessPoint(i * unitWidth, j * unitHeight, false); &#125; &#125; rule = new Rule(this, point); record = new MakeChessManual(this, point); img = Toolkit.getDefaultToolkit().getImage("board.jpg"); pieceImg = Toolkit.getDefaultToolkit().getImage("piece.gif"); 红车1 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车1.set棋子类别(红方颜色); 红车2 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车2.set棋子类别(红方颜色); 红马1 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马1.set棋子类别(红方颜色); 红马2 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马2.set棋子类别(红方颜色); 红炮1 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮1.set棋子类别(红方颜色); 红炮2 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮2.set棋子类别(红方颜色); 红相1 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相1.set棋子类别(红方颜色); 红相2 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相2.set棋子类别(红方颜色); 红士1 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士1.set棋子类别(红方颜色); 红士2 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士2.set棋子类别(红方颜色); 红帅 = new ChessPiece("帅", Color.red, bc, w - 4, h - 4, this); 红帅.set棋子类别(红方颜色); 红兵1 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵1.set棋子类别(红方颜色); 红兵2 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵2.set棋子类别(红方颜色); 红兵3 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵3.set棋子类别(红方颜色); 红兵4 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵4.set棋子类别(红方颜色); 红兵5 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵5.set棋子类别(红方颜色); 黑将 = new ChessPiece("将", Color.black, bc, w - 4, h - 4, this); 黑将.set棋子类别(黑方颜色); 黑士1 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士1.set棋子类别(黑方颜色); 黑士2 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士2.set棋子类别(黑方颜色); 黑车1 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车1.set棋子类别(黑方颜色); 黑车2 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车2.set棋子类别(黑方颜色); 黑炮1 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮1.set棋子类别(黑方颜色); 黑炮2 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮2.set棋子类别(黑方颜色); 黑象1 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象1.set棋子类别(黑方颜色); 黑象2 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象2.set棋子类别(黑方颜色); 黑马1 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马1.set棋子类别(黑方颜色); 黑马2 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马2.set棋子类别(黑方颜色); 黑卒1 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒1.set棋子类别(黑方颜色); 黑卒2 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒2.set棋子类别(黑方颜色); 黑卒3 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒3.set棋子类别(黑方颜色); 黑卒4 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒4.set棋子类别(黑方颜色); 黑卒5 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒5.set棋子类别(黑方颜色); point[1][10].setPiece(红车1, this); point[2][10].setPiece(红马1, this); point[3][10].setPiece(红相1, this); point[4][10].setPiece(红士1, this); point[5][10].setPiece(红帅, this); point[6][10].setPiece(红士2, this); point[7][10].setPiece(红相2, this); point[8][10].setPiece(红马2, this); point[9][10].setPiece(红车2, this); point[2][8].setPiece(红炮1, this); point[8][8].setPiece(红炮2, this); point[1][7].setPiece(红兵1, this); point[3][7].setPiece(红兵2, this); point[5][7].setPiece(红兵3, this); point[7][7].setPiece(红兵4, this); point[9][7].setPiece(红兵5, this); point[1][1].setPiece(黑车1, this); point[2][1].setPiece(黑马1, this); point[3][1].setPiece(黑象1, this); point[4][1].setPiece(黑士1, this); point[5][1].setPiece(黑将, this); point[6][1].setPiece(黑士2, this); point[7][1].setPiece(黑象2, this); point[8][1].setPiece(黑马2, this); point[9][1].setPiece(黑车2, this); point[2][3].setPiece(黑炮1, this); point[8][3].setPiece(黑炮2, this); point[1][4].setPiece(黑卒1, this); point[3][4].setPiece(黑卒2, this); point[5][4].setPiece(黑卒3, this); point[7][4].setPiece(黑卒4, this); point[9][4].setPiece(黑卒5, this); &#125; public void paintComponent(Graphics g) &#123; super.paintComponent(g); int imgWidth = img.getWidth(this); int imgHeight = img.getHeight(this);// 获得图片的宽度与高度 int FWidth = getWidth(); int FHeight = getHeight();// 获得窗口的宽度与高度 int x = (FWidth - imgWidth) / 2; int y = (FHeight - imgHeight) / 2; g.drawImage(img, x, y, null); for (int j = 1; j &lt;= y轴长; j++) &#123; g.drawLine(point[1][j].x, point[1][j].y, point[x轴长][j].x, point[x轴长][j].y); &#125; for (int i = 1; i &lt;= x轴长; i++) &#123; if (i != 1 &amp;&amp; i != x轴长) &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长 - 5].x, point[i][y轴长 - 5].y); g.drawLine(point[i][y轴长 - 4].x, point[i][y轴长 - 4].y, point[i][y轴长].x, point[i][y轴长].y); &#125; else &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长].x, point[i][y轴长].y); &#125; &#125; g.drawLine(point[4][1].x, point[4][1].y, point[6][3].x, point[6][3].y); g.drawLine(point[6][1].x, point[6][1].y, point[4][3].x, point[4][3].y); g.drawLine(point[4][8].x, point[4][8].y, point[6][y轴长].x, point[6][y轴长].y); g.drawLine(point[4][y轴长].x, point[4][y轴长].y, point[6][8].x, point[6][8].y); for (int i = 1; i &lt;= x轴长; i++) &#123; g.drawString("" + i, i * unitWidth, unitHeight / 2); &#125; int j = 1; for (char c = 'A'; c &lt;= 'J'; c++) &#123; g.drawString("" + c, unitWidth / 4, j * unitHeight); j++; &#125; &#125; /**鼠标按下事件*/ public void mousePressed(MouseEvent e) &#123; ChessPiece piece = null; Rectangle rect = null; if (e.getSource() == this) move = false; if (move == false) if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); startX = piece.getBounds().x; startY = piece.getBounds().y; rect = piece.getBounds(); for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; int x = point[i][j].getX(); int y = point[i][j].getY(); if (rect.contains(x, y)) &#123; startI = i; startJ = j; break; &#125; &#125; &#125; &#125; &#125; public void mouseMoved(MouseEvent e) &#123; &#125; /**鼠标拖动事件*/ public void mouseDragged(MouseEvent e) &#123; ChessPiece piece = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); move = true; e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; if (move &amp;&amp; piece != null) &#123; x = e.getX(); y = e.getY(); if (红方走棋 &amp;&amp; ((piece.棋子类别()).equals(红方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; if (黑方走棋 &amp;&amp; (piece.棋子类别().equals(黑方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; &#125; &#125; &#125; /**松开鼠标事件*/ public void mouseReleased(MouseEvent e) &#123; ChessPiece piece = null; move = false; Rectangle rect = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); rect = piece.getBounds(); e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; boolean containChessPoint = false; int x = 0, y = 0; int m = 0, n = 0; if (piece != null) &#123; for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; x = point[i][j].getX(); y = point[i][j].getY(); if (rect.contains(x, y)) &#123; containChessPoint = true; m = i; n = j; break; &#125; &#125; &#125; &#125; if (piece != null &amp;&amp; containChessPoint) &#123; Color pieceColor = piece.获取棋子颜色(); if (point[m][n].isPiece()) &#123; Color c = (point[m][n].getPiece()).获取棋子颜色(); if (pieceColor.getRGB() == c.getRGB()) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; else &#123; boolean ok = rule.movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; ChessPiece pieceRemoved = point[m][n].getPiece(); point[m][n].reMovePiece(pieceRemoved, this); point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子(pieceRemoved); rule.isWine(pieceRemoved); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; validate(); repaint(); &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; else &#123; boolean ok = rule .movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子("没吃棋子"); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; if (piece != null &amp;&amp; !containChessPoint) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; public void mouseEntered(MouseEvent e) &#123; &#125; public void mouseExited(MouseEvent e) &#123; &#125; public void mouseClicked(MouseEvent e) &#123; &#125; &#125; 3.棋子类文件ChessPiece.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.edu.ouc.chineseChess; import javax.swing.*; import java.awt.*; import java.awt.event.*; /** * 棋子类 * * @author cnlht */ public class ChessPiece extends JLabel &#123; String name; // 棋子名字 Color backColor = null, foreColor;// 背景色和前景色 String 颜色类别 = null; ChessBoard board = null; int width, height;// 大小 public ChessPiece(String name, Color fc, Color bc, int width, int height, ChessBoard board) &#123;// 构造棋子 this.name = name; this.board = board; this.width = width; this.height = height; foreColor = fc; backColor = bc; setSize(width, height); setBackground(bc); addMouseMotionListener(board); addMouseListener(board); &#125; // 绘制棋子 public void paint(Graphics g) &#123; g.drawImage(board.pieceImg, 2, 2, width-2, height-2, null); g.setColor(foreColor); g.setFont(new Font("楷体", Font.BOLD, 26)); g.drawString(name, 7, height - 8);// 在棋子上绘制 “棋子名” g.setColor(Color.black); //g.drawOval(1, 1, width - 1, height - 1); float lineWidth = 2.3f; ((Graphics2D)g).setStroke(new BasicStroke(lineWidth)); ((Graphics2D)g).drawOval(2, 2, width-2, height-2); &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public String getName() &#123; return name; &#125; public Color 获取棋子颜色() &#123; return foreColor; &#125; public void set棋子类别(String 类别) &#123; 颜色类别 = 类别; &#125; public String 棋子类别() &#123; return 颜色类别; &#125; &#125; 04 ChessPoint类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369package cn.edu.ouc.chineseChess; import javax.swing.*; import java.awt.*; import java.awt.event.*; /** * 棋盘类 * * @author cnlht */ public class ChessBoard extends JPanel implements MouseListener, MouseMotionListener &#123; public ChessPoint point[][]; public int unitWidth, unitHeight; private int x轴长, y轴长; private int x, y; private Image img; protected Image pieceImg; private boolean move = false; public String 红方颜色 = "红方", 黑方颜色 = "黑方"; ChessPiece 红车1, 红车2, 红马1, 红马2, 红相1, 红相2, 红帅, 红士1, 红士2, 红兵1, 红兵2, 红兵3, 红兵4, 红兵5, 红炮1, 红炮2; ChessPiece 黑车1, 黑车2, 黑马1, 黑马2, 黑将, 黑士1, 黑士2, 黑卒1, 黑卒2, 黑卒3, 黑卒4, 黑卒5, 黑象1, 黑象2, 黑炮1, 黑炮2; int startX, startY; int startI, startJ; public boolean 红方走棋 = true, 黑方走棋 = false; Rule rule = null; public MakeChessManual record = null; public ChessBoard(int w, int h, int r, int c) &#123; setLayout(null); addMouseListener(this); addMouseMotionListener(this); Color bc = getBackground(); unitWidth = w; unitHeight = h; x轴长 = r; y轴长 = c; point = new ChessPoint[r + 1][c + 1]; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; point[i][j] = new ChessPoint(i * unitWidth, j * unitHeight, false); &#125; &#125; rule = new Rule(this, point); record = new MakeChessManual(this, point); img = Toolkit.getDefaultToolkit().getImage("board.jpg"); pieceImg = Toolkit.getDefaultToolkit().getImage("piece.gif"); 红车1 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车1.set棋子类别(红方颜色); 红车2 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车2.set棋子类别(红方颜色); 红马1 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马1.set棋子类别(红方颜色); 红马2 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马2.set棋子类别(红方颜色); 红炮1 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮1.set棋子类别(红方颜色); 红炮2 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮2.set棋子类别(红方颜色); 红相1 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相1.set棋子类别(红方颜色); 红相2 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相2.set棋子类别(红方颜色); 红士1 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士1.set棋子类别(红方颜色); 红士2 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士2.set棋子类别(红方颜色); 红帅 = new ChessPiece("帅", Color.red, bc, w - 4, h - 4, this); 红帅.set棋子类别(红方颜色); 红兵1 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵1.set棋子类别(红方颜色); 红兵2 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵2.set棋子类别(红方颜色); 红兵3 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵3.set棋子类别(红方颜色); 红兵4 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵4.set棋子类别(红方颜色); 红兵5 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵5.set棋子类别(红方颜色); 黑将 = new ChessPiece("将", Color.black, bc, w - 4, h - 4, this); 黑将.set棋子类别(黑方颜色); 黑士1 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士1.set棋子类别(黑方颜色); 黑士2 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士2.set棋子类别(黑方颜色); 黑车1 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车1.set棋子类别(黑方颜色); 黑车2 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车2.set棋子类别(黑方颜色); 黑炮1 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮1.set棋子类别(黑方颜色); 黑炮2 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮2.set棋子类别(黑方颜色); 黑象1 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象1.set棋子类别(黑方颜色); 黑象2 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象2.set棋子类别(黑方颜色); 黑马1 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马1.set棋子类别(黑方颜色); 黑马2 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马2.set棋子类别(黑方颜色); 黑卒1 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒1.set棋子类别(黑方颜色); 黑卒2 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒2.set棋子类别(黑方颜色); 黑卒3 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒3.set棋子类别(黑方颜色); 黑卒4 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒4.set棋子类别(黑方颜色); 黑卒5 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒5.set棋子类别(黑方颜色); point[1][10].setPiece(红车1, this); point[2][10].setPiece(红马1, this); point[3][10].setPiece(红相1, this); point[4][10].setPiece(红士1, this); point[5][10].setPiece(红帅, this); point[6][10].setPiece(红士2, this); point[7][10].setPiece(红相2, this); point[8][10].setPiece(红马2, this); point[9][10].setPiece(红车2, this); point[2][8].setPiece(红炮1, this); point[8][8].setPiece(红炮2, this); point[1][7].setPiece(红兵1, this); point[3][7].setPiece(红兵2, this); point[5][7].setPiece(红兵3, this); point[7][7].setPiece(红兵4, this); point[9][7].setPiece(红兵5, this); point[1][1].setPiece(黑车1, this); point[2][1].setPiece(黑马1, this); point[3][1].setPiece(黑象1, this); point[4][1].setPiece(黑士1, this); point[5][1].setPiece(黑将, this); point[6][1].setPiece(黑士2, this); point[7][1].setPiece(黑象2, this); point[8][1].setPiece(黑马2, this); point[9][1].setPiece(黑车2, this); point[2][3].setPiece(黑炮1, this); point[8][3].setPiece(黑炮2, this); point[1][4].setPiece(黑卒1, this); point[3][4].setPiece(黑卒2, this); point[5][4].setPiece(黑卒3, this); point[7][4].setPiece(黑卒4, this); point[9][4].setPiece(黑卒5, this); &#125; public void paintComponent(Graphics g) &#123; super.paintComponent(g); int imgWidth = img.getWidth(this); int imgHeight = img.getHeight(this);// 获得图片的宽度与高度 int FWidth = getWidth(); int FHeight = getHeight();// 获得窗口的宽度与高度 int x = (FWidth - imgWidth) / 2; int y = (FHeight - imgHeight) / 2; g.drawImage(img, x, y, null); for (int j = 1; j &lt;= y轴长; j++) &#123; g.drawLine(point[1][j].x, point[1][j].y, point[x轴长][j].x, point[x轴长][j].y); &#125; for (int i = 1; i &lt;= x轴长; i++) &#123; if (i != 1 &amp;&amp; i != x轴长) &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长 - 5].x, point[i][y轴长 - 5].y); g.drawLine(point[i][y轴长 - 4].x, point[i][y轴长 - 4].y, point[i][y轴长].x, point[i][y轴长].y); &#125; else &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长].x, point[i][y轴长].y); &#125; &#125; g.drawLine(point[4][1].x, point[4][1].y, point[6][3].x, point[6][3].y); g.drawLine(point[6][1].x, point[6][1].y, point[4][3].x, point[4][3].y); g.drawLine(point[4][8].x, point[4][8].y, point[6][y轴长].x, point[6][y轴长].y); g.drawLine(point[4][y轴长].x, point[4][y轴长].y, point[6][8].x, point[6][8].y); for (int i = 1; i &lt;= x轴长; i++) &#123; g.drawString("" + i, i * unitWidth, unitHeight / 2); &#125; int j = 1; for (char c = 'A'; c &lt;= 'J'; c++) &#123; g.drawString("" + c, unitWidth / 4, j * unitHeight); j++; &#125; &#125; /**鼠标按下事件*/ public void mousePressed(MouseEvent e) &#123; ChessPiece piece = null; Rectangle rect = null; if (e.getSource() == this) move = false; if (move == false) if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); startX = piece.getBounds().x; startY = piece.getBounds().y; rect = piece.getBounds(); for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; int x = point[i][j].getX(); int y = point[i][j].getY(); if (rect.contains(x, y)) &#123; startI = i; startJ = j; break; &#125; &#125; &#125; &#125; &#125; public void mouseMoved(MouseEvent e) &#123; &#125; /**鼠标拖动事件*/ public void mouseDragged(MouseEvent e) &#123; ChessPiece piece = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); move = true; e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; if (move &amp;&amp; piece != null) &#123; x = e.getX(); y = e.getY(); if (红方走棋 &amp;&amp; ((piece.棋子类别()).equals(红方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; if (黑方走棋 &amp;&amp; (piece.棋子类别().equals(黑方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; &#125; &#125; &#125; /**松开鼠标事件*/ public void mouseReleased(MouseEvent e) &#123; ChessPiece piece = null; move = false; Rectangle rect = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); rect = piece.getBounds(); e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; boolean containChessPoint = false; int x = 0, y = 0; int m = 0, n = 0; if (piece != null) &#123; for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; x = point[i][j].getX(); y = point[i][j].getY(); if (rect.contains(x, y)) &#123; containChessPoint = true; m = i; n = j; break; &#125; &#125; &#125; &#125; if (piece != null &amp;&amp; containChessPoint) &#123; Color pieceColor = piece.获取棋子颜色(); if (point[m][n].isPiece()) &#123; Color c = (point[m][n].getPiece()).获取棋子颜色(); if (pieceColor.getRGB() == c.getRGB()) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; else &#123; boolean ok = rule.movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; ChessPiece pieceRemoved = point[m][n].getPiece(); point[m][n].reMovePiece(pieceRemoved, this); point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子(pieceRemoved); rule.isWine(pieceRemoved); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; validate(); repaint(); &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; else &#123; boolean ok = rule .movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子("没吃棋子"); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; if (piece != null &amp;&amp; !containChessPoint) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; public void mouseEntered(MouseEvent e) &#123; &#125; public void mouseExited(MouseEvent e) &#123; &#125; public void mouseClicked(MouseEvent e) &#123; &#125; &#125; 05 Demon类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369package cn.edu.ouc.chineseChess; import javax.swing.*; import java.awt.*; import java.awt.event.*; /** * 棋盘类 * * @author cnlht */ public class ChessBoard extends JPanel implements MouseListener, MouseMotionListener &#123; public ChessPoint point[][]; public int unitWidth, unitHeight; private int x轴长, y轴长; private int x, y; private Image img; protected Image pieceImg; private boolean move = false; public String 红方颜色 = "红方", 黑方颜色 = "黑方"; ChessPiece 红车1, 红车2, 红马1, 红马2, 红相1, 红相2, 红帅, 红士1, 红士2, 红兵1, 红兵2, 红兵3, 红兵4, 红兵5, 红炮1, 红炮2; ChessPiece 黑车1, 黑车2, 黑马1, 黑马2, 黑将, 黑士1, 黑士2, 黑卒1, 黑卒2, 黑卒3, 黑卒4, 黑卒5, 黑象1, 黑象2, 黑炮1, 黑炮2; int startX, startY; int startI, startJ; public boolean 红方走棋 = true, 黑方走棋 = false; Rule rule = null; public MakeChessManual record = null; public ChessBoard(int w, int h, int r, int c) &#123; setLayout(null); addMouseListener(this); addMouseMotionListener(this); Color bc = getBackground(); unitWidth = w; unitHeight = h; x轴长 = r; y轴长 = c; point = new ChessPoint[r + 1][c + 1]; for (int i = 1; i &lt;= r; i++) &#123; for (int j = 1; j &lt;= c; j++) &#123; point[i][j] = new ChessPoint(i * unitWidth, j * unitHeight, false); &#125; &#125; rule = new Rule(this, point); record = new MakeChessManual(this, point); img = Toolkit.getDefaultToolkit().getImage("board.jpg"); pieceImg = Toolkit.getDefaultToolkit().getImage("piece.gif"); 红车1 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车1.set棋子类别(红方颜色); 红车2 = new ChessPiece("車", Color.red, bc, w - 4, h - 4, this); 红车2.set棋子类别(红方颜色); 红马1 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马1.set棋子类别(红方颜色); 红马2 = new ChessPiece("馬", Color.red, bc, w - 4, h - 4, this); 红马2.set棋子类别(红方颜色); 红炮1 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮1.set棋子类别(红方颜色); 红炮2 = new ChessPiece("炮", Color.red, bc, w - 4, h - 4, this); 红炮2.set棋子类别(红方颜色); 红相1 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相1.set棋子类别(红方颜色); 红相2 = new ChessPiece("相", Color.red, bc, w - 4, h - 4, this); 红相2.set棋子类别(红方颜色); 红士1 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士1.set棋子类别(红方颜色); 红士2 = new ChessPiece("仕", Color.red, bc, w - 4, h - 4, this); 红士2.set棋子类别(红方颜色); 红帅 = new ChessPiece("帅", Color.red, bc, w - 4, h - 4, this); 红帅.set棋子类别(红方颜色); 红兵1 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵1.set棋子类别(红方颜色); 红兵2 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵2.set棋子类别(红方颜色); 红兵3 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵3.set棋子类别(红方颜色); 红兵4 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵4.set棋子类别(红方颜色); 红兵5 = new ChessPiece("兵", Color.red, bc, w - 4, h - 4, this); 红兵5.set棋子类别(红方颜色); 黑将 = new ChessPiece("将", Color.black, bc, w - 4, h - 4, this); 黑将.set棋子类别(黑方颜色); 黑士1 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士1.set棋子类别(黑方颜色); 黑士2 = new ChessPiece("士", Color.black, bc, w - 4, h - 4, this); 黑士2.set棋子类别(黑方颜色); 黑车1 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车1.set棋子类别(黑方颜色); 黑车2 = new ChessPiece("车", Color.black, bc, w - 4, h - 4, this); 黑车2.set棋子类别(黑方颜色); 黑炮1 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮1.set棋子类别(黑方颜色); 黑炮2 = new ChessPiece("炮", Color.black, bc, w - 4, h - 4, this); 黑炮2.set棋子类别(黑方颜色); 黑象1 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象1.set棋子类别(黑方颜色); 黑象2 = new ChessPiece("象", Color.black, bc, w - 4, h - 4, this); 黑象2.set棋子类别(黑方颜色); 黑马1 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马1.set棋子类别(黑方颜色); 黑马2 = new ChessPiece("马", Color.black, bc, w - 4, h - 4, this); 黑马2.set棋子类别(黑方颜色); 黑卒1 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒1.set棋子类别(黑方颜色); 黑卒2 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒2.set棋子类别(黑方颜色); 黑卒3 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒3.set棋子类别(黑方颜色); 黑卒4 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒4.set棋子类别(黑方颜色); 黑卒5 = new ChessPiece("卒", Color.black, bc, w - 4, h - 4, this); 黑卒5.set棋子类别(黑方颜色); point[1][10].setPiece(红车1, this); point[2][10].setPiece(红马1, this); point[3][10].setPiece(红相1, this); point[4][10].setPiece(红士1, this); point[5][10].setPiece(红帅, this); point[6][10].setPiece(红士2, this); point[7][10].setPiece(红相2, this); point[8][10].setPiece(红马2, this); point[9][10].setPiece(红车2, this); point[2][8].setPiece(红炮1, this); point[8][8].setPiece(红炮2, this); point[1][7].setPiece(红兵1, this); point[3][7].setPiece(红兵2, this); point[5][7].setPiece(红兵3, this); point[7][7].setPiece(红兵4, this); point[9][7].setPiece(红兵5, this); point[1][1].setPiece(黑车1, this); point[2][1].setPiece(黑马1, this); point[3][1].setPiece(黑象1, this); point[4][1].setPiece(黑士1, this); point[5][1].setPiece(黑将, this); point[6][1].setPiece(黑士2, this); point[7][1].setPiece(黑象2, this); point[8][1].setPiece(黑马2, this); point[9][1].setPiece(黑车2, this); point[2][3].setPiece(黑炮1, this); point[8][3].setPiece(黑炮2, this); point[1][4].setPiece(黑卒1, this); point[3][4].setPiece(黑卒2, this); point[5][4].setPiece(黑卒3, this); point[7][4].setPiece(黑卒4, this); point[9][4].setPiece(黑卒5, this); &#125; public void paintComponent(Graphics g) &#123; super.paintComponent(g); int imgWidth = img.getWidth(this); int imgHeight = img.getHeight(this);// 获得图片的宽度与高度 int FWidth = getWidth(); int FHeight = getHeight();// 获得窗口的宽度与高度 int x = (FWidth - imgWidth) / 2; int y = (FHeight - imgHeight) / 2; g.drawImage(img, x, y, null); for (int j = 1; j &lt;= y轴长; j++) &#123; g.drawLine(point[1][j].x, point[1][j].y, point[x轴长][j].x, point[x轴长][j].y); &#125; for (int i = 1; i &lt;= x轴长; i++) &#123; if (i != 1 &amp;&amp; i != x轴长) &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长 - 5].x, point[i][y轴长 - 5].y); g.drawLine(point[i][y轴长 - 4].x, point[i][y轴长 - 4].y, point[i][y轴长].x, point[i][y轴长].y); &#125; else &#123; g.drawLine(point[i][1].x, point[i][1].y, point[i][y轴长].x, point[i][y轴长].y); &#125; &#125; g.drawLine(point[4][1].x, point[4][1].y, point[6][3].x, point[6][3].y); g.drawLine(point[6][1].x, point[6][1].y, point[4][3].x, point[4][3].y); g.drawLine(point[4][8].x, point[4][8].y, point[6][y轴长].x, point[6][y轴长].y); g.drawLine(point[4][y轴长].x, point[4][y轴长].y, point[6][8].x, point[6][8].y); for (int i = 1; i &lt;= x轴长; i++) &#123; g.drawString("" + i, i * unitWidth, unitHeight / 2); &#125; int j = 1; for (char c = 'A'; c &lt;= 'J'; c++) &#123; g.drawString("" + c, unitWidth / 4, j * unitHeight); j++; &#125; &#125; /**鼠标按下事件*/ public void mousePressed(MouseEvent e) &#123; ChessPiece piece = null; Rectangle rect = null; if (e.getSource() == this) move = false; if (move == false) if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); startX = piece.getBounds().x; startY = piece.getBounds().y; rect = piece.getBounds(); for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; int x = point[i][j].getX(); int y = point[i][j].getY(); if (rect.contains(x, y)) &#123; startI = i; startJ = j; break; &#125; &#125; &#125; &#125; &#125; public void mouseMoved(MouseEvent e) &#123; &#125; /**鼠标拖动事件*/ public void mouseDragged(MouseEvent e) &#123; ChessPiece piece = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); move = true; e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; if (move &amp;&amp; piece != null) &#123; x = e.getX(); y = e.getY(); if (红方走棋 &amp;&amp; ((piece.棋子类别()).equals(红方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; if (黑方走棋 &amp;&amp; (piece.棋子类别().equals(黑方颜色))) &#123; piece.setLocation(x - piece.getWidth() / 2, y - piece.getHeight() / 2); &#125; &#125; &#125; &#125; /**松开鼠标事件*/ public void mouseReleased(MouseEvent e) &#123; ChessPiece piece = null; move = false; Rectangle rect = null; if (e.getSource() instanceof ChessPiece) &#123; piece = (ChessPiece) e.getSource(); rect = piece.getBounds(); e = SwingUtilities.convertMouseEvent(piece, e, this); &#125; if (e.getSource() == this) &#123; boolean containChessPoint = false; int x = 0, y = 0; int m = 0, n = 0; if (piece != null) &#123; for (int i = 1; i &lt;= x轴长; i++) &#123; for (int j = 1; j &lt;= y轴长; j++) &#123; x = point[i][j].getX(); y = point[i][j].getY(); if (rect.contains(x, y)) &#123; containChessPoint = true; m = i; n = j; break; &#125; &#125; &#125; &#125; if (piece != null &amp;&amp; containChessPoint) &#123; Color pieceColor = piece.获取棋子颜色(); if (point[m][n].isPiece()) &#123; Color c = (point[m][n].getPiece()).获取棋子颜色(); if (pieceColor.getRGB() == c.getRGB()) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; else &#123; boolean ok = rule.movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; ChessPiece pieceRemoved = point[m][n].getPiece(); point[m][n].reMovePiece(pieceRemoved, this); point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子(pieceRemoved); rule.isWine(pieceRemoved); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; validate(); repaint(); &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; else &#123; boolean ok = rule .movePieceRule(piece, startI, startJ, m, n); if (ok) &#123; point[m][n].setPiece(piece, this); (point[startI][startJ]).set有棋子(false); record.记录棋谱(piece, startI, startJ, m, n); record.记录吃掉的棋子("没吃棋子"); if (piece.棋子类别().equals(红方颜色)) &#123; 红方走棋 = false; 黑方走棋 = true; &#125; if (piece.棋子类别().equals(黑方颜色)) &#123; 黑方走棋 = false; 红方走棋 = true; &#125; &#125; else &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; if (piece != null &amp;&amp; !containChessPoint) &#123; piece.setLocation(startX, startY); (point[startI][startJ]).set有棋子(true); &#125; &#125; &#125; public void mouseEntered(MouseEvent e) &#123; &#125; public void mouseExited(MouseEvent e) &#123; &#125; public void mouseClicked(MouseEvent e) &#123; &#125; &#125; 06 MakeChessManual类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package cn.edu.ouc.chineseChess;import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.util.LinkedList; /** * 制作棋谱类 * * @author cnlht */ public class MakeChessManual extends JPanel implements ActionListener &#123; JTextArea text = null; JScrollPane scroll = null; ChessBoard board = null; ChessPoint[][] point; LinkedList 棋谱 = null; LinkedList 吃掉的棋子 = null; JButton buttonUndo; int i = 0; public MakeChessManual(ChessBoard board, ChessPoint[][] point) &#123; this.board = board; this.point = point; text = new JTextArea(); scroll = new JScrollPane(text); 棋谱 = new LinkedList(); 吃掉的棋子 = new LinkedList(); buttonUndo = new JButton("悔棋"); buttonUndo.setFont(new Font("隶书", Font.PLAIN, 18)); setLayout(new BorderLayout()); add(scroll, BorderLayout.CENTER); add(buttonUndo, BorderLayout.SOUTH); buttonUndo.addActionListener(this); &#125; public char numberToLetter(int n) &#123; char c = '\0'; switch (n) &#123; case 1: c = 'A'; break; case 2: c = 'B'; break; case 3: c = 'C'; break; case 4: c = 'D'; break; case 5: c = 'E'; break; case 6: c = 'F'; break; case 7: c = 'G'; break; case 8: c = 'H'; break; case 9: c = 'I'; break; case 10: c = 'J'; break; &#125; return c; &#125; public void 记录棋谱(ChessPiece piece, int startI, int startJ, int endI, int endJ) &#123; Point pStart = new Point(startI, startJ); Point pEnd = new Point(endI, endJ); MoveStep step = new MoveStep(pStart, pEnd); 棋谱.add(step); String 棋子类别 = piece.棋子类别(); String name = piece.getName(); String m = "#" + 棋子类别 + name + ": " + startI + numberToLetter(startJ) + " 到 " + endI + numberToLetter(endJ); text.append(m); if (piece.棋子类别().equals(board.黑方颜色)) text.append("\n"); &#125; public void 记录吃掉的棋子(Object object) &#123; 吃掉的棋子.add(object); &#125; public LinkedList 获取棋谱() &#123; return 棋谱; &#125; public void actionPerformed(ActionEvent e) &#123; int position = text.getText().lastIndexOf("#"); if (position != -1) text.replaceRange("", position, text.getText().length()); if (棋谱.size() &gt; 0) &#123; MoveStep lastStep = (MoveStep) 棋谱.getLast(); 棋谱.removeLast(); Object qizi = 吃掉的棋子.getLast(); 吃掉的棋子.removeLast(); String temp = qizi.toString(); if (temp.equals("没吃棋子")) &#123; int startI = lastStep.pStart.x; int startJ = lastStep.pStart.y; int endI = lastStep.pEnd.x; int endJ = lastStep.pEnd.y; ChessPiece piece = point[endI][endJ].getPiece(); point[startI][startJ].setPiece(piece, board); (point[endI][endJ]).set有棋子(false); if (piece.棋子类别().equals(board.红方颜色)) &#123; board.红方走棋 = true; board.黑方走棋 = false; &#125; if (piece.棋子类别().equals(board.黑方颜色)) &#123; board.黑方走棋 = true; board.红方走棋 = false; &#125; &#125; else &#123; ChessPiece removedPiece = (ChessPiece) qizi; int startI = lastStep.pStart.x; int startJ = lastStep.pStart.y; int endI = lastStep.pEnd.x; int endJ = lastStep.pEnd.y; ChessPiece piece = point[endI][endJ].getPiece(); point[startI][startJ].setPiece(piece, board); point[endI][endJ].setPiece(removedPiece, board); (point[endI][endJ]).set有棋子(true); if (piece.棋子类别().equals(board.红方颜色)) &#123; board.红方走棋 = true; board.黑方走棋 = false; &#125; if (piece.棋子类别().equals(board.黑方颜色)) &#123; board.黑方走棋 = true; board.红方走棋 = false; &#125; &#125; &#125; &#125; &#125; 07 MoveStep类123456789101112131415161718package cn.edu.ouc.chineseChess;import java.awt.Point; /** * 走步类 * * @author cnlht * */ public class MoveStep implements java.io.Serializable &#123; public Point pStart, pEnd; public MoveStep(Point p1, Point p2) &#123; pStart = p1; pEnd = p2; &#125; &#125; 08 Rule类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320package cn.edu.ouc.chineseChess;import javax.swing.*; import java.awt.*; import java.awt.event.*; /** * 走棋规则类 * * @author cnlht */ public class Rule &#123; ChessBoard board = null; ChessPiece piece = null; ChessPoint point[][]; int startI, startJ, endI, endJ; public Rule(ChessBoard board, ChessPoint point[][]) &#123; this.board = board; this.point = point; &#125; public void isWine(ChessPiece piece) &#123; this.piece = piece; if (piece.getName() == "将" || piece.getName() == "帅") &#123; if (piece.颜色类别 == "红方") &#123; JOptionPane.showMessageDialog(null, "黑方 胜利！"); &#125; else &#123; JOptionPane.showMessageDialog(null, "红方 胜利！"); &#125; &#125; &#125; public boolean movePieceRule(ChessPiece piece, int startI, int startJ, int endI, int endJ) &#123; this.piece = piece; this.startI = startI; this.startJ = startJ; this.endI = endI; this.endJ = endJ; int minI = Math.min(startI, endI); int maxI = Math.max(startI, endI); int minJ = Math.min(startJ, endJ); int maxJ = Math.max(startJ, endJ); boolean 可否走棋 = false; if (piece.getName().equals("车")) &#123; if (startI == endI) &#123; int j = 0; for (j = minJ + 1; j &lt;= maxJ - 1; j++) &#123; if (point[startI][j].isPiece()) &#123; 可否走棋 = false; break; &#125; &#125; if (j == maxJ) &#123; 可否走棋 = true; &#125; &#125; else if (startJ == endJ) &#123; int i = 0; for (i = minI + 1; i &lt;= maxI - 1; i++) &#123; if (point[i][startJ].isPiece()) &#123; 可否走棋 = false; break; &#125; &#125; if (i == maxI) &#123; 可否走棋 = true; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("車")) &#123; if (startI == endI) &#123; int j = 0; for (j = minJ + 1; j &lt;= maxJ - 1; j++) &#123; if (point[startI][j].isPiece()) &#123; 可否走棋 = false; break; &#125; &#125; if (j == maxJ) &#123; 可否走棋 = true; &#125; &#125; else if (startJ == endJ) &#123; int i = 0; for (i = minI + 1; i &lt;= maxI - 1; i++) &#123; if (point[i][startJ].isPiece()) &#123; 可否走棋 = false; break; &#125; &#125; if (i == maxI) &#123; 可否走棋 = true; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125;else if (piece.getName().equals("马")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (xAxle == 2 &amp;&amp; yAxle == 1) &#123; if (endI &gt; startI) &#123; if (point[startI + 1][startJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; if (endI &lt; startI) &#123; if (point[startI - 1][startJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; &#125;else if (xAxle == 1 &amp;&amp; yAxle == 2) &#123; if (endJ &gt; startJ) &#123; if (point[startI][startJ + 1].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; if (endJ &lt; startJ) &#123; if (point[startI][startJ - 1].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("馬")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (xAxle == 2 &amp;&amp; yAxle == 1) &#123; if (endI &gt; startI) &#123; if (point[startI + 1][startJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; if (endI &lt; startI) &#123; if (point[startI - 1][startJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; &#125;else if (xAxle == 1 &amp;&amp; yAxle == 2) &#123; if (endJ &gt; startJ) &#123; if (point[startI][startJ + 1].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; if (endJ &lt; startJ) &#123; if (point[startI][startJ - 1].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("象")) &#123; int centerI = (startI + endI) / 2; int centerJ = (startJ + endJ) / 2; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (xAxle == 2 &amp;&amp; yAxle == 2 &amp;&amp; endJ &lt;= 5) &#123; if (point[centerI][centerJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("相")) &#123; int centerI = (startI + endI) / 2; int centerJ = (startJ + endJ) / 2; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (xAxle == 2 &amp;&amp; yAxle == 2 &amp;&amp; endJ &gt;= 6) &#123; if (point[centerI][centerJ].isPiece()) &#123; 可否走棋 = false; &#125; else &#123; 可否走棋 = true; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("炮")) &#123; int number = 0; if (startI == endI) &#123; int j = 0; for (j = minJ + 1; j &lt;= maxJ - 1; j++) &#123; if (point[startI][j].isPiece()) &#123; number++; &#125; &#125; if (number &gt; 1) &#123; 可否走棋 = false; &#125; else if (number == 1) &#123; if (point[endI][endJ].isPiece()) &#123; 可否走棋 = true; &#125; &#125; else if (number == 0 &amp;&amp; !point[endI][endJ].isPiece()) &#123; 可否走棋 = true; &#125; &#125; else if (startJ == endJ) &#123; int i = 0; for (i = minI + 1; i &lt;= maxI - 1; i++) &#123; if (point[i][startJ].isPiece()) &#123; number++; &#125; &#125; if (number &gt; 1) &#123; 可否走棋 = false; &#125; else if (number == 1) &#123; if (point[endI][endJ].isPiece()) &#123; 可否走棋 = true; &#125; &#125; else if (number == 0 &amp;&amp; !point[endI][endJ].isPiece()) &#123; 可否走棋 = true; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("兵")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (endJ &gt;= 6) &#123; if (startJ - endJ == 1 &amp;&amp; xAxle == 0) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (endJ &lt;= 5) &#123; if ((startJ - endJ == 1) &amp;&amp; (xAxle == 0)) &#123; 可否走棋 = true; &#125; else if ((endJ - startJ == 0) &amp;&amp; (xAxle == 1)) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; &#125; else if (piece.getName().equals("卒")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (endJ &lt;= 5) &#123; if (endJ - startJ == 1 &amp;&amp; xAxle == 0) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (endJ &gt;= 6) &#123; if ((endJ - startJ == 1) &amp;&amp; (xAxle == 0)) &#123; 可否走棋 = true; &#125; else if ((endJ - startJ == 0) &amp;&amp; (xAxle == 1)) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; &#125; else if (piece.getName().equals("士")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (endI &lt;= 6 &amp;&amp; endI &gt;= 4 &amp;&amp; xAxle == 1 &amp;&amp; yAxle == 1) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if (piece.getName().equals("仕")) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (endI &lt;= 6 &amp;&amp; endI &gt;= 4 &amp;&amp; xAxle == 1 &amp;&amp; yAxle == 1) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; else if ((piece.getName().equals("帅")) || (piece.getName().equals("将"))) &#123; int xAxle = Math.abs(startI - endI); int yAxle = Math.abs(startJ - endJ); if (endI &lt;= 6 &amp;&amp; endI &gt;= 4) &#123; if ((xAxle == 1 &amp;&amp; yAxle == 0) || (xAxle == 0 &amp;&amp; yAxle == 1)) &#123; 可否走棋 = true; &#125; else &#123; 可否走棋 = false; &#125; &#125; else &#123; 可否走棋 = false; &#125; &#125; return 可否走棋; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[nogrok 内网穿透]]></title>
    <url>%2F2017%2F05%2F28%2Fnogrok%20%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[使用Sunny-Ngrok赠送的免费域名进行http服务映射 1、首先在本站注册成为会员 2、开通隧道123456在上图中表单信息解释： 隧道名称：可以随便填写，只是为了使用者在往后之后这个隧道是干嘛的 前置域名：服务器免费赠送的域名，请不要带上后缀，如果要sunny.ngrok.cc 只需要填写 sunny 即可 ，千万不要填写成sunny.ngrok.cc否则域名会是sunny.ngrok.cc.ngrok.cc 本地端口：可以为同一个局域网内任意一台机器进行映射，只需要填对ip和端口就行，例如：192.168.1.1:80 http验证用户名：非必填项，在需要的时候填写，否则可以不填 http验证密码：非必填项，在需要的时候填写，否则可以不填3、在需要映射的机器建立web服务 如果没有启动web服务将会看到下图提示4、下载客户端 根据自己的操作系统需求下载相对于版本 5、启动映射服务 Linux或者Mac系统下启动，需要进入到客户端的目录执行以下命令，通过隧道管理找到隧道id，然后执行./sunny clientid 隧道id 看到这样则是成功启动一条隧道，启动多条隧道把多条隧道id使用英文逗号隔开就可以了。例如： ./sunny clientid c7fb2defb4081919,3e23d14f040b2b12 上面命令就可以启动多条隧道了 6、访问服务 然后通过启动成功界面上的链接访问网站如果显示是内网搭建的web服务里面的内容就说明成功了]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉平衡树相关算法]]></title>
    <url>%2F2017%2F05%2F24%2F%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365#include&lt;stdio.h&gt;#include&lt;iostream&gt;typedef int KeyType;typedef char InfoType;typedef struct node&#123; KeyType Key; int bf; InfoType data; struct node *lchild, *rchild;&#125;BSTNode;void LeftProcess(BSTNode *&amp;p, int &amp;taller)&#123; BSTNode *p1,*p2; if (p-&gt;bf == 0) &#123; p-&gt;bf = 1; taller = 1; &#125; else if (p-&gt;bf == 1) &#123; p-&gt;bf = 0; taller = 0; &#125; else &#123; p1 = p-&gt;lchild; if (p1-&gt;bf == 1) &#123; p-&gt;lchild = p1-&gt;rchild; p1-&gt;rchild = p; p-&gt;bf = p1-&gt;bf = 0; p = p1; &#125; else if (p1-&gt;bf == -1) &#123; p2 = p1-&gt;rchild; p1-&gt;rchild = p2-&gt;lchild; p2-&gt;lchild = p1; p-&gt;lchild = p2-&gt;rchild; p2-&gt;rchild = p; if (p2-&gt;bf == 1) p-&gt;bf = p1-&gt;bf = 0; else if (p2-&gt;bf == 1) &#123; p1-&gt;bf = 0; p-&gt;bf = -1; &#125; else &#123; p1-&gt;bf = 1; p-&gt;bf = 0; &#125; p = p2; p-&gt;bf = 0; &#125; taller = 0; &#125;&#125;void RightProcess(BSTNode * &amp;p, int &amp;taller)&#123; BSTNode *p1, *p2; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; taller = 1; &#125; else if (p-&gt;bf == 1) &#123; p-&gt;bf = 0; taller = 0; &#125; else &#123; p1 = p-&gt;rchild; if (p1-&gt;bf == -1) &#123; p-&gt;rchild - p1-&gt;lchild; p1-&gt;lchild = p; p-&gt;bf = p1-&gt;bf = 0; p = p1; &#125; else if (p1-&gt;bf == 1) &#123; p2 = p1-&gt;lchild; p1-&gt;lchild = p2-&gt;rchild; p2-&gt;rchild = p1; p-&gt;rchild = p2-&gt;lchild; p2-&gt;lchild = p; if (p2-&gt;bf == 0) p-&gt;bf = p1-&gt;bf = 0; else if (p2-&gt;bf == -1) &#123; p1-&gt;bf = 0; p-&gt;bf = 0; &#125; else &#123; p1-&gt;bf = -1; p-&gt;bf = 0; &#125; p = p2; p-&gt;bf = 0; &#125; taller = 0; &#125;&#125;int InseertAVL(BSTNode * &amp;b, KeyType e, int &amp;taller)&#123; if (b == NULL) &#123; b = (BSTNode *)malloc(sizeof(BSTNode)); b-&gt;Key = e; b-&gt;lchild = b-&gt;rchild = NULL; b-&gt;bf = 1; taller = 1; &#125; else &#123; if (e == b-&gt;Key) &#123; taller = 0; return 0; &#125; if (e &lt; b-&gt;Key) &#123; if ((InseertAVL(b-&gt;lchild, e, taller)) == 0) return 0; if (taller == 1) LeftProcess(b, taller); &#125; else &#123; if ((InseertAVL(b-&gt;lchild, e, taller)) == 0) return 0; if (taller == 1) RightProcess(b, taller); &#125; &#125; return 1;&#125;void DispBSTree(BSTNode * b)&#123; if (b != NULL) &#123; printf("%d", b-&gt;Key); if (b-&gt;lchild != NULL || b-&gt;rchild != NULL) &#123; printf("("); DispBSTree(b-&gt;lchild); if (b-&gt;rchild != NULL)printf(","); DispBSTree(b-&gt;rchild); printf(")"); &#125; &#125;&#125;void LeftProcee1(BSTNode * &amp;p, int &amp;taller)&#123; BSTNode *p1, *p2; if (p-&gt;bf == 1) &#123; p-&gt;bf = 0; taller = 1; &#125; else if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; taller = 0; &#125; else &#123; p1 = p-&gt;rchild; if (p1-&gt;bf == 0) &#123; p-&gt;rchild = p1-&gt;lchild; p1-&gt;lchild = p; p1 -&gt; bf = 1; p-&gt;bf = -1; p = p1; taller = 0; &#125; else if (p1-&gt;bf == -1) &#123; p-&gt;rchild = p1-&gt;lchild; p1-&gt;lchild = p; p1-&gt;bf = p-&gt;bf = 0; p = p1 = 0; taller = 1; &#125; else &#123; p2 = p1-&gt;lchild; p1-&gt;lchild = p2-&gt;rchild; p2-&gt;rchild = p1; p-&gt;rchild = p2-&gt;lchild; p2-&gt;lchild = p; if (p2-&gt;bf == 0) &#123; p-&gt;bf = 0; p1-&gt;bf = 0; &#125; else if (p2-&gt;bf = 1) &#123; p-&gt;bf = 1; p1-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; p1-&gt;bf = -1; &#125; p2-&gt;bf = 0; p = p2; taller = 1; &#125; &#125;&#125;void RightProcess1(BSTNode * &amp;p, int &amp;taller)&#123; BSTNode *p1, *p2; if (p-&gt;bf == -1) &#123; p-&gt;bf = 0; taller = -1; &#125; else if (p-&gt;bf ==0) &#123; p-&gt;bf = 1; taller = 0; &#125; else &#123; p1 = p-&gt;lchild; if (p1-&gt;bf == 0) &#123; p-&gt;lchild = p1-&gt;rchild; p-&gt;rchild = p; p1-&gt;bf = -1; p-&gt;bf = 1; p = p1; taller = 0; &#125; else if (p1-&gt;bf == 1) &#123; p-&gt;lchild = p1-&gt;rchild; p1-&gt;rchild = p; p-&gt;bf = p-&gt;bf = 0; p = p1; taller = 1; &#125; else &#123; p2 = p1-&gt;rchild; p1-&gt;rchild = p2-&gt;lchild; p2-&gt;lchild = p1; p-&gt;lchild = p2-&gt;rchild; p2-&gt;rchild = p; if (p2-&gt;bf == 0) &#123; p-&gt;bf = 0; p1-&gt;bf = 0; &#125; else if (p2-&gt;bf == 1) &#123; p-&gt;bf = -1; p1-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; p1-&gt;bf = 1; &#125; p2-&gt;bf = 0; p = p2; taller = 1; &#125; &#125;&#125;void Delete2(BSTNode * &amp;q, BSTNode * &amp;r, int &amp;taller)&#123; if (r-&gt;rchild == NULL) &#123; q-&gt;Key = r-&gt;Key; q = r; r = r-&gt;rchild; free(q); taller = 1; &#125; else &#123; Delete2(q, r-&gt;rchild, taller); if (taller == 1) RightProcess1(r, taller); &#125;&#125;int DeleteAVL(BSTNode * &amp;p, KeyType x, int &amp;taller)&#123; int k; BSTNode *q; if (p == NULL) return 0; else if (x &lt; p-&gt;Key) &#123; k = DeleteAVL(p-&gt;rchild, x, taller); if (taller == 1) RightProcess1(p, taller); return k; &#125; else if (x &gt; p-&gt;Key) &#123; k = DeleteAVL(p-&gt;rchild, x, taller); if (taller == 1) RightProcess1(p, taller); return k; &#125; else &#123; q = p; if (p-&gt;rchild == NULL) &#123; p = p-&gt;lchild; free(q); taller = 1; &#125; else if (p-&gt;lchild == NULL) &#123; p = p-&gt;rchild; free(q); taller = 1; &#125; else &#123; Delete2(q, q-&gt;lchild, taller); if (taller == 1) LeftProcee1(q, taller); p = q; &#125; return 1; &#125;&#125;void main()&#123; BSTNode *b = NULL; int i, j, k; KeyType a[] = &#123; 4,9,0,1,8,6,3,5,2,7 &#125;, n = 10; printf("创建一颗AVL树\n"); for (i = 0; i &lt; n; i++) &#123; printf("第%d步，插入%d元素：", i + 1, a[i]); InseertAVL(b, a[i], j); DispBSTree(b); printf("\n"); &#125; printf("结果AVL："); DispBSTree(b); printf("\n"); printf("删除节点:\n"); k = 8; printf("删除节点%d:", k); DeleteAVL(b, k, j); printf("AVL:"); DispBSTree(b); printf("\n"); k -= 2; printf("删除节点%d", k); DeleteAVL(b, j, k); printf("AVL:"); DispBSTree(b); printf("\n"); getchar();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派摄像头配置]]></title>
    <url>%2F2017%2F05%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE.%E6%91%84%E5%83%8F%E5%A4%B4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 安装1sudo apt install motion2. 配置 备份配置文件1sudo cp /etc/motion/motion.conf /etc/motion/motion.conf.bak 打开配置文档1sudo vim /etc/motion/motion.conf 更改文档中以下内容123456width 640 #图像的宽height 480 #图像的高target_dir /home/pi/motion-images #图片保存的路径stream_localhost off #允许通过网页查看摄像头stream_auth_method 2 #开启密码认证stream_authentication 用户名:密码 #网页查看摄像头的用户名和密码 官方详细配置说明：http://lavrsen.dk/foswiki/bin/view/Motion/ConfigFileOptions 3. 运行1sudo motion]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派实现无线中继路由]]></title>
    <url>%2F2017%2F05%2F06%2F%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8Cpc%2F</url>
    <content type="text"><![CDATA[设置PC端ip]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信开发者]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%2F</url>
    <content type="text"><![CDATA[微信公众平台 有服务号 订阅号(1558185399@qq.com) 小程序（jackj2629@gmail.com） 每个的注册邮箱不能一样小程序代码构成 程序运行原理 关于android手机root，去对应手机的官方论坛找。不是随便下个软件就能root的，太天真。。。vivo 我服。。。 b站 微信小程序教程 wxml 框架 (数据对象渲染 判断 列表渲染) wxss 框架 （内外联 选择器） js 框架 与wxs （wx script）]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派 无线网卡配置]]></title>
    <url>%2F2017%2F05%2F02%2F%5B%E6%A0%91%E8%8E%93%E6%B4%BE%5D%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、查看网卡状态是否正常- 把无线网卡插到树莓派上，输入命令ifconfig -a查看是否有wlan0的信息，如果有说明网卡状态正常，可以跳过第二步，直接配置无线网络。如果查不到wlan0的信息，则需要安装无线网卡的驱动。二、查看无线网卡的信息- 输入命令dmesg | grep usb查看无线网卡的信息，主要是看制造厂家（Manufacturer）。比如，我的网卡信息是usb 1-1.3: Manufacturer: Realtek- 以Realtek为例，安装无线网卡驱动。如果现在你的树莓派能联网，输入安装命令就可以安装Realtek的驱动了。- 首先搜索Realtek驱动：- apt-cache search realtek看到下面信息：firmware-realtek – Binary firmware for Realtek wired and wireless network adapters安装Realtek驱动：- sudo apt-get install firmware-realtek如果你的树莓派现在不能上网，那么你可以去镜像站点中下载相关驱动。我推荐阿里云的镜像站点，速度比较快。http://mirrors.aliyun.com/raspbian/raspbian/pool/non-free/f/firmware-nonfree下载firmware-realtek_0.43_all.deb，用winscp上传到树莓派的/tmp目录中。输入命令安装：- sudo dpkg -i /tmp/firmware-realtek_0.43_all.deb三、配置无线网络 用编辑器nano打开interfaces文件 sudo nano /etc/network/interfaces我的interfaces文件是这样的： 123456789auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0iface wlan0 inet manualwpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 我们把无线网卡部分全部用#注释掉，然后添加自己的配置信息，最终结果如下： 123456789101112auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0#allow-hotplug wlan0#iface wlan0 inet manualiface wlan0 inet dhcpwpa-conf /etc/wpa.conf#wpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 使用nano编辑器，ctrl+o保存，ctrl+x退出。(别忘啦sudo 要不改不了，ctrl+o enter ctrl+x 顺序) 用编辑器nano创建 /etc/wpa.conf 文件： sudo nano /etc/wpa.conf如果你的wifi没有密码 1234network=&#123;[Tab] ssid="你的无线网络名称（ssid）"[Tab] key_mgmt=NONE&#125; 如果你的wifi使用WEP加密 12345network=&#123;[Tab] ssid="你的无线网络名称（ssid）"[Tab] key_mgmt=NONE[Tab] wep_key0="你的wifi密码"&#125; 如果你的wifi使用WPA/WPA2加密12345network=&#123;[Tab] ssid="你的无线网络名称（ssid）"[Tab] key_mgmt=WPA-PSK[Tab] psk="你的wifi密码"&#125; 注1：所有符号都是半角符号（英文状态下的符号），“[Tab]”表示按一次Tab键注2：如果你不清楚wifi的加密模式，可以在安卓手机上用root explorer打开 /data/misc/wifi/wpa/wpa_supplicant.conf，查看wifi的信息。 比如，我的wpa.conf文件是这样的：12345network=&#123; ssid="238_2" key_mgmt=WPA-PSK psk="fangjun_"&#125; 最后输入命令启用无线网卡： sudo ifup wlan0 可以连无线网了。 注意 远程所使用的ip地址变啦 无线 有线连接 ip地址变啦 这个坑我卡啦3天 甚至怀疑硬件有问题，蠢蠢蠢！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派起步]]></title>
    <url>%2F2017%2F04%2F28%2F%E3%80%90%E6%A0%91%E8%8E%93%E6%B4%BE%E3%80%91%E7%94%B5%E8%84%91%E6%98%BE%E7%A4%BA%E5%99%A8%E5%BD%93%E6%A0%91%E8%8E%93%E6%B4%BE%E6%98%BE%E7%A4%BA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[简要步骤 基本材料：树莓派一个，路由器一个，网线一条（用于连接路由器），笔记本一台 提前下载好需要的文件：树莓派的官网下载raspbian : https://www.raspberrypi.org/downloads/ 格式化内存卡 SDFormatter：http://pan.baidu.com/s/1bzE9qu 写入镜像 win32diskimager ：http://pan.baidu.com/s/1o8AvKyI 利用putty进行ssh连接 ： http://pan.baidu.com/s/1qXJ4Q2S 安装系统 使用putty ip地址可以从路由器后台获得 这时候点open会报错（3b树莓派默认关闭ssh） 解决方法：在boot（你的sd卡）下新建ssh文件夹即可 安装xrdp服务 在putty点击open后的弹出窗口输入 用户名：pi 密码：raspberry（密码看不见） 然后输入命令：sudo apt-get install xrdp 打开电脑自带的远程桌面连接工具 这时候报错：error ：connect problem 解决方法： 在putty点击open后的弹出窗口输入 sudo apt-get install vnc4server tightvncserver 多试几次 登陆成功如图]]></content>
  </entry>
  <entry>
    <title><![CDATA[生成器模式]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.类图]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合框架]]></title>
    <url>%2F2017%2F04%2F28%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[完整教程：how2j 备忘 ArrayList存放对象 容器的容量”capacity”会随着对象的增加，自动增长 只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。 1234//容器类ArrayList，用于存放对象 ArrayList heros = new ArrayList();//创建容器类对象 heros.add( new Hero("盖伦"));//添加新英雄 System.out.println(heros.size());//容器类大小 List :ArrayList实现了接口List常见的写法会把引用声明为接口List类型注意：是java.util.List,而不是java.awt.List 因为ArrayList实现了List接口，所以List接口的方法ArrayList都实现了 12345678910111213141516171819List heros = new ArrayList();//创建容器类对象heros.add( new Hero("盖伦"));//添加新英雄System.out.println(heros.size());//容器类大小 ``` - 泛型 Generic:不指定泛型的容器，可以存放任何类型的元素 指定了泛型的容器，只能存放指定类型的元素以及其子类```java//声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错 List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;(); genericheros.add(new Hero("盖伦")); //如果不是Hero类型，根本就放不进去 //genericheros.add(new Item("冰杖")); //除此之外，还能存放Hero的子类 genericheros.add(new APHero()); //并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类 Hero h = genericheros.get(0); 泛型的简写 List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;(); List&lt;Hero&gt; genericheros2 = new ArrayList&lt;&gt;(); 迭代器遍历 havaNext Iterator&lt;Hero&gt; it= heros.iterator(); //从最开始的位置判断"下一个"位置是否有数据 //如果有就通过next取出来，并且把指针向下移动 //直达"下一个"位置没有数据 while(it.hasNext()){ Hero h = it.next(); System.out.println(h); }]]></content>
      <categories>
        <category>how2j</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB1%2F</url>
    <content type="text"><![CDATA[依赖BeautifulSoup Python 主文件spider_main.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-# 主程序,负责根url，以及启动爬虫 import html_downloder import html_output import html_parser import url_managerclass SpilderMain: def __init__(self): # 初始化所需要的对象,包括url管理器，网页下载器，网页解析器，输出器 # 来提供给craw（）使用 # 来提供给craw（）使用 self.urls = url_manager.UrlManager() self.downloader = html_downloder.HtmlDownloader() self.parser = html_parser.HtmlParser() self.outputer = html_output.HtmlOutputer() def craw(self, url): count = 1 # url计数 # 添加根url self.urls.add_new_url(url) # 开始解析 while self.urls.has_new_url(): try: # 获取url new_url = self.urls.get_new_url() print("第%d个url：%s" % (count, new_url)) # 将url对应的页面进行下载 html_cont = self.downloader.download(new_url) # 对下载下来的页面进行解析,将解析出来的数据进行保存 new_urls, new_data = self.parser.parse(new_url, html_cont) # 将解析出来的urls添加到url_manager self.urls.add_new_urls(new_urls) # 将数据进行收集 self.outputer.collect_data(new_data) if count == 15: break count += 1 except: print("爬取失败") self.outputer.output_html()if __name__ == "__main__": root_url = "http://baike.baidu.com/view/21087.htm" obj_spider = SpilderMain() # 启动爬虫 obj_spider.craw(root_url) 网页下载器html_downloder.py1234567891011121314# -*- coding:utf-8 -*-# 页面下载器import urllib.requestclass HtmlDownloader(object): def download(self, url): if url is None: return None response = urllib.request.urlopen(url) if response.getcode() != 200: return None return response.read()#页面下载器 网页解析器html_parser.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*-# 网页解析器import refrom bs4 import BeautifulSoupimport urllib.parseclass HtmlParser(object): # 对html_cont的内容进行解析 def parse(self, page_url, html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8') new_urls = self._get_new_urls(page_url, soup) new_data = self._get_new_data(page_url, soup) return new_urls, new_data # 获取页面上所有的url def _get_new_urls(self, page_url, soup): new_urls = set() # 根据分析，链接的格式是：/view/12334.htm links = soup.find_all('a', href=re.compile(r"/view/\d+\.htm")) for link in links: new_url = link['href'] # url格式需要进行拼接，加上 http://baike.baidu.com new_full_url = urllib.parse.urljoin(page_url, new_url) new_urls.add(new_full_url) return new_urls # 获取每一页面的数据，包括标题以及简介 def _get_new_data(self, page_url, soup): # 以一个词典数据类型保存数据 res_data = &#123;&#125; # 保存url res_data['url'] = page_url # 下面是标题的格式 # &lt;dd class="lemmaWgt-lemmaTitle-title"&gt; &lt;h1&gt;Python&lt;/h1&gt; title_node = soup.find('dd', class_="lemmaWgt-lemmaTitle-title").find('h1') res_data['title'] = title_node.get_text() # 开始获取简介的内容 # &lt;div class="lemma-summary" label-module="lemmaSummary"&gt; summary_node = soup.find('div', class_="lemma-summary") res_data['summary'] = summary_node.get_text() return res_data URL管理器url_manager.py12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-# url管理器class UrlManager(object): def __init__(self): self.new_urls = set() self.old_urls = set() # 添加url def add_new_url(self, url): if url is None: return # 当url既不在新的列表中也不在旧的列表中时，则将其添加到新的url——set()集合中 if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self, urls): if urls is None or len(urls) == 0: return for url in urls: self.add_new_url(url) # 判断是否还有待爬取的url def has_new_url(self): return len(self.new_urls) != 0 def get_new_url(self): new_url = self.new_urls.pop() self.old_urls.add(new_url) return new_url 定义路径输出结果1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-# 最后的结果输出# 提供两个功能，一个事收集数据，另一个是输出数据class HtmlOutputer(object): # 收集数据需要一个列表list进行维护 def __init__(self): self.datas= [] def collect_data(self, data): if data is None: return self.datas.append(data) # 输出一个html文档 def output_html(self): fileout = open("output.html", "w", encoding='utf-8') fileout.write("&lt;html&gt;") fileout.write("&lt;head&gt;") fileout.write("&lt;meta charset=\'utf-8\'&gt;") fileout.write("&lt;/head&gt;") fileout.write("&lt;body&gt;") fileout.write("&lt;table&gt;") for data in self.datas: fileout.write("&lt;tr&gt;") fileout.write("&lt;td&gt;%s&lt;/td&gt;" % data['url']) fileout.write("&lt;td&gt;%s&lt;/td&gt;" % data['title']) fileout.write("&lt;td&gt;%s&lt;/td&gt;" % data['summary']) fileout.write("&lt;/tr&gt;") fileout.write("&lt;/table&gt;") fileout.write("&lt;/body&gt;") fileout.write("&lt;/html&gt;") fileout.close()]]></content>
  </entry>
  <entry>
    <title><![CDATA[集合框架]]></title>
    <url>%2F2017%2F04%2F28%2F%E7%AD%96%E8%99%90%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.类图]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[E3D插件]]></title>
    <url>%2F2017%2F04%2F04%2FE3D%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[E3插件的安装方法 E3D插件 双击 ElementInstaller_2.0.7.2008_Win_Full.exe 程序安装（建议右键用管理员身份运行，一般默认即可，也可根据自身情况选择设置） 复制破解文件夹中的 Element.aex 到AE插件目录覆盖替换（目录一般为：…\Adobe\Adobe After Effects 版本号 \Support Files\Plug-ins\VideoCopilot） 打开 AE 软件, 应用 E3D 插件到一个固态层上，将会有弹窗出现， 点击Install License，选择破解文件夹中的 ElementLicense.license 完成破解 完成享用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构上机实验]]></title>
    <url>%2F2017%2F03%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[01 约瑟夫环问题123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;node;node *creat(node *head, int n)&#123; int i = 1; node *s, *p = head; while (i &lt;= n) &#123; s = (node *)malloc(sizeof(node)); s-&gt;data = i++; p-&gt;next = s; p = p-&gt;next; &#125; p-&gt;next = head-&gt;next; free(head); return p-&gt;next;&#125;int main()&#123; int i, n, m; node *head, *newstart, *h, *t; head = (node *)malloc(sizeof(node)); printf("请输入数据长度n，数据间隔m\n"); scanf("%d %d", &amp;n, &amp;m); newstart = creat(head, n); h = newstart; while (h != h-&gt;next) &#123; for (i = 1; i&lt;m; i++) &#123; h = h-&gt;next; &#125; t = h-&gt;next; printf("%d-&gt;\n", h-&gt;next-&gt;data); h-&gt;next = t-&gt;next; h = t-&gt;next; free(t); &#125; printf("%d\n", h-&gt;data); return 0;&#125; 02 一元多项式相加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;using namespace std; struct Node&#123; double coe;//系数 int exp;//指数 Node *next;&#125;;//创建链表，节点数为一元多项式的项数void CreatPoly(Node *&amp;head,int n)//写成*head报错 为什么？&#123; head=(Node *)new Node; head-&gt;coe=0; head-&gt;exp=0; head-&gt;next=NULL;//初始化头节点 Node *p=head; for(int i=0;i&lt;n;i++)&#123; p-&gt;next=(Node *)new Node;//尾插法建表 p=p-&gt;next; cin&gt;&gt;p-&gt;coe&gt;&gt;p-&gt;exp; p-&gt;next=NULL; &#125;&#125;//打印表void ShowPoly(Node *head)&#123; if(head-&gt;next == NULL) putchar('0'); else&#123; for(Node *p=head-&gt;next;p!=NULL;p=p-&gt;next)&#123;//遍历所有节点 if(p!=head-&gt;next&amp;&amp;p-&gt;coe&gt;0)putchar('+'); if(p-&gt;coe==1)&#123; if(p-&gt;exp==0)putchar('1'); &#125; if(p-&gt;coe==1&amp;&amp;p-&gt;exp==0)putchar('1'); else if(p-&gt;coe==-1)putchar('-'); else cout&lt;&lt;p-&gt;coe; //指数为0，1时特殊处理 switch(p-&gt;exp)&#123; case 0:break; case 1:putchar('X');break; default: p-&gt;exp&lt;0?printf("x^(%d)",p-&gt;exp):printf("x^%d",p-&gt;exp);break;//看不懂 break; &#125; &#125; &#125; cout&lt;&lt;endl;&#125;char comp(int a,int b)&#123; if(a&gt;b)return '&gt;'; if(a&lt;b)return '&lt;'; return '=';&#125;//相加void AddPoly(Node *&amp;pA, Node *&amp;pB) // 传进两个链表的头指针&#123;Node *ha = pA;Node *hb = pB;Node *qa = ha-&gt;next; // ha, hb分别跟在qa, qb的后一位置Node *qb = hb-&gt;next; // qa, qb分别指向Pa, Pb中当前比较元素while(qa &amp;&amp; qb)&#123;double sum = 0;int a = qa-&gt;exp;int b = qb-&gt;exp;switch( comp(a, b) ) &#123;case '&lt;':ha = qa;qa = qa-&gt;next; // 非ha = ha-&gt;next;break;case '=':sum = qa-&gt;coe + qb-&gt;coe;if(sum != 0.0) &#123;qa-&gt;coe = sum;ha = qa;&#125;else &#123;if(ha-&gt;next != qa)cout &lt;&lt; "Error: ha-&gt;next != qa" &lt;&lt; endl;ha-&gt;next = ha-&gt;next-&gt;next; // 删除和为0的结点，ha不变，还在qa后一位置&#125;if(hb-&gt;next != qb)cout &lt;&lt; "Error: hb-&gt;next != qb" &lt;&lt; endl;hb-&gt;next = hb-&gt;next-&gt;next;qb = hb-&gt;next;qa = ha-&gt;next;break;case '&gt;':hb-&gt;next = hb-&gt;next-&gt;next; // 删除qb指向的结点qb-&gt;next = ha-&gt;next; // 将qb插入ha后qa前ha-&gt;next = qb;qb = hb-&gt;next; // not qb = ha-&gt;nextha = ha-&gt;next;break;default:cout &lt;&lt; "Error!" &lt;&lt; endl;break;&#125;&#125;if(qb)ha-&gt;next = qb;&#125;int main()&#123; Node *A=NULL; Node *B=NULL; int countA; int countB; cout&lt;&lt;"输入A的项数"&lt;&lt;endl;cin&gt;&gt;countA; cout&lt;&lt;"输入B的项数"&lt;&lt;endl;cin&gt;&gt;countB; CreatPoly(A,countA); CreatPoly(B,countB); cout&lt;&lt;"A="&lt;&lt;endl; ShowPoly(A); cout&lt;&lt;"B="&lt;&lt;endl; ShowPoly(B); AddPoly(A,B); cout&lt;&lt;"A+B="&lt;&lt;endl; ShowPoly(A); delete(A);&#125; 03 栈 正则表达式运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;#define maxsize 1000//中则表达式str转换为后缀表达式void trans(char str[], char exp[])&#123; struct &#123; char data[maxsize]; int top; &#125;op; char ch; int i = 0, t = 0; op.top = -1; ch = str[i]; i++; while (ch != '\0') &#123; switch (ch) &#123; case '(': op.top++; op.data[op.top] = ch; break; case ')': while (op.data[op.top] != '(') &#123; exp[t] = op.data[op.top]; op.top--; t++; &#125; op.top--; break; case '+': case '-': while (op.top != -1 &amp;&amp; op.data[op.top] != '(') &#123; exp[t] = op.data[op.top]; op.top--; t++; &#125; op.top--; op.data[op.top] = ch; break; case '*': case '/': while (op.data[op.top] == '*' || op.data[op.top] == '/') &#123; exp[t] = op.data[op.top]; op.top--; t++; &#125; op.top++; op.data[op.top] = ch; break; case ' ': break; default: while (ch &gt;= '0'&amp;&amp;ch &lt;= '9') &#123; exp[t] = ch; t++; ch = str[i]; i++; &#125; i--; exp[t] = '#'; t++; &#125; ch = str[i]; i++; &#125; while (op.top != -1) &#123; exp[t] = op.data[op.top]; t++; op.top--; &#125; exp[t] = '\0';&#125;//后缀表达式的求值float compvalue(char exp[])&#123; struct &#123; float data[maxsize]; int top; &#125;st; float d; char ch; int t = 0; st.top = -1; ch = exp[t]; t++; while (ch != '\0') &#123; switch (ch) &#123; case '+': st.data[st.top - 1] = st.data[st.top - 1] + st.data[st.top]; st.top--; break; case '-': st.data[st.top - 1] = st.data[st.top - 1] - st.data[st.top]; st.top--; break; case '*': st.data[st.top - 1] = st.data[st.top - 1] * st.data[st.top]; st.top--; break; case '/': if (st.data[st.top] != 0) st.data[st.top - 1] = st.data[st.top - 1] / st.data[st.top]; else &#123; printf("\nerror! \n"); exit(0); &#125; st.top--; break; default: d = 0; while (ch &gt;= '0'&amp;&amp;ch &lt;= '9') &#123; d = 10 * d + ch - '0'; ch = exp[t]; t++; &#125; st.top++; st.data[st.top] = d; &#125; ch = exp[t]; t++; &#125; return st.data[st.top];&#125;int main()&#123; char str[maxsize], exps[maxsize]; printf("please input a expressions,just include +,-,*,/and integers:"); cin &gt;&gt; str;//输入一个中缀表达式 printf("old is: %s\n", str); trans(str, exps);//转换 printf("after is: %s\n", exps); printf("the result is: %g\n", compvalue(exps)); //求值并输出 return 0;&#125; ![])(http://i1.piimg.com/567571/a11fae0ace0176df.png) 04 车厢排序问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;iostream&gt; using namespace std;template&lt;class T&gt;class My_queue;template&lt;class T&gt;class Node&#123;private: T data; Node&lt;T&gt; *next;public: Node() &#123; next = 0; &#125; Node(T d) &#123; data = d; next = 0; &#125; friend My_queue&lt;T&gt;;&#125;;template&lt;class T&gt;class My_queue&#123;private: Node&lt;T&gt; *tail;public: My_queue() &#123; tail = new Node&lt;T&gt;(); tail-&gt;next = tail; &#125; bool empty() &#123; return (tail-&gt;next == tail); &#125; void push(T d) &#123; Node&lt;T&gt; *p = new Node&lt;T&gt;(d); p-&gt;next = tail-&gt;next; tail-&gt;next = p; tail = p; &#125; T front() &#123; if (empty()) &#123; cout &lt;&lt; "queue is empty!" &lt;&lt; endl; exit(0); &#125; Node&lt;T&gt; *p = tail-&gt;next; T data = p-&gt;next-&gt;data; return data; &#125; T back() &#123; if (empty()) &#123; cout &lt;&lt; "queue is empty!" &lt;&lt; endl; exit(0); &#125; T data = tail-&gt;data; return data; &#125; void pop() &#123; Node&lt;T&gt; *p = tail-&gt;next; Node&lt;T&gt; *q = p-&gt;next; p-&gt;next = q-&gt;next; if (q == tail) tail = p; delete q; &#125;&#125;;void OutPut(int&amp; minH, int&amp; minQ, My_queue&lt;int&gt; H[], int k, int n);bool Hold(int c, int&amp; minH, int&amp; minQ, My_queue&lt;int&gt; H[], int k);bool Rail_Road(int p[], int n, int k)&#123; //k个缓冲轨，车厢初始排序为p[1...n] //创建与缓冲轨对应的队列 My_queue&lt;int&gt; *H; H = new My_queue&lt;int&gt;[k]; int NowOut = 1; //下一次要出轨的车厢 int minH = n + 1; //缓冲轨中编号最小的车厢 int minQ = k; //编号最小的车厢所在缓冲轨的编号 //车厢重排序 for (int i = 0; i&lt;n; i++) &#123; if (p[i] == NowOut) &#123; cout &lt;&lt; "Move car " &lt;&lt; p[i] &lt;&lt; " from input to output" &lt;&lt; endl; NowOut++; //从缓冲轨中输出 while (minH == NowOut) &#123; OutPut(minH, minQ, H, k, n); NowOut++; if (NowOut == n + 1) //输出全部车厢后返回 return true; &#125; &#125; else &#123; //将p[i]放入某个缓冲轨 if (!Hold(p[i], minH, minQ, H, k)) return false; &#125; &#125; return true;&#125;void OutPut(int&amp; minH, int&amp; minQ, My_queue&lt;int&gt; H[], int k, int n)&#123; //该函数实现把一节车厢从缓冲轨送至出轨处 //同时修改minH minQ的值 int c; //从队列中pop掉编号最小的车厢minH c = H[minQ].front(); H[minQ].pop(); cout &lt;&lt; "Move car " &lt;&lt; c &lt;&lt; " from holding queue " &lt;&lt; minQ + 1 &lt;&lt; " to output " &lt;&lt; endl; //检查所有队列，搜索新的minH minQ minH = n + 1; for (int i = 0; i&lt;k; i++) if ((!H[i].empty()) &amp;&amp; (H[i].front()&lt;minH)) &#123; minH = H[i].front(); minQ = i; &#125;&#125;bool Hold(int c, int&amp; minH, int&amp; minQ, My_queue&lt;int&gt; H[], int k)&#123; //该函数是将车厢c放入缓冲轨中 //为车厢c寻找最优缓冲轨 int BestQueue = k;//初始化缓冲轨的编号 int BestLast = 0; //最优缓冲轨的队尾车厢编号 int x; //扫描缓冲轨 for (int i = 0; i&lt;k; i++) &#123; if (!H[i].empty()) &#123; x = H[i].back(); if (c&gt;x &amp;&amp; x&gt;BestLast) &#123; BestLast = x; BestQueue = i; &#125; &#125; else &#123; //H[i]为空时 if (BestQueue == k) BestQueue = i; &#125; &#125; if (BestQueue == k) //没有可用的缓冲轨 return false; H[BestQueue].push(c); cout &lt;&lt; "Move car " &lt;&lt; c &lt;&lt; " from input to holding queue " &lt;&lt; BestQueue + 1 &lt;&lt; endl; //必要时修改minH和minS if (c&lt;minH) &#123; minH = c; minQ = BestQueue; &#125; return true;&#125;int main()&#123; int p[9] = &#123; 3,6,9,2,4,7,1,8,5 &#125;; if (Rail_Road(p, 9, 3)) cout &lt;&lt; "车厢重排序成功" &lt;&lt; endl; else cout &lt;&lt; "车厢重排序失败" &lt;&lt; endl; getchar();&#125; 05 三元组实现稀疏矩阵的转置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;using namespace std;struct node&#123; int r;//行标 int c;//列标 double dat;//数据&#125;;class triple&#123;private: int row;//行数 int col;//列数 int num;//非零个数 node *ptr;//存放数组的首地址public: triple(int co,int ro,int nu):col(co),row(ro),num(nu) &#123; ptr=new node[num];//分配num，盛放num个元素 cout&lt;&lt;"请输入"&lt;&lt;num&lt;&lt;"个三元组元素\n"&lt;&lt;"格式为：2 3 6.7\n其中2为行标，3为列标，6.7为数据元素"&lt;&lt;endl; for(int i=0;i&lt;num;i++) &#123; cin&gt;&gt;ptr[i].r; cin&gt;&gt;ptr[i].c; cin&gt;&gt;ptr[i].dat; &#125; &#125; ~triple()&#123;delete[]ptr;&#125;void print()&#123; int flag=ptr[0].r; cout&lt;&lt;"第"&lt;&lt;flag&lt;&lt;"行元素为："; for(int i=0;i&lt;num;i++) &#123; if(ptr[i].r!=flag) &#123; cout&lt;&lt;"\n"; flag=ptr[i].r; cout&lt;&lt;endl; cout&lt;&lt;"第"&lt;&lt;flag&lt;&lt;"行元素为："; &#125; cout&lt;&lt;"("&lt;&lt;ptr[i].r&lt;&lt;","&lt;&lt;ptr[i].c&lt;&lt;","&lt;&lt;ptr[i].dat&lt;&lt;")"; &#125;&#125;void transpose()&#123; int flag=0; for(int i=1;i&lt;=col;i++) &#123; for(int j=0;j&lt;num;j++) &#123; if(ptr[j].c==i) &#123; if(flag!=ptr[j].c) &#123; flag=ptr[j].c; cout&lt;&lt;"\n第"&lt;&lt;ptr[j].c&lt;&lt;"行为："; &#125; cout&lt;&lt;"("&lt;&lt;ptr[j].c&lt;&lt;","&lt;&lt;ptr[j].r&lt;&lt;","&lt;&lt;ptr[j].dat&lt;&lt;")"; &#125; &#125; &#125;&#125;&#125;;int main()&#123; cout&lt;&lt;"请输入数组的行列和元素个数:\n"; int a[3]; for(int i=0;i&lt;3;i++) &#123; cin&gt;&gt;a[i]; &#125; triple t(a[0],a[1],a[2]); t.print();//输出原矩阵 cout&lt;&lt;"转制后的矩阵为:\n"; t.transpose();&#125; 06 二叉树后序遍历的非递归算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424#define _CRT_SECURE_NO_DEPRECATE//转载请标明出处，原文地址：http://blog.csdn.net/hackbuteer1/article/details/6583988#include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; using namespace std;//二叉树结点的描述 typedef struct BiTNode&#123; char data; struct BiTNode *lchild, *rchild; //左右孩子 &#125;BiTNode, *BiTree;//按先序遍历创建二叉树 //BiTree *CreateBiTree() //返回结点指针类型 //void CreateBiTree(BiTree &amp;root) //引用类型的参数 void CreateBiTree(BiTNode **root) //二级指针作为函数参数 &#123; char ch; //要插入的数据 scanf("\n%c", &amp;ch); //cin&gt;&gt;ch; if (ch == '#') *root = NULL; else &#123; *root = (BiTNode *)malloc(sizeof(BiTNode)); (*root)-&gt;data = ch; printf("请输入%c的左孩子：", ch); CreateBiTree(&amp;((*root)-&gt;lchild)); printf("请输入%c的右孩子：", ch); CreateBiTree(&amp;((*root)-&gt;rchild)); &#125;&#125;//前序遍历的算法程序 void PreOrder(BiTNode *root)&#123; if (root == NULL) return; printf("%c ", root-&gt;data); //输出数据 PreOrder(root-&gt;lchild); //递归调用，前序遍历左子树 PreOrder(root-&gt;rchild); //递归调用，前序遍历右子树 &#125;//中序遍历的算法程序 void InOrder(BiTNode *root)&#123; if (root == NULL) return; InOrder(root-&gt;lchild); //递归调用，前序遍历左子树 printf("%c ", root-&gt;data); //输出数据 InOrder(root-&gt;rchild); //递归调用，前序遍历右子树 &#125;//后序遍历的算法程序 void PostOrder(BiTNode *root)&#123; if (root == NULL) return; PostOrder(root-&gt;lchild); //递归调用，前序遍历左子树 PostOrder(root-&gt;rchild); //递归调用，前序遍历右子树 printf("%c ", root-&gt;data); //输出数据 &#125;/*二叉树的非递归前序遍历，前序遍历思想：先让根进栈，只要栈不为空，就可以做弹出操作，每次弹出一个结点，记得把它的左右结点都进栈，记得右子树先进栈，这样可以保证右子树在栈中总处于左子树的下面。*/void PreOrder_Nonrecursive(BiTree T) //先序遍历的非递归 &#123; if (!T) return; stack&lt;BiTree&gt; s; s.push(T); while (!s.empty()) &#123; BiTree temp = s.top(); cout &lt;&lt; temp-&gt;data &lt;&lt; " "; s.pop(); if (temp-&gt;rchild) s.push(temp-&gt;rchild); if (temp-&gt;lchild) s.push(temp-&gt;lchild); &#125;&#125;void PreOrder_Nonrecursive1(BiTree T) //先序遍历的非递归&#123; if (!T) return; stack&lt;BiTree&gt; s; BiTree curr = T; while (curr != NULL || !s.empty()) &#123; while (curr != NULL) &#123; cout &lt;&lt; curr-&gt;data &lt;&lt; " "; s.push(curr); curr = curr-&gt;lchild; &#125; if (!s.empty()) &#123; curr = s.top(); s.pop(); curr = curr-&gt;rchild; &#125; &#125;&#125;void PreOrder_Nonrecursive2(BiTree T) //先序遍历的非递归 &#123; if (!T) return; stack&lt;BiTree&gt; s; while (T) // 左子树上的节点全部压入到栈中 &#123; s.push(T); cout &lt;&lt; T-&gt;data &lt;&lt; " "; T = T-&gt;lchild; &#125; while (!s.empty()) &#123; BiTree temp = s.top()-&gt;rchild; // 栈顶元素的右子树 s.pop(); // 弹出栈顶元素 while (temp) // 栈顶元素存在右子树，则对右子树同样遍历到最下方 &#123; cout &lt;&lt; temp-&gt;data &lt;&lt; " "; s.push(temp); temp = temp-&gt;lchild; &#125; &#125;&#125;void InOrderTraverse1(BiTree T) // 中序遍历的非递归 &#123; if (!T) return; BiTree curr = T; // 指向当前要检查的节点 stack&lt;BiTree&gt; s; while (curr != NULL || !s.empty()) &#123; while (curr != NULL) &#123; s.push(curr); curr = curr-&gt;lchild; &#125;//while if (!s.empty()) &#123; curr = s.top(); s.pop(); cout &lt;&lt; curr-&gt;data &lt;&lt; " "; curr = curr-&gt;rchild; &#125; &#125;&#125;void InOrderTraverse(BiTree T) // 中序遍历的非递归 &#123; if (!T) return; stack&lt;BiTree&gt; s; BiTree curr = T-&gt;lchild; // 指向当前要检查的节点 s.push(T); while (curr != NULL || !s.empty()) &#123; while (curr != NULL) // 一直向左走 &#123; s.push(curr); curr = curr-&gt;lchild; &#125; curr = s.top(); s.pop(); cout &lt;&lt; curr-&gt;data &lt;&lt; " "; curr = curr-&gt;rchild; &#125;&#125;void PostOrder_Nonrecursive1(BiTree T) // 后序遍历的非递归 &#123; stack&lt;BiTree&gt; S; BiTree curr = T; // 指向当前要检查的节点 BiTree previsited = NULL; // 指向前一个被访问的节点 while (curr != NULL || !S.empty()) // 栈空时结束 &#123; while (curr != NULL) // 一直向左走直到为空 &#123; S.push(curr); curr = curr-&gt;lchild; &#125; curr = S.top(); // 当前节点的右孩子如果为空或者已经被访问，则访问当前节点 if (curr-&gt;rchild == NULL || curr-&gt;rchild == previsited) &#123; cout &lt;&lt; curr-&gt;data &lt;&lt; " "; previsited = curr; S.pop(); curr = NULL; &#125; else curr = curr-&gt;rchild; // 否则访问右孩子 &#125;&#125;void PostOrder_Nonrecursive(BiTree T) // 后序遍历的非递归 双栈法 &#123; stack&lt;BiTree&gt; s1, s2; BiTree curr; // 指向当前要检查的节点 s1.push(T); while (!s1.empty()) // 栈空时结束 &#123; curr = s1.top(); s1.pop(); s2.push(curr); if (curr-&gt;lchild) s1.push(curr-&gt;lchild); if (curr-&gt;rchild) s1.push(curr-&gt;rchild); &#125; while (!s2.empty()) &#123; printf("%c ", s2.top()-&gt;data); s2.pop(); &#125;&#125;int visit(BiTree T)&#123; if (T) &#123; printf("%c ", T-&gt;data); return 1; &#125; else return 0;&#125;void LeverTraverse(BiTree T) //方法一、非递归层次遍历二叉树 &#123; queue &lt;BiTree&gt; Q; BiTree p; p = T; if (visit(p) == 1) Q.push(p); while (!Q.empty()) &#123; p = Q.front(); Q.pop(); if (visit(p-&gt;lchild) == 1) Q.push(p-&gt;lchild); if (visit(p-&gt;rchild) == 1) Q.push(p-&gt;rchild); &#125;&#125;void LevelOrder(BiTree BT) //方法二、非递归层次遍历二叉树 &#123; BiTNode *queue[10];//定义队列有十个空间 if (BT == NULL) return; int front, rear; front = rear = 0; queue[rear++] = BT; while (front != rear)//如果队尾指针不等于对头指针时 &#123; cout &lt;&lt; queue[front]-&gt;data &lt;&lt; " "; //输出遍历结果 if (queue[front]-&gt;lchild != NULL) //将队首结点的左孩子指针入队列 &#123; queue[rear] = queue[front]-&gt;lchild; rear++; //队尾指针后移一位 &#125; if (queue[front]-&gt;rchild != NULL) &#123; queue[rear] = queue[front]-&gt;rchild; //将队首结点的右孩子指针入队列 rear++; //队尾指针后移一位 &#125; front++; //对头指针后移一位 &#125;&#125;int depth(BiTNode *T) //树的深度 &#123; if (!T) return 0; int d1, d2; d1 = depth(T-&gt;lchild); d2 = depth(T-&gt;rchild); return (d1&gt;d2 ? d1 : d2) + 1; //return (depth(T-&gt;lchild)&gt;depth(T-&gt;rchild)?depth(T-&gt;lchild):depth(T-&gt;rchild))+1; &#125;int CountNode(BiTNode *T)&#123; if (T == NULL) return 0; return 1 + CountNode(T-&gt;lchild) + CountNode(T-&gt;rchild);&#125;int main(void)&#123; BiTNode *root = NULL; //定义一个根结点 int flag = 1, k; printf(" 本程序实现二叉树的基本操作。\n"); printf("可以进行建立二叉树，递归先序、中序、后序遍历，非递归先序、中序遍历及非递归层序遍历等操作。\n"); while (flag) &#123; printf("\n"); printf("|--------------------------------------------------------------|\n"); printf("| 二叉树的基本操作如下: |\n"); printf("| 0.创建二叉树 |\n"); printf("| 1.递归先序遍历 |\n"); printf("| 2.递归中序遍历 |\n"); printf("| 3.递归后序遍历 |\n"); printf("| 4.非递归先序遍历 |\n"); printf("| 5.非递归中序遍历 |\n"); printf("| 6.非递归后序遍历 |\n"); printf("| 7.非递归层序遍历 |\n"); printf("| 8.二叉树的深度 |\n"); printf("| 9.二叉树的结点个数 |\n"); printf("| 10.退出程序 |\n"); printf("|--------------------------------------------------------------|\n"); printf(" 请选择功能："); scanf("%d", &amp;k); switch (k) &#123; case 0: printf("请建立二叉树并输入二叉树的根节点："); CreateBiTree(&amp;root); break; case 1: if (root) &#123; printf("递归先序遍历二叉树的结果为："); PreOrder(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 2: if (root) &#123; printf("递归中序遍历二叉树的结果为："); InOrder(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 3: if (root) &#123; printf("递归后序遍历二叉树的结果为："); PostOrder(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 4: if (root) &#123; printf("非递归先序遍历二叉树："); PreOrder_Nonrecursive1(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 5: if (root) &#123; printf("非递归中序遍历二叉树："); InOrderTraverse1(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 6: if (root) &#123; printf("非递归后序遍历二叉树："); PostOrder_Nonrecursive(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 7: if (root) &#123; printf("非递归层序遍历二叉树："); //LeverTraverse(root); LevelOrder(root); printf("\n"); &#125; else printf(" 二叉树为空！\n"); break; case 8: if (root) printf("这棵二叉树的深度为：%d\n", depth(root)); else printf(" 二叉树为空！\n"); break; case 9: if (root) printf("这棵二叉树的结点个数为：%d\n", CountNode(root)); else printf(" 二叉树为空！\n"); break; default: flag = 0; printf("程序运行结束，按任意键退出！\n"); &#125; &#125; system("pause"); return 0;&#125; 07 图的两种遍历方法及对应的生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#define _CRT_SECURE_NO_WARNINGS//图的遍历是指按某条搜索路径访问图中每个结点，使得每个结点均被访问一次，而且仅被访问一次。图的遍历有深度遍历算法和广度遍历算法，程序如下：#include &lt;iostream&gt;#include&lt;stdio.h&gt;#define INFINITY 32767#define MAX_VEX 20 //最大顶点个数#define QUEUE_SIZE (MAX_VEX+1) //队列长度using namespace std;bool *visited; //访问标志数组 //图的邻接矩阵存储结构typedef struct &#123; char *vexs; //顶点向量 int arcs[MAX_VEX][MAX_VEX]; //邻接矩阵 int vexnum, arcnum; //图的当前顶点数和弧数&#125;Graph;//队列类class Queue &#123;public: void InitQueue() &#123; base = (int *)malloc(QUEUE_SIZE * sizeof(int)); front = rear = 0; &#125; void EnQueue(int e) &#123; base[rear] = e; rear = (rear + 1) % QUEUE_SIZE; &#125; void DeQueue(int &amp;e) &#123; e = base[front]; front = (front + 1) % QUEUE_SIZE; &#125;public: int *base; int front; int rear;&#125;;//图G中查找元素c的位置int Locate(Graph G, char c) &#123; for (int i = 0; i&lt;G.vexnum; i++) if (G.vexs[i] == c) return i; return -1;&#125;//创建无向网void CreateUDN(Graph &amp;G) &#123; int i, j, w, s1, s2; char a, b, temp; printf("输入顶点数和弧数:"); scanf("%d%d", &amp;G.vexnum, &amp;G.arcnum); temp = getchar(); //接收回车 G.vexs = (char *)malloc(G.vexnum * sizeof(char)); //分配顶点数目 printf("输入%d个顶点.\n", G.vexnum); for (i = 0; i&lt;G.vexnum; i++) &#123; //初始化顶点 printf("输入顶点%d:", i); scanf("%c", &amp;G.vexs[i]); temp = getchar(); //接收回车 &#125; for (i = 0; i&lt;G.vexnum; i++) //初始化邻接矩阵 for (j = 0; j&lt;G.vexnum; j++) G.arcs[i][j] = INFINITY; printf("输入%d条弧.\n", G.arcnum); for (i = 0; i&lt;G.arcnum; i++) &#123; //初始化弧 printf("输入弧%d:", i); scanf("%c %c %d", &amp;a, &amp;b, &amp;w); //输入一条边依附的顶点和权值 temp = getchar(); //接收回车 s1 = Locate(G, a); s2 = Locate(G, b); G.arcs[s1][s2] = G.arcs[s2][s1] = w; &#125;&#125;//图G中顶点k的第一个邻接顶点int FirstVex(Graph G, int k) &#123; if (k &gt;= 0 &amp;&amp; k&lt;G.vexnum) &#123; //k合理 for (int i = 0; i&lt;G.vexnum; i++) if (G.arcs[k][i] != INFINITY) return i; &#125; return -1;&#125;//图G中顶点i的第j个邻接顶点的下一个邻接顶点int NextVex(Graph G, int i, int j) &#123; if (i &gt;= 0 &amp;&amp; i&lt;G.vexnum &amp;&amp; j &gt;= 0 &amp;&amp; j&lt;G.vexnum) &#123; //i,j合理 for (int k = j + 1; k&lt;G.vexnum; k++) if (G.arcs[i][k] != INFINITY) return k; &#125; return -1;&#125;//深度优先遍历void DFS(Graph G, int k) &#123; int i; if (k == -1) &#123; //第一次执行DFS时,k为-1 for (i = 0; i&lt;G.vexnum; i++) if (!visited[i]) DFS(G, i); //对尚未访问的顶点调用DFS &#125; else &#123; visited[k] = true; printf("%c ", G.vexs[k]); //访问第k个顶点 for (i = FirstVex(G, k); i &gt;= 0; i = NextVex(G, k, i)) if (!visited[i]) DFS(G, i); //对k的尚未访问的邻接顶点i递归调用DFS &#125;&#125;//广度优先遍历void BFS(Graph G) &#123; int k; Queue Q; //辅助队列Q Q.InitQueue(); for (int i = 0; i&lt;G.vexnum; i++) if (!visited[i]) &#123; //i尚未访问 visited[i] = true; printf("%c ", G.vexs[i]); Q.EnQueue(i); //i入列 while (Q.front != Q.rear) &#123; Q.DeQueue(k); //队头元素出列并置为k for (int w = FirstVex(G, k); w &gt;= 0; w = NextVex(G, k, w)) if (!visited[w]) &#123; //w为k的尚未访问的邻接顶点 visited[w] = true; printf("%c ", G.vexs[w]); Q.EnQueue(w); &#125; &#125; &#125;&#125;//主函数void main() &#123; int i; Graph G; CreateUDN(G); visited = (bool *)malloc(G.vexnum * sizeof(bool)); printf("\n深度优先遍历: "); for (i = 0; i&lt;G.vexnum; i++) visited[i] = false; DFS(G, -1); printf("\n广度优先遍历: "); for (i = 0; i&lt;G.vexnum; i++) visited[i] = false; BFS(G); printf("\n程序结束.\n"); getchar();&#125; 08 给定一个有向图，对其拓扑排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define Maxsize 30#define INFINITY 99999using namespace std;typedef struct ArcNode&#123; int adjvex; struct ArcNode *nextarc;&#125;ArcNode;typedef struct adjlist&#123; char name[10]; int indegree; ArcNode *firstarc;&#125;adjlist;typedef struct&#123; int vexnum, arcnum; adjlist ver[Maxsize];&#125;ALGraph;int Locatecity(ALGraph G, char v[]);void createGraph();void output(ALGraph G);void FindInDegree(ALGraph &amp;G);void TopologicalSort(ALGraph &amp;G);void TopologicalSort(ALGraph &amp;G)&#123; int i, j, e, count; stack&lt;int&gt; s; ArcNode *p; FindInDegree(G); for (i = 0; i&lt;G.vexnum; i++) if (!G.ver[i].indegree) s.push(i); count = 0; //对顶点进行计数 cout &lt;&lt; "拓扑排序的结果如下: \n"; while (!s.empty()) &#123; e = s.top(); cout &lt;&lt; G.ver[e].name &lt;&lt; " "; count++; s.pop(); for (p = G.ver[e].firstarc; p; p = p-&gt;nextarc) &#123; if (!(--G.ver[p-&gt;adjvex].indegree)) s.push(p-&gt;adjvex); &#125;//for &#125;//while cout &lt;&lt; endl; if (count&lt;G.vexnum) &#123; cout &lt;&lt; "该有向图有回路\n"; return; &#125;//if&#125;void FindInDegree(ALGraph &amp;G)&#123; int indeg, i, j; ArcNode *p; for (i = 0; i&lt;G.vexnum; i++) &#123; indeg = 0; for (j = 0; j&lt;G.vexnum; j++) &#123; if (G.ver[j].firstarc != NULL) &#123; p = G.ver[j].firstarc; while (p) &#123; if (p-&gt;adjvex == i) indeg++; p = p-&gt;nextarc; &#125;//while &#125;//if &#125;//for G.ver[i].indegree = indeg; &#125;//for&#125;void createGraph()&#123; ALGraph G; cout &lt;&lt; "请输入图的顶点个数: \n"; cin &gt;&gt; G.vexnum; cout &lt;&lt; "请输入弧数:\n"; cin &gt;&gt; G.arcnum; for (int i = 0; i&lt;G.vexnum; i++) &#123; cout &lt;&lt; "第 " &lt;&lt; i + 1 &lt;&lt; " 个顶点的名称\n"; cin &gt;&gt; G.ver[i].name; G.ver[i].indegree = 0; //都初始化为零 G.ver[i].firstarc = NULL; &#125;//for int n, m; char v1[10], v2[10]; for (int j = 0; j&lt;G.arcnum; j++) &#123; cout &lt;&lt; "请输入第 " &lt;&lt; j + 1 &lt;&lt; " 条弧的弧尾与弧头" &lt;&lt; endl; cin &gt;&gt; v1 &gt;&gt; v2; n = Locatecity(G, v1); m = Locatecity(G, v2); ArcNode *p, *q, *t; p = (ArcNode*)malloc(sizeof(ArcNode)); p-&gt;adjvex = m; p-&gt;nextarc = NULL; if (G.ver[n].firstarc == NULL) G.ver[n].firstarc = p; else &#123; q = G.ver[n].firstarc; while (q-&gt;nextarc) q = q-&gt;nextarc; q-&gt;nextarc = p; &#125;//else &#125;//for output(G); TopologicalSort(G);&#125;void output(ALGraph G)&#123; int i, j; ArcNode *p; cout &lt;&lt; "有向图的邻接边的对应关系为:\n"; for (i = 0; i&lt;G.vexnum; i++) &#123; if (G.ver[i].firstarc != NULL) &#123; p = G.ver[i].firstarc; while (p) &#123; cout &lt;&lt; p-&gt;adjvex &lt;&lt; " "; p = p-&gt;nextarc; &#125;//while &#125;//if cout &lt;&lt; endl; &#125;//for&#125;int Locatecity(ALGraph G, char v[]) //定位v在G中的位置的函数&#123; int i; for (i = 0; i&lt;G.vexnum; i++) if (!strcmp(G.ver[i].name, v)) break; return i;&#125;int main()&#123; createGraph(); system("PAUSE"); return 0;&#125; 09 二叉排序树的建立，删除，插入节点，查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#include&lt;malloc.h&gt;#define MaxSize 100typedef int KeyType;typedef char InfoType;typedef struct node&#123; KeyType key; InfoType data; struct node *lchild, *rchild;&#125;BSTNode;int path[MaxSize];void DispBST(BSTNode *b);int InsetBST(BSTNode *&amp;p, KeyType k)&#123; if (p == NULL) &#123; p = (BSTNode *)malloc(sizeof(BSTNode)); p-&gt;key = k; p-&gt;lchild = p-&gt;rchild = NULL; return 1; &#125; else if (k == p-&gt;key) return 0; else if (k &lt; p-&gt;key) return InsetBST(p-&gt;lchild, k); else return InsetBST(p-&gt;rchild, k);&#125;BSTNode *CreatBST(KeyType A[], int n)&#123; BSTNode *bt = NULL; int i = 0; while (i&lt;n) &#123; if (InsetBST(bt, A[i]) == 1) &#123; printf("第%d步 插入%d:", i + 1, A[i]); DispBST(bt); i++; &#125; &#125; return bt;&#125;void Delete1(BSTNode *p, BSTNode *&amp;r)&#123; BSTNode *q; if (r-&gt;rchild != NULL) Delete1(p, r-&gt;rchild); else &#123; p-&gt;key = r-&gt;key; q = r; r = r-&gt;lchild; free(q); &#125;&#125;void Delete(BSTNode *&amp;p)&#123; BSTNode *q; if (p-&gt;rchild == NULL) &#123; q = p; p = p-&gt;lchild; free(q); &#125; else if (p-&gt;lchild == NULL) &#123; q = p; p = p-&gt;rchild; free(q); &#125; else Delete1(p, p-&gt;lchild);&#125;int DeleteBST(BSTNode *&amp;bt, KeyType k)&#123; if (bt == NULL) return 0; else &#123; if (k &lt; bt-&gt;key) return DeleteBST(bt-&gt;lchild, k); else if (k &gt; bt-&gt;key) return DeleteBST(bt-&gt;rchild, k); else &#123; Delete(bt); return 1; &#125; &#125;&#125;void SearchBST(BSTNode *bt, KeyType k, KeyType path[], int i)&#123; int j; if (bt == NULL) return; else if (k == bt-&gt;data) &#123; path[i + 1] = bt-&gt;key; for (j = 0; j &lt;= i + 1; j++) &#123; printf("%3d", path[j]); &#125; &#125; else &#123; path[i + 1] = bt-&gt;key; if (k &lt; bt-&gt;key) SearchBST(bt-&gt;lchild, k, path, i + 1); else SearchBST(bt-&gt;rchild, k, path, i + 1); &#125;&#125;int SearchBST2(BSTNode *bt, KeyType k)&#123; if (bt == NULL) return 0; else if (k == bt-&gt;key) &#123; printf("%3d", bt-&gt;data); return 1; &#125; else if (k &lt; bt-&gt;key) SearchBST2(bt-&gt;lchild, k); else SearchBST2(bt-&gt;rchild, k); printf("%3d", bt-&gt;key);&#125;void DispBST(BSTNode *bt)&#123; if (bt != NULL) &#123; printf("%d", bt-&gt;key); if (bt-&gt;lchild != NULL || bt-&gt;rchild != NULL) &#123; printf("("); DispBST(bt-&gt;lchild); if (bt-&gt;rchild != NULL) printf(","); DispBST(bt-&gt;rchild); printf(")"); &#125; &#125;&#125;KeyType predt = -32767;int JundgBST(BSTNode *bt)&#123; int b1, b2; if (bt == NULL) return 1; else &#123; b1 = JundgBST(bt-&gt;lchild); if (b1 == 0 || predt &gt;= bt-&gt;key) return 0; predt = bt-&gt;key; b2 = JundgBST(bt-&gt;rchild); return b2; &#125;&#125;void main()&#123; BSTNode *bt; KeyType k = 6; int a[] = &#123; 4,9,3,8,7,0,1,2,5,6 &#125;, n = 10; printf("创建一颗BST树"); bt = CreatBST(a, n); printf("BST："); DispBST(bt); printf("bt%s\n", (JundgBST(bt) ? "是一颗树" : "不是一颗树")); printf("查找%d关键字(递归，顺序)", k); SearchBST(bt, k, path, -1); printf("查找%d关键字(非递归，逆序)", k); SearchBST2(bt, k); printf("删除操作：\n"); printf("原BST："); DispBST(bt); printf("\n"); printf("删除节点4"); DeleteBST(bt, 4); DispBST(bt); getchar();&#125; 10 希尔排序 与 快速排序的比较123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_DEPRECATE#include&lt;stdio.h&gt;#define Max 30typedef struct&#123; int key;&#125;RecType;RecType R[Max], S[Max];void ShellSort(RecType R[], int n)&#123; int i, j, gap; RecType tmp; gap = n / 2; while (gap&gt;0) &#123; for (i = gap; i &lt; n; i++) &#123; tmp = R[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; tmp.key&lt;R[j].key) &#123; R[j + gap] = R[j]; j = j - gap; &#125; R[j + gap] = tmp; &#125; gap = gap / 2; &#125;&#125;void QuickSort(RecType R[], int s, int t)&#123; int i = s, j = t; RecType tmp; if (s &lt; j) &#123; tmp = R[s]; while (i != j) &#123; while (j &gt; i&amp;&amp;R[j].key &gt; tmp.key) j--; R[i] = R[j]; while (i &lt; j&amp;&amp;R[i].key &lt; tmp.key) i++; R[j] = R[i]; &#125; R[i] = tmp; QuickSort(R, s, i - 1); QuickSort(R, i + 1, t); &#125;&#125;void main()&#123; int n, i; printf("请输入关键字个数：\n"); scanf("%d", &amp;n); printf("请输入关键字序列：\n"); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;R[i].key); S[i].key = R[i].key; &#125; ShellSort(R, n); printf("希尔排序结果为："); for (i = 0; i &lt; n; i++) printf("%d", R[i].key); printf("\n"); QuickSort(S, 0, n - 1); printf("快速排序结果为："); for (i = 0; i &lt; n; i++) printf("%d", S[i].key);&#125; 11123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int tile = 0;//L型骨牌数量int Matrix[100][100];//定义数据结构void ChessBoard(int tr, int tc, int dr, int dc, int size)&#123; //tr tc 行号 列号 if (size == 1) return; int t = tile++;//L型骨牌号 int s = size / 2;//分割棋盘 if (dr &lt; tr + s&amp;&amp;dc &lt; tc + s)//用L型骨牌覆盖左上角棋盘 ChessBoard(tr, tc, dr, dc, s);//特殊方格在此棋盘中 else &#123; //特殊方格不在此棋盘中，t号L型骨牌覆盖右下角 Matrix[tr + s - 1][tc + s - 1];//覆盖本子棋盘其余方格 ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s); &#125; if (dr &lt; tr + s&amp;&amp;dc &gt;= tc + s)//用L型骨牌号覆盖右上角棋盘 ChessBoard(tr, tc, dr, dc, s); else &#123; //特殊方格不在此棋盘中，t号L型骨牌覆盖左下角 Matrix[tr + s - 1][tc + s] = t;//覆盖本子棋盘其余方格 ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; if (dr &gt;= tr + s&amp;&amp;dc&lt;tc + s)//用L型骨牌覆盖左下角子棋盘 ChessBoard(tr + s, tc, dr, dc, s); else &#123; //特殊方格不在此棋盘中，t号L型骨牌覆盖右上角 Matrix[tr + s][tc + s] = t;//覆盖本子棋盘其余方格 ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; if (dr &gt;= tr + s&amp;&amp;dc &gt;= tc + s)//用L骨牌覆盖右上角子棋盘 ChessBoard(tr + s, tc + s, dr, dc, s); else &#123; //特殊方格不在此棋盘中，t号L型骨牌覆盖右上角 Matrix[tr + s][tc + s] = t;//覆盖本子棋盘其余方格 ChessBoard(tr, tc + s, tr + s, tc + s, s); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构上机指导]]></title>
    <url>%2F2017%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E6%9C%BA%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[1.1 求素数12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;bool prime(int n)&#123; int i; for (i = 2; i &lt;= (int)sqrt(n); i++) &#123; if (n%i == 0) return false; else return true; &#125;&#125;int main()&#123; int n, i, j = 0; printf("n:" ); scanf("%d",&amp;n); printf("小于等于%d的素数", n); if (n&gt;2) &#123; printf("%4d", n); j++; &#125; for (i = 3; i &lt;= n; i += 2) if (prime(i)) &#123; printf("%4d", i); if (j != 0 &amp;&amp; ++j % 10 == 0) printf("\n"); &#125; printf("\n");&#125; 1.2 求正整数各位数字之和12345678910111213141516171819#include&lt;stdio.h&gt;int func(int num)&#123; int s=0; do&#123; s+=num%10; num/=10; &#125;while(num); return (s);&#125;int main()&#123; int n; printf("输入一个整数："); scanf("%d",&amp;n); printf("各位数字之和:%d",func(n) );&#125; 1.3 求一个字符串是否为回文1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 100//算法bool func(char s[])&#123; bool flag=true; int i,j,slen=strlen(s); for(i=0,j=slen-1;i&lt;j;i++,j--)&#123; if(s[i]!=s[j])&#123; flag=false; break; &#125; &#125; return (flag);&#125;int main()&#123; char s[MAX]; printf("输入一串字符：" ); scanf("%s",s); if(func(s))&#123; printf("%s是回文字符串",s);&#125; else&#123; printf("%s不是回文字符串",s );&#125;&#125; 2.1 实现顺序表基本运算*123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//文件1#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MaxSize 50typedef char ElemTypetypedef struct&#123; ElemType date[MaxSize]; int length;&#125;SqList;//初始化线性表void InitList(SqList *&amp; L)&#123;L=(SqList *)malloc(SqList);L-&gt;length;&#125;//销毁线性表void DestroyList(SqList *L)&#123;free(L)&#125;//判断线性表是否为空bool ListEmpty(SqList *L)&#123;return L-&gt;length==0;&#125;//求线性表的长度int ListLength(SqList *L)&#123;return (L-&gt;length);&#125;//输出线性表void DispList(SqList *L)&#123;int i; if(ListEmpty(L))return; for(i=0;i&lt;n;i++)&#123; printf(" %c",L-&gt;data[i] ); &#125;&#125; //求线性表中数据元素的值bool GetElem(SqList *L,int i,ElemType &amp;e)&#123;if(i&lt;1||i&gt;L-&gt;length) return false; e=L-&gt;data[i-1]; return true;&#125;//按元素值查找int LocatElem(SqList *L,ElemType e)&#123;int i=0; while(i&lt;L-&gt;length&amp;&amp;L-&gt;data[i]!=e) i++;if(i&gt;=L-&gt;length) return 0;else return i+1; &#125;//插入数据元素bool ListInsert(SqList *L,int i,ElemType e)&#123;int j; if(i&lt;1||i&gt;L-&gt;length+1) return false; i--; for(j=L-&gt;length;j&gt;i;j--) L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i]=e; L-&gt;length++; return true; &#125;//删除数据元素bool ListDelete(SqList *&amp;L,int i,ElemType &amp;e)&#123;int j; if(i&lt;1||i&gt;L-&gt;length) return false; i--; e=L-&gt;data[i]; for(j=i;j&lt;L-&gt;length;j++) L-&gt;data[j]=L-&gt;data[j+1]; L-&gt;length--; return true; &#125;//文件2#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MaxSize 50typedef char ElemTypetypedef struct&#123; ElemType date[MaxSize]; int length;&#125;SqList;extern void InitList(SqList *&amp; L);extern void DestroyList(SqList *L);extern bool ListEmpty(SqList *L);extern int ListLength(SqList *L);extern void DispList(SqList *L);extern bool GetElem(SqList *L,int i,ElemType &amp;e);extern int LocatElem(SqList *L,ElemType e);extern bool ListInsert(SqList *L,int i,ElemType e);extern bool ListDelete(SqList *&amp;L,int i,ElemType &amp;e);void main()&#123; SqList *L;ElemType e; printf("顺序表的基本运算如下：" ); printf("初始化线性表"); InitList(L); printf("(2)采用尾插法建表"); ListInsert(L,1,'a'); ListInsert(L,2,'b'); ListInsert(L,3,'c'); ListInsert(L,4,'d'); ListInsert(L,5,'e'); printf("(3)输出顺序表"); DispList(L); printf("(4)顺序表L的长度=%d\n",ListLength(L)); printf("(5)顺序表为%s\n",ListEmpty(L)?"空":"非空"); GetElem(L,3,e); printf("(6)线性表L的第三个元素%c\n",e ); printf("(7)元素a的位置=%d\n",LocatElem(L,'a') ); printf("(8)在第四个位置插入f\n" ); ListInsert(L,4.f); printf("(9)输出顺序表\n" ); DispList(L); printf("删除L的第三个元素\n" ); ListDelete(L,3,e); printf("输出线性表\n" ); DispList(L); printf("释放线性表\n", ); DestroyList(L);&#125; 2.2 实现单链表各种基本运算方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[qqbot]]></title>
    <url>%2F2017%2F03%2F22%2Fqqbot%2F</url>
    <content type="text"><![CDATA[只有两步，但只能查看信息，搜索信息 pip install qqbot qqbot 扫码 云服务器部署截图（windows本地部署图片失效）(已被禁啦 去年初还可以玩的，顺便说一句，写博客时，被有的群拉黑啦 ，因为无差别自动回复) SmartqqBot+图灵机器人 python的安装 pip的安装 下载SmartqqBot源码 注册图灵账号并创建机器人获得apikey 然后开始搞事情 1.python的安装 pip的安装 别忘啦配置路径 python安装 重点说pip（为安装一些依赖库而生）这个坑python官网 图灵机器人插件配置(把序列号贴进key（src/smartqq-plugin/turing_boot文件中）) 运行run.py]]></content>
  </entry>
  <entry>
    <title><![CDATA[eclipse开发计算器]]></title>
    <url>%2F2017%2F03%2F20%2Feclipse%E5%BC%80%E5%8F%91%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[eclipse目录结构三大部分 AndroidManifest.xml layout(res资源的一部分) src AndroidManifest.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.jisuanqil" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" /&gt; &lt;application android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;activity android:name="com.example.jisuanqil.MainActivit" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; layout(res资源的一部分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#000000" &gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="60dip" android:background="#FFFFFF" android:editable="false" android:id="@+id/et_showview" android:gravity="bottom|right" android:textSize="20sp" /&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="fill_parent" android:layout_marginTop="20dip" android:gravity="center_horizontal" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:orientation="horizontal" &gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_clear" android:background="#FFFFFF" android:text="C" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_del" android:background="#FFFFFF" android:text="DEL" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_divide" android:background="#FFFFFF" android:text="÷" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_multiply" android:background="#FFFFFF" android:text="×" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dip" android:gravity="center_horizontal" android:orientation="horizontal" &gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_7" android:background="#FFFFFF" android:text="7" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_8" android:background="#FFFFFF" android:text="8" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_9" android:background="#FFFFFF" android:text="9" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_minus" android:background="#FFFFFF" android:text="－" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dip" android:gravity="center_horizontal" android:orientation="horizontal" &gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_4" android:background="#FFFFFF" android:text="4" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_5" android:background="#FFFFFF" android:text="5" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_6" android:background="#FFFFFF" android:text="6" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_pluse" android:background="#FFFFFF" android:text="＋" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginTop="10dip" android:gravity="center_horizontal" android:orientation="horizontal" &gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_1" android:background="#FFFFFF" android:text="1" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_2" android:background="#FFFFFF" android:text="2" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_3" android:background="#FFFFFF" android:text="3" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="10dip" android:orientation="horizontal" &gt; &lt;Button android:layout_width="130dp" android:layout_height="60dp" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_0" android:background="#FFFFFF" android:text="0" /&gt; &lt;Button android:layout_width="60dp" android:layout_height="60dp" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:text="." android:id="@+id/btn_point" android:background="#FFFFFF" android:textSize="20sp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width="60dip" android:layout_height="130dip" android:layout_marginLeft="10dip" android:gravity="bottom|right" android:paddingBottom="10dp" android:paddingRight="10dp" android:textSize="20sp" android:id="@+id/btn_equal" android:background="#FFFFFF" android:text="=" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; src123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package com.example.jisuanqil;import java.util.ArrayList;import java.util.Arrays;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity implements OnClickListener &#123; Button btn_0; Button btn_1; Button btn_2; Button btn_3; Button btn_4; Button btn_5; Button btn_6; Button btn_7; Button btn_8; Button btn_9; Button btn_point;// 小数点 Button btn_divide;// 除以 Button btn_multiply;// 乘以 Button btn_minus;// 减去 Button btn_pluse;// 加 Button btn_equal;// 等于 Button btn_clear; Button btn_del; EditText et_showview; boolean needclear; protected void onCreat(Bundle saveInstenceState)&#123; super.onCreate(saveInstenceState); setContentView(R.layout.activity); btn_0 = (Button) findViewById(R.id.btn_0); btn_1 = (Button) findViewById(R.id.btn_1); btn_2 = (Button) findViewById(R.id.btn_2); btn_3 = (Button) findViewById(R.id.btn_3); btn_4 = (Button) findViewById(R.id.btn_4); btn_5 = (Button) findViewById(R.id.btn_5); btn_6 = (Button) findViewById(R.id.btn_6); btn_7 = (Button) findViewById(R.id.btn_7); btn_8 = (Button) findViewById(R.id.btn_8); btn_9 = (Button) findViewById(R.id.btn_9); btn_point = (Button) findViewById(R.id.btn_point);// 小数点 btn_divide = (Button) findViewById(R.id.btn_divide);// 除以 btn_multiply = (Button) findViewById(R.id.btn_multiply);// 乘以 btn_minus = (Button) findViewById(R.id.btn_minus);// 减去 btn_pluse = (Button) findViewById(R.id.btn_pluse);// 加 btn_equal = (Button) findViewById(R.id.btn_equal);// 等于 btn_clear = (Button) findViewById(R.id.btn_clear); btn_del = (Button) findViewById(R.id.btn_del); et_showview = (EditText) findViewById(R.id.et_showview); btn_0.setOnClickListener(this); btn_1.setOnClickListener(this); btn_2.setOnClickListener(this); btn_3.setOnClickListener(this); btn_4.setOnClickListener(this); btn_5.setOnClickListener(this); btn_6.setOnClickListener(this); btn_7.setOnClickListener(this); btn_8.setOnClickListener(this); btn_9.setOnClickListener(this); btn_point.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_multiply.setOnClickListener(this); btn_minus.setOnClickListener(this); btn_pluse.setOnClickListener(this); btn_equal.setOnClickListener(this); btn_clear.setOnClickListener(this); btn_del.setOnClickListener(this); &#125; public void onClick(View v)&#123; String str = et_showview.getText().toString(); switch (v.getId()) &#123; case R.id.btn_0: case R.id.btn_1: case R.id.btn_2: case R.id.btn_3: case R.id.btn_4: case R.id.btn_5: case R.id.btn_6: case R.id.btn_7: case R.id.btn_8: case R.id.btn_9: case R.id.btn_point: if(needclear)&#123; str = ""; et_showview.setText(""); &#125; et_showview.setText(str + ((Button) v).getText()); break; case R.id.btn_pluse: case R.id.btn_minus: case R.id.btn_multiply: case R.id.btn_divide: if(needclear)&#123; et_showview.setText(""); &#125; et_showview.setText(str +" "+((Button) v).getText()+" "); break; case R.id.btn_equal: getResult(); break; case R.id.btn_del: if (str != null &amp;&amp; !str.equals("")) &#123; et_showview.setText(str.substring(0, str.length() - 1)); &#125; break; case R.id.btn_clear: et_showview.setText(""); break; &#125; &#125; public void getResult()&#123; needclear = true; String exp = et_showview.getText().toString(); double r = 0; int space = exp.indexOf(' ');//用于搜索空格位置 String s1 = exp.substring(0, space);//s1用于保存第一个运算数 String op = exp.substring(space + 1, space + 2);//op用于保存运算符 String s2 = exp.substring(space + 3);//s2用于保存第二个运算数 double arg1 = Double.parseDouble(s1);//将运算数从string转换为Single double arg2 = Double.parseDouble(s2); if(op.equals("＋"))&#123; r = arg1 + arg2; &#125;else if(op.equals("－"))&#123; r = arg1 - arg2; &#125;else if(op.equals("×"))&#123; r = arg1 * arg2; &#125;else if(op.equals("÷"))&#123; if (arg2 == 0) &#123; r=0; &#125; else &#123; r = arg1 / arg2; &#125; &#125; if(!s1.contains(".")&amp;&amp;!s2.contains("."))&#123; int result = (int)r; et_showview.setText(result+""); &#125;else&#123; et_showview.setText(r+""); &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络问题]]></title>
    <url>%2F2017%2F03%2F11%2F%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[未识别的网络 已连接 重启一下网卡 点禁用 网络受限 已连接 右键打开网络共享中心 无intenet 安全 开始-运行-输入”netsh winsock reset”,然后重启系统 确认可行]]></content>
  </entry>
  <entry>
    <title><![CDATA[守望先锋专题]]></title>
    <url>%2F2017%2F03%2F10%2F%E5%AE%88%E6%9C%9B%E5%85%88%E9%94%8B%2F</url>
    <content type="text"><![CDATA[[![][pic]][douban][pic]:http://p1.bqimg.com/567571/7bcd8ffe9fa167ea.jpg[douban]:http://pan.baidu.com/s/1skUoumx Computer gamesOur topic is computer games.we have three parts to share with you .First,i will told you the best computer game –overwatchAnd then,miss xu will teach you to how to make a computer games.At last,miss Li will show you the the most successful gaming platform-steam. Part one:overwatch First,the company which made it,Blizzard.Many people think that Blizzard is like a CG company more than games company.and say that blizard company make CG by heart,make games by feet.their 3d models about buildings and heroes is one of the best in the word.For example,you can see .this two pictures are real place.and up two pictures are blizzaid model builded for overwatch.In overwatch,the places we are palying are designed based on our real life palce.like yiliaosi, king rote,66 rote and so on.so blizzaid is not only a games company and also the CG company.that’s blizzaid. Second ,let me make a simple introduce about blizzaid games.World of Warcraft (WOW) i think that everyone have seen the movie about it.DiabloStarCraftStorm heroHearth Stone What is overwatch?In future world,Overwatch is group name .we have different group like smart machine,black feet and so on.different hero belong to difference group . Overwatch:Represent hero :wenshidun flash faji and so on,In the future,overwatch is made for end the country war,there are doctor,Soldiers ,scientists and so on.but after the war,the group is broken because people don’t need them.Until,the smart robots ouni update his system and not fellow human any more.the new war is coming. people need overwatch,the world need more hero,so overwatch heroes get together again. Black feet:Represent hero :death ,black flowerBlack feet is also the enemy to overwatch.;their Faith are different,overwatch think the world need save,but black feet think the world need rebuild.they all fight for their faith.black feet want kill the key man so that it can rebuild the world quickly,on the anther hand ,overwatch protect the people that black feet want to kill. Smart machine:Attractive robot,they update their system by themselve.and think that human would be dangrous if they do noting changed.and save human only one way –Launching the war,And they did it. The hero story: crazy rabbitCrazy rabbit is doctor who want to build something with human soul.at first,the king of country interested and support the rabbit do his research.until the rabbit failed many times and start use human body do his research ,the people of the country are worried about it .the king realized it and decided to push the rabbit out of his country.In doctor rabbit,even using human body ,he still can make the thing made by part of death body alive.In this time, evil angel coming.and take what doctor rabbit want –the soul.finally,the doctor rabbit finish his research and create a monster–the pig. The new hero aolishaThe genius girl yifei update the old robot system and give it a new name.The story happen in lubini.one day,unkown enemy attract the airport,and the defined robot can stop them.after that ,people don’t thrust that robot and don’t use them.until The genius girl yifei rebuild it.the new robot has been given a heart by yifei and that make it more powerful.]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2017%2F03%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[物理层数据链路层网络层运输层&lt;h2应用层]]></content>
  </entry>
  <entry>
    <title><![CDATA[产品经理练成]]></title>
    <url>%2F2017%2F02%2F24%2F%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E7%BB%83%E6%88%90%2F</url>
    <content type="text"><![CDATA[几种软件模型 瀑布模型 快速原型模型 螺旋模型 增量模型 统一过程模型 RUP 瀑布 快速模型的区别RUP12345678简而言之：可以用迭代开发来更好的应对变化,瀑布模型属于软件工程阶段的产物软件开发的效率,质量,以及软件开发相关的管理工作.软件越发复杂,RUP可以用迭代开发来更好的应对变化,使软件的实践更加完整. 瀑布123456简而言之：太死板，不易变动。瀑布模型的优点：有利于大型软件开发过程中人员的组织、管理，有利于软件开发方法和工具的研究，从而提高了大型软件项目开发的质量和效率。瀑布模型的缺点：（1）开发过程一般不能逆转，否则代价太大；（2）实际的项目开发很难严格按该模型进行；（3）客户往往很难清楚地给出所有的需求，而该模型却要求如此。（4）软件的实际情况必须到项目开发的后期客户才能看到，这要求客户有足够的耐心。瀑布模型的使用范围：（1）用户的需求非常清楚全面，且在开发过程中没有或很少变化；（2）开发人员对软件的应用领域很熟悉；（3）用户的使用环境非常稳定；（4）开发工作对用户参与的要求很低。 快速原型12345简而言之：开发费用低、开发周期短 准确的原型设计比较困难快速原型模型的优点：（1）可以得到比较良好的需求定义，容易适应需求的变化；（2）有利于开发与培训的同步；（3）开发费用低、开发周期短且对用户更友好。快速原型模型的缺点：（1）客户与开发者对原型理解不同；（2） 准确的原型设计比较困难；（3） 不利于开发人员的创新。快速原型模型的使用范围：（1）对所开发的领域比较熟悉而且有快速的原型开发工具；（2）项目招投标时，可以以原型模型作为软件的开发模型；（3）进行产品移植或升级时，或对已有产品原型进行客户化工作时，原型模型是非常适合的。]]></content>
      <tags>
        <tag>软件模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio开发环境搭建]]></title>
    <url>%2F2017%2F02%2F22%2Fandriod%20studio%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[先说android studio 1.下载android studio2.下载JDK 并配置系统变量.3.下载SDK]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验题]]></title>
    <url>%2F2017%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0112345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; int n,count; cin&gt;&gt;n; if(n&gt;=2)&#123; printf("%d ",2); count++; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=2;j*j&lt;i;j++)&#123; if(i%j==0)&#123; continue; &#125; else&#123; printf("%d ",i); count++; if(count%10==0)&#123; printf("\n"); &#125; &#125; &#125; &#125;&#125; 03123456789101112131415161718192021#include&lt;iostream&gt;#include &lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; string g=s; for(int i=0;i&lt;s.size();i++)&#123; g[s.size()-i-1]=s[i]; &#125; if(s==g)&#123; printf("回文"); &#125; else&#123; printf("非回文"); &#125;&#125; 顺序表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;typedef int ElemType;void CreateList(SqList *&amp;L,ElemType a[],int n)//由a中的a个元素建立顺序表&#123; int i; L=(SqList *)malloc(sizeof(SqList)); for(i=0;i&lt;n;i++) L-&gt;data[i]=a[i]; L-&gt;length=n;&#125;void InitList(SqList *&amp;L）//初始化线性表&#123; L=(SqList *)malloc(sizeof(SqList)); L-&gt;length=0;&#125;void LocatElem(SqList *L,ElemType e)//查找元素&#123; int i=0; while(i&lt;L-&gt;length&amp;&amp;L-&gt;data[i]!=e) i++; if(i&gt;=L-&gt;length) return 0; else return i+1;&#125;bool ListInsert(SqList *&amp;L,int i,ElemType e)//插入元素&#123; int j; if(i&lt;1||i&gt;L-&gt;length+1) return false; i--; for(j=L-&gt;length;j&gt;i;j--) L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i]=e; L-&gt;length++; return trun;&#125;using namespace std;int main()&#123; CreateList la,lb; int j,i; i=initlist(&amp;la); if(i==1) &#125; 顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXSIZE 100typedef int DataType;#define OK 1#define ERROR -1#define FALSE 0#define True 2typedef struct&#123;DataType data[MAXSIZE];int length;&#125; SqList;int InitList(SqList *L )//初始化&#123;L-&gt;length=0; //空表，长度为0return OK;&#125;int ListEmpty(SqList *L)//判断是否为空表&#123;if (L-&gt;length==0)return True;if (L-&gt;length!=0)return FALSE;&#125;int ListLength(SqList L)//求表长&#123;return (L.length);&#125;void ListTraverse(SqList L)//输出表&#123;int i;for(i=0;i&lt;L.length;i++)printf("%d ",L.data[i]);printf("\n");&#125;int ListInsert(SqList *L,int i,DataType e)//插入元素&#123;int k;if (L-&gt;length==MAXSIZE)return ERROR;if (i&lt;1 || i&gt;L-&gt;length+1)return ERROR;if (i&lt;=L-&gt;length)&#123;for(k=L-&gt;length-1;k&gt;=i-1;k--)L-&gt;data[k+1]=L-&gt;data[k];&#125;L-&gt;data[i-1]=e;L-&gt;length++;return OK;&#125;int ListDelete(SqList *L,int i,DataType *e)//删除元素&#123;int k;if (L-&gt;length==0) return ERROR;if (i&lt;1 || i&gt;L-&gt;length) return ERROR;*e=L-&gt;data[i-1];if (i&lt;L-&gt;length)&#123;for(k=i;k&lt;L-&gt;length;k++)L-&gt;data[k-1]=L-&gt;data[k];&#125;L-&gt;length--;return OK;&#125;int ListFindEle(SqList *L,DataType e)// 查找元素&#123;int i;for (i=1; i&lt;=L-&gt;length; i++)&#123;if (e == L-&gt;data[i-1])return i;&#125;return FALSE ;&#125;int ListAlter(SqList *L,int i,DataType *e)//修改元素&#123;if (i&lt;1||i&gt;L-&gt;length)return ERROR;L-&gt;data[i-1]=*e;return OK;&#125;void ClearList(SqList *L)//清空表&#123;L-&gt;length=0; //将线性表的长度置为0&#125;//释放表空间void DestroyList(SqList *L) //释放线性表占据的所有存储空间&#123;if (L-&gt;data)free(L-&gt;data);&#125;int main()&#123;int tmp=0,locat=0,res=0,n,i;SqList *list;list=(SqList*)malloc(sizeof(*list));printf(" ***********************************\n");printf("* 1---------初始化 *\n");printf("* 2---------判断是否为空表 *\n");printf("* 3---------求表长 *\n");printf("* 4---------输出表*\n");printf("* 5---------插入元素 *\n");printf("* 6---------删除元素 *\n");printf("* 7---------查找元素 *\n");printf("* 8---------修改元素 *\n");printf("* 9---------清空表 *\n");printf("* 10--------释放表空间 *\n");printf("* 11--------输入线性表初始值 *\n");printf("* 12--------退出 *\n");printf(" ************************************\n");while(1)&#123;printf("请选择菜单号（1-12）:");scanf("%d",&amp;n);if(n==0||n&gt;11)break;switch(n)&#123;case 1:InitList(list);printf("已完成初始化!\n");break;case 2:if(ListEmpty(list)==True)printf("是空表!\n");elseprintf("不是空表!\n");break;case 3:printf("线性表长度为:%d\n",ListLength(*list));break;case 4:printf("线性表元素的值为:");ListTraverse(*list);break;case 5:printf("要插入的位置和数值为:");scanf("%d %d",&amp;locat,&amp;res);ListInsert(list,locat,res);printf("插入完成!\n");break;case 6:printf("要删除的位置为:");scanf("%d",&amp;locat);ListDelete(list,locat,&amp;res);printf("删除完成!\n");break;case 7:printf("要查找的位置为:");scanf("%d",&amp;locat);printf("该位置的值为:%d\n",ListFindEle(list,locat));break;case 8:printf("要修改的位置和数值为:");scanf("%d %d",&amp;locat,&amp;res);ListAlter(list,locat,&amp;res);printf("修改完成!\n");break;case 9:ClearList(list);printf("表中内容已清空!\n");break;case 10: DestroyList(list);printf("释放成功!\n");break;case 11:InitList(list);printf("请输入顺序表长度:");scanf("%d",&amp;list-&gt;length);printf("请输入顺序表的值:");for(i=0;i&lt; list-&gt;length;i++)scanf("%d",&amp;list-&gt;data[i]);printf("线性元素的值为:\n");ListTraverse(*list);break;case 12:exit(1);default:break;&#125;&#125;return 0;&#125; 0412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct lnode &#123; int ID; struct lnode *next; &#125;; void BubbleSort(struct lnode * head); int main() &#123; int n, i, d; while(scanf("%d", &amp;n) != EOF) &#123; //初始化带头节点的链表 struct lnode *head, *s, *r, *p; r = head; for(i = 0; i &lt; n; i ++) &#123; scanf("%d", &amp;d); s -&gt; ID = d; r -&gt; next = s; r = s; &#125; r -&gt; next = NULL; //冒泡排序 BubbleSort(head); //打印输出 for(p = head -&gt; next; p != NULL; p = p -&gt; next) &#123; if(p -&gt; next == NULL) &#123; printf("%d\n", p -&gt; ID); &#125;else &#123; printf("%d ", p -&gt; ID); &#125; &#125; &#125; return 0; &#125; void BubbleSort(struct lnode *head) &#123; struct lnode *f, *p, *x, *y; f = NULL; if(head -&gt; next == NULL || head -&gt; next -&gt; next == NULL) &#123; return; &#125; while(f != head-&gt;next-&gt;next) &#123; for(p = head; p -&gt; next -&gt; next != f; p = p -&gt; next) &#123; if(p -&gt; next -&gt; ID &gt; p -&gt; next -&gt; next -&gt;ID) &#123; x = p -&gt; next; y = p -&gt; next -&gt; next; p -&gt; next = y; x -&gt; next = y -&gt; next; y -&gt; next = x; &#125; &#125; f = p -&gt; next; &#125; &#125; 04123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;struct Node&#123; char Element; int length; Node *last,*next; &#125;;typedef char ElementType;typedef Node *List;List L; List CreateList(List &amp;L)&#123; List I=(List)malloc(sizeof(Node)); int length=0;L-&gt;next=L-&gt;last=nullptr; return I;&#125;void insect(List &amp;L,ElementType a)&#123; L-&gt;length++; Node*n=(Node *)malloc(sizeof(Node)); n-&gt;Element=a; if(L-&gt;next==nullptr)&#123; L-&gt;last=n;L-&gt;next=n; n-&gt;last=n;n-&gt;next=n; &#125; else&#123; L-&gt;last-&gt;next;//L原来的最后一个节点的next指向新最后一个节点 n-&gt;last=L-&gt;last;//新最后一个节点的last指向旧最后一个节点 n-&gt;next=L-&gt;next;//新最后一个节点指向第一个节点（循环链表） L-&gt;next-&gt;last=n;//第一个节点指向最后一个节点 L-&gt;last=n;//指定最后一个节点 &#125;&#125;void print(List &amp;L)&#123; int n=L-&gt;length; Node *Node=L-&gt;next; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;Node-&gt;Element; Node=Node-&gt;next; &#125;&#125;void output3th(List &amp;L)&#123; Node *Node=L-&gt;next; for(int i=0;i&lt;3;i++)&#123; Node=Node-&gt;next; &#125; cout&lt;&lt;Node-&gt;Element&lt;&lt;endl;&#125;void location(List &amp;L)&#123; char a; Node *Node=L-&gt;next; for(int i=1;i&lt;=L-&gt;length;i++)&#123; if(Node-&gt;Element==a)&#123; cout&lt;&lt;"a location"&lt;&lt;i; &#125; else Node=Node-&gt;next; &#125;&#125;void insect4f(List &amp;L)&#123; Node *m=(Node *)malloc(sizeof(Node)); Node *Node=L-&gt;next; for(int i=1;i&lt;=3;i++)&#123; Node-&gt;next=m; L-&gt;last-&gt;last-&gt;last=m; m-&gt;last=Node-&gt;next; m-&gt;next=L-&gt;last-&gt;last; &#125;&#125;void delete3th(List &amp;l)&#123; Node *tmp,*Node=L-&gt;next; for(int i=1;i&lt;=3;i++)&#123; Node=Node-&gt;next; &#125; tmp=Node;free(tmp);//删掉啦第三个节点 L-&gt;next-&gt;next-&gt;next=L-&gt;last-&gt;last;//第二个节点的next指向第四个节点 L-&gt;last-&gt;last-&gt;last=L-&gt;next-&gt;next;//第四个节点的last指向第二个节点&#125;void DestroyList(List &amp;L)&#123; Node *tmp,*Node=L-&gt;next; for(int i=0;i&lt;L-&gt;length;i++)&#123; tmp=Node; Node=Node-&gt;next; free(tmp); &#125; free(L);&#125;int printlength(List &amp;L)&#123; return L-&gt;length;&#125;int main()&#123; char a,b,c,d,e,f; List L=CreateList(L); insect(L,a);insect(L,b);insect(L,c);insect(L,d);insect(L,e); print(L); cout&lt;&lt;L-&gt;length&lt;&lt;endl; cout&lt;&lt;printlength(L)&lt;&lt;endl; output3th(L); location(L); insect4f(L); print(L); delete3th(L); print(L); DestroyList(L);&#125; 05123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;typedef Node2 *HList;//1.数据储存//创建存储结构#define MaxCol 10typedef int ElemType;typedef struct Node1&#123; ElemType data[MaxCol]; struct Node1 *next;&#125;DList;//指定每个表的行列数typedef struct Node2&#123; int Row, Col; DList *next;&#125;HList;//2.运算方法//建表void CreateTable(HList)&#123; int i, j; DList *r, *s; h = (HList *)malloc(sizeof(HList)); printf("表的行列数：\n"); scanf("%d%d", &amp;h-&gt;Row, &amp;h-&gt;Col); for (int i = 0; i &lt; h-&gt;Row; i++) &#123; printf("第%d行：", i + 1); s = (DList *)malloc(sizeof(DList); for (int j = 0; j-&gt;h-&gt;Col; j++) &#123; scanf("%d", &amp;s-&gt;data[j]); if (h-&gt;next == NULL) h-&gt;next = s; else r-&gt;next = s; r = s; &#125; r-&gt;next=NULL; &#125;&#125;//销毁单链表void DestroyTable(HList *h)&#123; DList *pre = h-&gt;next, *p = pre-&gt;next; while (p!=NULL) &#123; free(pre); pre = p; p = p-&gt;next; &#125; free(pre); free(h);&#125;//输出单链表void DispTable(HList *h)&#123; int j; DList *p = h-&gt;next; while (p!=NULL) &#123; for (j = 0; j &lt; h-&gt;Col; j++) &#123; printf("%4d", p-&gt;data[j]); printf("\n"); p = p-&gt;next; &#125; &#125;&#125;//表连接运算法void LinkTable(HList *h1,HList *h2,HList *h)&#123; int i, j; DList *p = h-&gt;next, *q, *s, *r; printf("连接字段是：第一个表序号，第二个表序号："); scanf("%d%d", &amp;i, &amp;j); h = (HList)malloc(sizeof(HList)); h-&gt;Row = 0; h-&gt;Col = h1-&gt;Col + h2-&gt;Col; h-&gt;next = NULL; while (p!=NULL) &#123; q = h2-&gt;next; while (q != NULL) &#123; if (p-&gt;data[i - 1] == q-&gt;data[j - 1]) &#123; s = (DList)malloc(sizeof(HList)); for (int k= 0; k &lt; h1-&gt;Col; k++) s-&gt;data[k] = p-&gt;data[k]; for (int k = 0; k &lt; h2-&gt;Col; k++) s-&gt;data[h1-&gt;Col + k] = q-&gt;data[k]; if (h-&gt;next == NULL) h-&gt;next = s; else r-&gt;next = s; r = s; h-&gt;Row++; &#125; p = p-&gt;next; &#125; r-&gt;next = NULL; &#125;&#125;void main()&#123; HList *h1, *h2, *h; printf("表1：、n"); CreateTable(h1); printf("表2：\n"); CreateTable(h2); LinkTable(h1, h2, h); printf("链接结果表：\n"); DispTable(h); DestroyTable(h1); DestroyTable(h2); DestroyTable(h);&#125; 061234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;typedef struct&#123; int i, j; int pre;&#125;Box;typedef struct&#123; Box data[10]; int front, rear;&#125;QuType;bool mgpath1(int xi, int yi, int xe, int ye)&#123; int i, j, find = 0, di; QuType qu; qu.front = qu.rear = -1; qu.rear++; qu.data[qu.rear].i = xi; qu.data[qu.rear].j = yi; //(xi, yi)进队 qu.data[qu.rear].pre = -1; mg[xi][yi] = -1; while (qu.front != qu.rear &amp;&amp; !find) &#123; qu.front++; i = qu.data[qu.front].i; j = qu.data[qu.front].j; if (i == xe&amp;&amp;j == ye) &#123; find = 1; print(qu, qu.front); return true; &#125; for (di = 0; di &lt; 4; di++) &#123; switch (di) &#123; case 0:i = qu.data[qu.front].i - 1; j = qu.data[qu.front].j; break; case 1:i = qu.data[qu.front].i; j = qu.data[qu.front].j + 1; break; case 2:i = qu.data[qu.front].i + 1; j = qu.data[qu.front].j; break; case 3:i = qu.data[qu.front].i; j = qu.data[qu.front].j - 1; break; &#125; if (mg[i][j] == 0) &#123; qu.rear++; qu.data[qu.rear].i = i; qu.data[qu.rear].j = j; qu.data[qu.rear].pre = qu.front; mg[i][j] = -1; &#125; &#125; &#125; return false;&#125;//从队列qu中输出路径void print(QuType qu, int front)&#123; int k = front, j, ns = 0; printf(&quot;\n&quot;); do &#123; j = k; k = qu.data[k].pre; qu.data[j].pre = -1; &#125; while (k != 0); printf(&quot;迷宫路径如下：、n&quot;); k = 0; while (k&lt;10) &#123; if (qu.data[k].pre == -1) &#123; ns++; printf(&quot;\t(%d,%d)&quot;, qu.data[k].i, qu.data[k].j); if (ns % 5 == 0) printf(&quot;\n&quot;); &#125; k++; &#125; printf(&quot;\n&quot;);&#125;void main()&#123; int M, N; cin &gt;&gt; M &gt;&gt; N; if (!mgpath1(1, 1, M, N)) printf(&quot;迷宫误解&quot;);&#125; 0712345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;typedef string SqString;int index(SqString s, SqString t)&#123; unsigned int i = 0, j = 0; while ( i&lt;s.length()&amp;&amp;j&lt;t.length()) &#123; if (s[i] == t[j]) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; if(j&lt;=t.length()) break; &#125; if (j &lt;= t.length())&#123; return(i - t.length());&#125; else&#123; return(-1);&#125;&#125;int main()&#123; string s = "aaaaab"; string t = "aaab"; index(s, t); return 0;&#125; 08`//创建二叉树 #include&lt;btree.h&gt;void CreatBTNode(BTnode &amp;b,char str){ BTNode St[MaxSize],p; int top=-1,k,j=0; char ch; b=NULL; ch=str[j]; while(ch!=’\0’) {switch(ch) { case ‘(‘:top++,St[top]=p;k=1;break; case ‘)’:top–;break; case ‘,’:k=z;break; default:p=(BTNode *)malloc(sizeof(BTNode)); p-&gt;data=ch;p-&gt;lchild=p-&gt;rchild=NULL; if(b==NULL) b=p; else { switch(k) { case1:St[top]-&gt;lchild=p;break; case2:St[top]-&gt;rchild=p;break; } } } j++;ch=str[j]; }} //查找节点/递归模型f(b,x)=NULLf(b,x)=bf(b,x)=pf(b,x)=f(b-&gt;rchild,x) ///对应的递归算法BTNode FindNode(BTNode b,ElemType x){ BTNode *p; if(b==NULL) return NULL; else if(b-&gt;data==x) return b; else { p=FindNode(b-&gt;lchild,x); if(p!=NULL) return p; else return FindNode(b-&gt;rchild,x); } } //找孩子节点BTNode lchildNode(BTNode p){ return p-&gt;lchild;} BTNode rchildNode(BTNode p){ return p-&gt;rchild;} //求高度/递归模型f(b)=0f(b)=MAX{f(b-&gt;lchild),f(b-&gt;rchild)} ///递归算法int BTNodeHeight(BTNode *b){ int lchild,rchild; if(b==NULL) return 0; else { lchild= BTNodeHeight(b-&gt;lchild);//求左子树的高度 rchild=BTNodeHeight(b-&gt;rchild); return (lchild&gt;rchild?(lchild+1:rchild+1)); } } //输出二叉树void DispBTNode(BTNode *b){ if(b!=NULL) { printf(“%c”,b-&gt;data); if(b-&gt;lchild!=NULL||b-&gt;rchild!=NULL) { printf(“(\n” ); DispBTNode(b-&gt;lchild); if(b-&gt;rchild!=NULL) printf(“,\n” ); DispBTNode(b-&gt;rchild); printf(“)\n” ); } }} //二叉树的遍历//先序遍历void PreOrder(BTNode b){ if(b!=NULL) { printf(“%c\n”,b-&gt;data ); PreOrder(b-&gt;lchild); PreOrder(b-&gt;rchild); }}//中根遍历void InOrder(BTNode b){ if(b!=NULL) { InOrder(b-&gt;lchild); printf(“%c\n”,b-&gt;data ); InOrder(b-&gt;rchild); }}//后根遍历 void PostOrder(BTNode b){ if(b!=NULL) { PostOrder(b-&gt;lchild); PostOrder(b-&gt;rchild); printf(“%c\n”,b-&gt;data ); }}void main(){ BTNode b,p,lp,*rp; CreatBTNode(b,”A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”); printf(“二叉树的基本运算”)； printf(“(1)输出二叉树：”); DispBTNode(b);printf(“\n” ); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2F02%2F14%2FHTML%2F</url>
    <content type="text"><![CDATA[1.HTML框架HTML决定网页内容，CSS决定网页样式，javascripe决定网页行为。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="ucf-8"&gt;//编码方式ucf-8&lt;title&gt;fuck&lt;/title&gt;//标题&lt;body&gt;//body里面是网页的内容&lt;/body&gt;&lt;/head&gt;&lt;/html&gt;//就TM这样简单 CSS以styl标签搞事情123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;body //body的样式&#123; background-color:#d0e4fe;&#125;h1 //h1的样式&#123; color:orange; text-align:center;&#125;p //page的样式&#123; font-family:"Times New Roman"; font-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;CSS 实例!&lt;/h1&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; scripe标签1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;div style="text-align:center"&gt; &lt;button onclick="playPause()"&gt;播放/暂停&lt;/button&gt; &lt;button onclick="makeBig()"&gt;放大&lt;/button&gt; &lt;button onclick="makeSmall()"&gt;缩小&lt;/button&gt; &lt;button onclick="makeNormal()"&gt;普通&lt;/button&gt; &lt;br&gt; &lt;video id="video1" width="420"&gt; &lt;source src="mov_bbb.mp4" type="video/mp4"&gt; &lt;source src="mov_bbb.ogg" type="video/ogg"&gt; 您的浏览器不支持 HTML5 video 标签。 &lt;/video&gt;&lt;/div&gt;&lt;script&gt;var myVideo=document.getElementById("video1");function playPause()&#123; if (myVideo.paused) myVideo.play(); else myVideo.pause();&#125; function makeBig()&#123; myVideo.width=560;&#125; function makeSmall()&#123; myVideo.width=320;&#125; function makeNormal()&#123; myVideo.width=420;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简单的网页以及两个常用搜索代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;fuck&lt;/title&gt;&lt;style media="screen"&gt;input[type=text] &#123; //静态栏搜索 width: 130px; box-sizing: border-box; border: 2px solid #ccc; border-radius: 4px; font-size: 16px; background-color: white; background-image: url('searchicon.png'); background-position: 10px 10px; background-repeat: no-repeat; padding: 12px 20px 12px 40px; -webkit-transition: width 0.4s ease-in-out; transition: width 0.4s ease-in-out;&#125;input[type=text]:focus &#123; width: 100%;&#125;body&#123; background-image: url('http://p1.bqimg.com/567571/1487e5929ef40176.jpg');&#125;#myInput &#123; //动态栏搜索 background-image: url('https://static.runoob.com/images/mix/searchicon.png'); /* 搜索按钮 */ background-position: 10px 12px; /* 定位搜索按钮 */ background-repeat: no-repeat; /* 不重复图片 */ width: 100%; font-size: 16px; padding: 12px 20px 12px 40px; border: 1px solid #ddd; margin-bottom: 12px;&#125;&lt;/style&gt;&lt;body&gt; &lt;input type="text" id="myInput" onkeyup="myFunction()" placeholder="搜索..."&gt; &lt;form&gt; &lt;input type="text" name="search" placeholder="Search.."&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级真题]]></title>
    <url>%2F2017%2F02%2F11%2FPAT%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1001123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int n; scanf("%d", &amp;n); int count = 0; while(n != 1)&#123; if(n % 2 != 0)&#123; n = (3 * n + 1) / 2; count ++; &#125; else&#123; n /= 2; count ++; &#125; &#125; printf("%d\n", count); return 0; cin&gt;&gt;n;&#125; 10051234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int bai,shi,ge,n; cin&gt;&gt;n; ge=n%10; shi=(n-ge)/10%10; bai=(n-shi*10-ge)/100%10; if(bai!=0) for(int i=0;i&lt;bai;i++)&#123; printf("B"); &#125; if(shi!=0) for(int i=0;i&lt;shi;i++)&#123; printf("S"); &#125; if(ge!=0) for(int i=0;i&lt;ge;i++)&#123; printf("G"); &#125;&#125; 1006123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int array[100000];int main()&#123; int n; cin&gt;&gt;n; for(int i=2;i&lt;n/2+1;i++)&#123; for(int j=2;i*j&lt;=n;j++)&#123; array[i*j]=1; &#125; &#125; int tmp=2,count; for(int j=2;j&lt;=n;j++)&#123; if(array[j]==0)&#123; if(j-tmp==2)&#123; count++; tmp=j; &#125; else&#123; tmp=j; &#125; &#125; &#125; printf("%d",count);&#125; 10071234567891011121314#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,a[100]; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[(i+m)%n]); &#125; for(int i=0;i&lt;n;i++)&#123; printf("%d ",a[i]); &#125;&#125; 10141234567891011121314#include&lt;iostream&gt;#include&lt;sstdio&gt;#include&lt;sstring&gt;using namespace std;int main()&#123; int n,lowline,eline; cin&gt;&gt;renshu&gt;&gt;lowline&gt;&gt;eline&gt;&gt;endl; int man[n][4]; for(int i=0;i&lt;n;i++)&#123; scanf("%d %d %d",man[i][0],man[i][1],man[i][2]); &#125; &#125; 1021123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;sstdio&gt;#include&lt;sstring&gt;using namespace std;int main()&#123; string s; gets(s); int count[10]; for(int i=0;i&lt;s.size();i++)&#123; if(s[i]-48=0)&#123; count[0]++; &#125; else if(s[i]-48=1)&#123; count[1]++; &#125; else if(s[i]-48=2)&#123; count[2]++; &#125; else if(s[i]-48=3)&#123; count[3]++; &#125; else if(s[i]-48=4)&#123; count[4]++; &#125; else if(s[i]-48=5)&#123; count[5]++; &#125; else if(s[i]-48=6)&#123; count[6]++; &#125; else if(s[i]-48=7)&#123; count[7]++; &#125; else if(s[i]-48=8)&#123; count[8]++; &#125; else if(s[i]-48=9)&#123; count[9]++; &#125; for(int j=0;j&lt;10;j++)&#123; printf("%d :%d",j,count[j]); &#125; &#125;&#125; 102312345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; string num1,num2; for(int i=1;i&lt;s.find('E');i++)&#123; num1[i]=s[i]; &#125; for(int i=s.find('E')+1;i&lt;s.size();i++)&#123; num2[i]=s[i]; &#125; if(s[0]="+"&amp;&amp;s.find('E')+1=='+')&#123; printf("%d",num1*pow(10,num2)); &#125; if(s[0]="+"&amp;&amp;s.find('E')+1=='-')&#123; printf("%d",1/(num1*pow(10,num2))); &#125; if(s[0]="-"&amp;&amp;s.find('E')+1=='+')&#123; printf("-%d",num1*pow(10,num2)); &#125; if(s[0]="-"&amp;&amp;s.find('E')+1=='-')&#123; printf("-%d",1/(num1*pow(10,num2))); &#125;&#125; 102512345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; float c1,c2; cin&gt;&gt;c1&gt;&gt;c2; float time=c2-c1+50; int hour=time/360000; int minute=(time-hour*360000)/6000; int second=(time-hour*360000-minute*6000)/100; printf("%02f %02f %02f",hour,minute,second);&#125; 10561234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); vector&lt;int&gt; v(n); int sum; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;v[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; sum+=v[i]*10+v[j]; sum+=v[j]*10+v[i]; &#125; &#125; printf("%d",sum);&#125; 1057123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; string s; gets(s); int sum; for(int i=0;i&lt;s,size();i++)&#123; if(s[i]&gt;='A'&amp;&amp;s[i]=&lt;'Z')&#123; sum=sum+s[i]-64; &#125; else if(s[i]&gt;='a'&amp;&amp;s[i]=&lt;'z')&#123; sum=sum+s[i]-96; &#125; int count1,count0; while(sum!=0)&#123;//十进制转二进制 除2 if(sum%2==0)&#123; count0++; &#125; eles if(sum%2==1)&#123; count1++; &#125; sum=sum/2; &#125; &#125;&#125; 106112345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); vector&lt;int&gt; vatual(m); vector&lt;int&gt; key(m); int sum=0,g; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;vatual[i]); &#125; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;key[i]); &#125; for(int i=0;i&lt;n;i++)&#123; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;g); if(g==key[i])&#123; sum=sum+key[i]; &#125; &#125;&#125; printf("%d\n",sum);&#125; 106312345678910111213141516#include&lt;cmach&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a,b; cin&gt;&gt;n; double mo; double max=0; for(i=0;i&lt;n;i++)&#123; scanf("%f %f",&amp;a.&amp;b); mo=sqrt(a*a+b*b); max=(mo&gt; max)?mo:max; &#125; printf("%0.2lf",max);&#125; 106412345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;sstdio&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; vector&lt;int&gt; v; string s; sum=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s for(j=0;j&lt;=s.size();j++)&#123; sum=sum+s[j]-'0'; &#125; vector&lt;int&gt;::iterator result=find(v.begin,v.end(),sum); if(result=v.end())&#123; v.push_back(sum); &#125; &#125; sort(v.begin,v.end()); printf("%d",v.size()); for(i=0;i&lt;v.size();i++)&#123; if(i==0)&#123; printf("%d",v[i]); &#125; else&#123; printf(" %d",v[i]); &#125; &#125;&#125; 1065123456789101112131415161718192021222324252627282930313233#include&lt;sstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int table[100000]int main ()&#123; int n; int a,b; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d %d",&amp;a,&amp;b); table[a]=b; table[b]=a; &#125; scanf("%d",&amp;n); vector&lt;int&gt; v(n); vector&lt;int&gt; doge; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;v[i]); &#125; for(int i=0;i&lt;n;i++)&#123; vector&lt;int&gt;::iterator result=find(v.begin(),v.end(),table[v[i]]); if(result==v.end()) doge.push_back(v[i]); &#125; sort(doge.begin(),doge.end()); for(int i=0;i&lt;doge.size();i++)&#123; printf("%05d",doge[i]); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F02%2F10%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法的稳定性：排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。（冒泡，直接插入排序，归并排序是稳定的，简单选择排序，希尔排序，堆排序，快排是不稳定的。） #鸡尾酒排序12345678910111213141516171819int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大定向冒泡排序 int n = sizeof(A) / sizeof(int); int left = 0; // 初始化边界 int right = n - 1;while (left &lt; right) &#123; for (int i = left; i &lt; right; i++) // 前半轮,将最大元素放到后面 if (A[i] &gt; A[i + 1]) &#123; exchange(A, i, i + 1); &#125; right--; for (int i = right; i &gt; left; i--) // 后半轮,将最小元素放到前面 if (A[i - 1] &gt; A[i]) &#123; exchange(A, i - 1, i); &#125; left++; &#125; #冒泡排序 1234567891011int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大冒泡排序 int n = sizeof(A) / sizeof(int); for (int j = 0; j &lt; n - 1; j++) // 每次最大元素就像气泡一样"浮"到数组的最后 &#123; for (int i = 0; i &lt; n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移 &#123; if (A[i] &gt; A[i + 1]) // 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法 &#123; exchange(A, i, i + 1); &#125; &#125; #快速排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;int partition(int A[], int left, int right) // 划分函数&#123; int pivot = A[right]; // 选择最后一个元素作为基准 int tail = left - 1; // tail为小于基准的子数组最后一个元素的索引 for (int i = left; i &lt; right; i++) // 遍历基准以外的其他元素 &#123; if (A[i] &lt;= pivot) // 把小于等于基准的元素放到前一个子数组中 &#123; tail++; exchange(A, tail, i); &#125; &#125; exchange(A, tail + 1, right); // 最后把基准放到前一个子数组的后边,剩下的子数组既是大于基准的子数组 // 该操作很有可能把后面元素的稳定性打乱,所以快速排序是不稳定的排序算法 return tail + 1; // 返回基准的索引&#125;void quicksort(int A[], int left, int right)&#123; int pivot_index; // 基准的索引 if (left &lt; right) &#123; pivot_index = partition(A, left, right); quicksort(A, left, pivot_index-1); quicksort(A, pivot_index+1, right); &#125;&#125;int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大快速排序 int n = sizeof(A) / sizeof(int); quicksort(A, 0, n - 1); printf("快速排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ",A[i]); &#125; printf("\n"); return 0;&#125; #插入排序 12345678910111213141516int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;// 从小到大插入排序 int n = sizeof(A) / sizeof(int); int i, j, get; for (i = 1; i &lt; n; i++) // 类似抓扑克牌排序 &#123; get = A[i]; // 右手抓到一张扑克牌 j = i - 1; // 拿在左手上的牌总是排序好的 while (j &gt;= 0 &amp;&amp; A[j] &gt; get) // 将抓到的牌与手牌从右向左进行比较 &#123; A[j + 1] = A[j]; // 如果该手牌比抓到的牌大,就将其右移 j--; &#125; A[j + 1] = get;// 直到该手牌比抓到的牌小(或二者相等),将抓到的牌插入到该手牌右边(相等元素的相对次序未变,所以插入排序是稳定的) &#125; #二分插入排序123456789101112131415161718192021222324int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大二分插入排序 int n = sizeof(A) / sizeof(int); int i, j, get, left, right, middle; for (i = 1; i &lt; n; i++) // 类似抓扑克牌排序 &#123; get = A[i]; // 右手抓到一张扑克牌 left = 0; // 拿在左手上的牌总是排序好的,所以可以用二分法 right = i - 1; // 手牌左右边界进行初始化 while (left &lt;= right) // 采用二分法定位新牌的位置 &#123; middle = (left + right) / 2; if (A[middle] &gt; get) right = middle - 1; else left = middle + 1; &#125; for (j = i - 1; j &gt;= left; j--) // 将欲插入新牌位置右边的牌整体向右移动一个单位 &#123; A[j + 1] = A[j]; &#125; A[left] = get; // 将抓到的牌插入手牌 &#125; #希尔排序 1234567891011121314151617181920212223int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大希尔排序 int n = sizeof(A) / sizeof(int); int i, j, get; int h = 0; while (h &lt;= n) // 生成初始增量 &#123; h = 3*h + 1; &#125; while (h &gt;= 1) &#123; for (i = h; i &lt; n; i++) &#123; j = i - h; get = A[i]; while ((j &gt;= 0) &amp;&amp; (A[j] &gt; get)) &#123; A[j + h] = A[j]; j = j - h; &#125; A[j + h] = get; &#125; h = (h - 1) / 3; // 递减增量 &#125; #归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int L[10]; // 两个子数组定义成全局变量（辅助存储空间,大小正比于元素的个数）int R[10];void merge(int A[], int left, int middle, int right)// 合并两个已排好序的数组A[left...middle]和A[middle+1...right]&#123; int n1 = middle - left + 1; // 两个数组的大小 int n2 = right - middle; for (int i = 0; i &lt; n1; i++) // 把两部分分别拷贝到两个数组中 L[i] = A[left + i]; for (int j = 0; j &lt; n2; j++) R[j] = A[middle + j + 1]; L[n1] = INT_MAX; // 使用无穷大作为哨兵值放在子数组的末尾 R[n2] = INT_MAX; // 这样可以免去检查某个子数组是否已读完的步骤 int i = 0; int j = 0; for (int k = left; k &lt;= right; k++) // 依次比较两个子数组中的值，每次取出更小的那一个放入原数组 &#123; if (L[i] &lt;= R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125;&#125;void mergesort_recursion(int A[], int left, int right) // 递归实现的归并排序(自顶向下)&#123; int middle = (left + right) / 2; if (left &lt; right) // 当待排序的序列长度为1时(left == right)，递归“开始回升” &#123; mergesort_recursion(A, left, middle); mergesort_recursion(A, middle + 1, right); merge(A, left, middle, right); &#125;&#125;void mergesort_iteration(int A[], int left, int right) // 非递归(迭代)实现的归并排序(自底向上)&#123; int low, middle, high; // 子数组索引,前一个为A[low...middle],后一个子数组为A[middle+1...high] for (int size = 1; size &lt;= right - left; size *= 2) // 子数组的大小初始为1,每轮翻倍 &#123; low = left; while (low + size - 1 &lt;= right - 1 )// 后一个子数组存在(需要归并) &#123; middle = low + size - 1; high = middle + size; if (high &gt; right) // 后一个子数组大小不足size high = right; merge(A, low, middle, high); low = high + 1; // 前一个子数组索引向后移动 &#125; &#125;&#125;int main()&#123; int A1[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大归并排序 int A2[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; int n1 = sizeof(A1) / sizeof(int); int n2 = sizeof(A2) / sizeof(int); mergesort_recursion(A1, 0, n1 - 1); // 递归实现 mergesort_iteration(A2, 0, n2 - 1); // 非递归实现 printf("递归实现的归并排序结果："); for (int i = 0; i &lt; n1; i++) &#123; printf("%d ",A1[i]); &#125; printf("\n"); printf("非递归实现的归并排序结果："); for (int i = 0; i &lt; n2; i++) &#123; printf("%d ", A2[i]); &#125; printf("\n"); return 0;&#125; #堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定int heapsize; // 堆大小void exchange(int A[], int i, int j) // 交换A[i]和A[j]&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp;&#125;void heapify(int A[], int i) // 堆调整函数(这里使用的是最大堆)&#123; int leftchild = 2 * i + 1; // 左孩子索引 int rightchild = 2 * i + 2; // 右孩子索引 int largest; // 选出当前结点与左右孩子之中的最大值 if (leftchild &lt; heapsize &amp;&amp; A[leftchild] &gt; A[i]) largest = leftchild; else largest = i; if (rightchild &lt; heapsize &amp;&amp; A[rightchild] &gt; A[largest]) largest = rightchild; if (largest != i) &#123; exchange(A, i, largest); // 把当前结点和它的最大(直接)子节点进行交换 heapify(A, largest); // 递归调用，继续从当前结点向下进行堆调整 &#125;&#125;void buildheap(int A[], int n) // 建堆函数&#123; heapsize = n; for (int i = heapsize / 2 - 1; i &gt;= 0; i--) // 对每一个非叶结点 heapify(A, i); // 不断的堆调整&#125;void heapsort(int A[], int n)&#123; buildheap(A, n); for (int i = n - 1; i &gt;= 1; i--) &#123; exchange(A, 0, i); // 将堆顶元素(当前最大值)与堆的最后一个元素互换(该操作很有可能把后面元素的稳定性打乱,所以堆排序是不稳定的排序算法) heapsize--; // 从堆中去掉最后一个元素 heapify(A, 0); // 从新的堆顶元素开始进行堆调整 &#125;&#125;int main()&#123; int A[] = &#123; 5, 2, 9, 4, 7, 6, 1, 3, 8 &#125;;// 从小到大堆排序 int n = sizeof(A) / sizeof(int); heapsort(A, n); printf("堆排序结果："); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); &#125; printf("\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[deploy报错及其解决方法]]></title>
    <url>%2F2017%2F02%2F01%2Fhexo%20deploy%E6%8A%A5%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#报错提示1： 123INFO Deploying: gitFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.iocs/troubleshooting.htmlTypeError: source.replace is not a function 解决方法:_config.yml中的depoloy设置（这是正确的前提，特别注意冒号后要有空格，repo配置时要写成https形式，type类型要是git）12345deploy: type: git repo: https://github.com/jack00000/jack00000.github.io.git branch: master message: blog git bash中应该输入的命令123npm install hexo-deployer-git --save//安装deploy的依赖文件hexo g//重新生成public文件hexo d//部署到github上 ##正确后的提示代码： ##如果实在不会hexo deploy，教你一种直接的方法： 1234打开blog目录找到public文件将public里面的文件上传到你新建的仓库xxxx.githu.io然后直接打开游览器，输入xxxx.github.io #blog文件，public文件，以及部署成功示例图 其实你的静态文件就是public里面的文件，只要把public的东西上传到github就行]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法]]></title>
    <url>%2F2017%2F01%2F02%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#markdown基本语法 ##1.插入图片形式的链接(视频之类的)123[![][pic]][douban][pic]:http://p1.bpimg.com/567571/f3788a440ee3c976.png[douban]: http://book.douban.com/subject/1141406/ ##2.插入文字形式的链接1[一段文字](https://www.baidu.com/) ##3.插入图片1![](http://p1.bpimg.com/567571/f3788a440ee3c976.png) ##来一波福利（点击图片有惊喜）：[![][pic]][douban][pic]:http://p1.bpimg.com/567571/0ad716c2741e1f64.png[douban]: https://v.qq.com/x/page/q03303qk3h3.html ##设置照片圆角]]></content>
  </entry>
  <entry>
    <title><![CDATA[绿点]]></title>
    <url>%2F2017%2F01%2F01%2F%E7%BB%BF%E7%82%B9%E5%9B%A2%E9%98%9F%2F</url>
    <content type="text"><![CDATA[#绿点团队圣诞趴 绿点团队（Bright Green），2013年11月创建于武汉工程大学，以“锐意进取不断创新”为核心精神的创新创业团队。在校友企业-深圳市纯水一号水处理科技有限公司喻遵军先生等提供的专项资金支持下组建，得到机电工程学院副院长杨红的支持和指导，入驻机电工程学院创新创业中心，由武汉工程大学副教授，网络红人张志作为第一任指导老师，强调学生自我管理，提倡项目制绩效导向，帮助孵化各种先进项目小组。秉承开放原则，以武汉工程大学机电工程学院为主导，吸收了计算机院、国际学院、管理学院、艺术学院、理学院、法商学院等多个院系，组成多元文化的精英团队。 来图片，不说话：]]></content>
  </entry>
  <entry>
    <title><![CDATA[github+hexo建站]]></title>
    <url>%2F2016%2F12%2F18%2Fgithub%2Bhexo%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[1. 安装nodo.js , git，学习markdown语言如何安装nodo.js 如何安装git什么是markdown如何在github上建立仓库(注意：仓库名一定要是 你的github用户名.github.io )如何使本地仓库与github的仓库建立关联 你要知道git的基本使用如：1234//先cd你的仓库，然后git add .//添加你的修改git commit -m&quot;注释&quot;// -m可以不用写注释git push//提交 2.安装HEXO12npm install hexo-cli -g //cmd中输入npm install hexo --save 3.hexo 命令1234567//打开一个文件夹hexo init blog//创建一个博客文件cd blog//打开博客文件npm install//生成node_modules依赖文件hexo server//部署到本地服务器hexo g//生成静态文件（上传到gihub的你建的仓库就可以用啦）hexo d//一键部署到服务器（前提在_config.yml中配置delopy） 4.theme的转换在github上搜索hexo theme将下载好的theme文件放在theme目录之下在配置文件config.yml找到theme变量将变量的值landspace改为刚下载的theme的文件名，如果这步出错，首先怀疑是不是theme出啦问题。（一定要记住保存，再打开git bash 搞事情）hexo g生成静态文件到public把pulic的文件传到github.io仓库就行 5.使用markdown写博文介绍一款不错的markdown在线编辑器cmd markdown几种流行的客户端（注意：写博文，文件名一定要是xxxx.md,不然hexo g不能识别你写的文件）markdown语言很简单，简单来说，就是不用鼠标就能完成简单排版的语言 6.一键部署到github在config.yml末尾处配置deploy12345deploy: type: git repo: https://github.com/jack00000/jack00000.github.io.git branch: master message: blog 在git bash中输入命令1234npm install hexo-deployer-git --savenpm install hexo-generator-searchdb --savehexo ghexo d 打开xxxx.github.io看下成功没。（注意：由于版本原因，type：github报错的话改成github）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Valine -- 一款极简的评论系统]]></title>
    <url>%2F2016%2F08%2F17%2FValine%20--%20%E4%B8%80%E6%AC%BE%E6%9E%81%E7%AE%80%E7%9A%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Hexo 中的解决方案 获取 APP ID 和 APP KEY 1.点击这里登录或注册Leancloud2.点这里创建应用，应用名看个人喜好。3.选择刚刚创建的应用&gt;设置&gt;选择应用 Key，然后你就能看到你的APP ID和APP KEY了，参考下图： 4.为了您的数据安全，请填写应用&gt;设置&gt;安全设置中的Web 安全域名(自己的域名就行)，如下图： 注：该解决方案基于Hexo主题–NexT.Pisces 配置_config.yml 主题目录下的/themes/next/_config.yml中添加：1234567891011121314151617181920212223242526272829valine: enable: true appId: Your_AppId appKey: Your_AppKey``` 修改comments.swig注：因为我没有其他的评论系统需求，所以将其他的删掉了。点这里，查看原主题的comments.swig备份文件打开/themes/next/layout/_partials/comments.swig，整个文件修改为：```swig&#123;% if page.comments %&#125; &lt;div class="comments" id="comments"&gt; &#123;% if (theme.valine and theme.valine.enable)%&#125; &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt; &lt;script src='/lib/Valine.min.js'&gt;&lt;/script&gt; &lt;script&gt; new Valine(&#123; av: AV, el: '.comments' , app_id: '&#123;&#123; theme.valine.appId &#125;&#125;', app_key: '&#123;&#123; theme.valine.appKey &#125;&#125;', placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!' &#125;); &lt;/script&gt; &#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 注：我引入的Valine路径为：/lib/Valine.min.js，是已将文件Valine.min.js放到了目录/themes/next/source/lib/下。 好了，差不多了，如果你看到你的文章页面出现了如下图所示的评论框，那么恭喜你，你已装逼成功，赶紧去炫耀吧。ヽ(￣▽￣)ﾉ 评论数据管理 插播一下，关于评论数据管理，请自行登录Leancloud应用管理。具体步骤：登录&gt;选择你创建的应用&gt;存储&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～]]></content>
  </entry>
  <entry>
    <title><![CDATA[how2j_jpa学习]]></title>
    <url>%2F2016%2F07%2F28%2Fhow2j_jpa%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[不写到博客总忘，没办法]]></title>
    <url>%2F2016%2F04%2F28%2F%E4%B8%8D%E5%86%99%E5%88%B0%E5%8D%9A%E5%AE%A2%E6%80%BB%E5%BF%98%EF%BC%8C%E6%B2%A1%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[遇坑集合 1.在hexo博客工程源码中，git add . 没有提交next主题下面的文件。 解决方法：后来发现这主要是next目录下有一个.git 目录，可能是被人给你这个目录的时候里面有了.git目录。删除.git目录。重新git add .就可以 把next放在里面还是提交不了 放外面提交成功。。。 2.Incorrect table definition; there can be only one TIMESTAMP column with CURRENT_TIMESTAMP in DEFAULT or ON UPDATE clause TIMESTAMP 字段 问题 在默认或更新时间戳时只能有一个时间戳列。 原因：数据库版本mysql 5.5 一个表中只能有一个TIMESTAMP类型字段可以有CURRENT_TIMESTAMP作为默认值. 只能有一列设置defalut，而且要放在第一位 解决方法：安装mysql 5.6 允许任何一个TIMESTAMP或者DATETIME类型字段将CURRENT_TIMESTAMP作为默认值了. 或只留一个timastamp字段的default12`create_time` timestamp not null default current_timestamp comment '创建时间',`update_time` timestamp not null default current_timestamp on update current_timestamp comment '修改时间', 未识别的网络 已连接 重启一下网卡 点禁用 网络受限 已连接 右键打开网络共享中心 无intenet 安全 开始-运行-输入”netsh winsock reset”,然后重启系统 确认可行 eclipse设置总教程 eclipse修改字体 窗口(Window)-首选项（Preferences）-&gt; General）-&gt; Appearence -&gt; Colors And Fonts -&gt; Java -&gt; Java Editor Text Font -&gt; Change : 接下来设置护眼颜色：window -&gt; preferences -&gt; General -&gt; Editors -&gt; Test Editors -&gt; Background color 命令行cmd强行删除文件 ra/s/q C:\文件名 目录名 eg： ra/s/q C:\users eclipse代码自动提示 打开 Eclipse -&gt; Window -&gt; Perferences 找到Java 下的 Editor 下的 Content Assist , 右边出现的选项中，有一个Auto activation triggers for Java: 8080 端口占用 netstat -ano|findstr “8080” idea生成类的构造函数和方法：(idea)alt +insert键 eclipse生成构造函数和方法 右键—&gt;source—&gt;Generate Constructors from Superclass，创建一个空参的构造函数；右键—&gt;source—&gt;Generate Constructors using Fields，创建一个带参数的构造函数。 (eclipse)shift+alt+s 数据库密码linux/admin 阿里云服务器密码Fangjun+ 老爸 生日 老历 2.15 3月21 左右 细姐 生日 老历 5.14 6月27 左右 大姐 生日 过年那天]]></content>
  </entry>
</search>
